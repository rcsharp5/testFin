{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e4f2be99914f151f0bb7","webpack:///../nodeProjects/testFin/services/testService/testService.js","webpack:///../nodeProjects/testFin/~/finsemble/lib/FrontEnd.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/clients/routerClientInstance.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/clients/routerClientConstructor.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/common/routerTransport.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/utils/util.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/common/validate.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/clients/storageClient.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/clients/baseClient.js","webpack:///../nodeProjects/testFin/~/finsemble/dist/clients/launcherClient.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,O;AACd,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAE;AACF,EAAC;;;;AAID;;;AAGA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACPA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAgE,8BAA8B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,iE;;;;;;ACtBA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAgD;;AAEhD,uCAA6C;AAC7C,sC;;AAEA;AACA;AACA;AACA;AACA,qCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,mBAAmB,GAAG,gHAAgH;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,sDAAqD;AACrD,sCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,4CAA2C;AAC3C,mBAAkB,gCAAgC,OAAO;AACzD;AACA,2CAA0C,wBAAwB;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,kDAAiD;AACjD,wDAAuD;AACvD;AACA,wCAAuC;AACvC,KAAI,OAAO;AACX;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,2CAA0C;AAC1C,KAAI;AACJ;AACA,mEAAkE;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oD;AACA,gEAA+D;AAC/D;AACA,0CAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA;AACA;AACA,6EAA4E;AAC5E,uCAAsC;AACtC,gDAA+C;AAC/C,O;AACA,yE;AACA;AACA;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA,IAAG;AACH,wCAAuC;AACvC;AACA,KAAI;AACJ,sEAAqE;AACrE;AACA,0DAAyD;AACzD,MAAK,OAAO;AACZ,wGAAuG;AACvG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA;AACA;AACA;AACA,M;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA,IAAG;AACH,2DAA0D;AAC1D;AACA,6DAA4D;AAC5D,KAAI,OAAO;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAwD;AACxD;AACA,oDAAmD;AACnD,oBAAmB,8BAA8B;AACjD;AACA;AACA,K;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA;AACA;AACA;AACA,M;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA,IAAG;AACH,2EAA0E;AAC1E;AACA,qDAAoD;AACpD,KAAI,OAAO;AACX,yEAAwE;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,mDAAkD;AAClD,yCAAwC;AACxC,KAAI;AACJ,+DAA8D;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,I;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,KAAI,QAAQ;AACZ;AACA;;AAEA;AACA;AACA;AACA,aAAY,IAAI;AAChB,aAAY,QAAQ;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,QAAQ;AACpB,aAAY,UAAU;AACtB,aAAY,UAAU;AACtB,aAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,8BAA8B;AAC7E;AACA;AACA;AACA;AACA;AACA,+D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,mBAAmB,GAAG,gHAAgH;AACpL;AACA;AACA;AACA,+CAA8C,mBAAmB;AACjE;AACA;AACA;AACA,gDAA+C,mBAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sC;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,KAAI,QAAQ;AACZ;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD,kDAAiD;AACjD;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,6C;AACV;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,I;;AAEA;AACA;AACA;AACA;AACA,I;;AAEA;AACA;AACA;AACA,8CAA6C;AAC7C,kDAAiD;AACjD,kDAAiD;AACjD,I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,I;AACA;;AAEA,6CAA4C;AAC5C;;AAEA,0C;;;;;;ACh4BA;AACA;AACA;;AAEA;AACA;AACA,oDAAmD;;AAEnD,sBAAqB;AACrB,gDAA+C;AAC/C;AACA;AACA,EAAC,OAAO;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB;;AAErB;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,aAAY,IAAI;AAChB,aAAY,IAAI;AAChB,aAAY,IAAI;AAChB;AACA;AACA;AACA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAwC;AACxC;AACA,oCAAmC;AACnC;AACA,2B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,aAAY,IAAI;AAChB,aAAY,IAAI;AAChB,aAAY,IAAI;AAChB,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA,qEAAoE;;AAEpE;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC;AAClC,kCAAiC,sCAAsC;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,IAAI;AAChB,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA,gEAA+D;;AAE/D;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH,+B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kC;;;;;;;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,oBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,GAAE;AACF;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA,aAAY,IAAI;AAChB,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,GAAE;;AAEF;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,sCAAqC,yBAAyB,EAAE;AAChE;AACA,oCAAmC,yBAAyB,EAAE;AAC9D,GAAE;;AAEF;AACA;AACA,cAAa,IAAI;AACjB,aAAY,IAAI;AAChB,cAAa,IAAI;AACjB;AACA;AACA,mDAAkD,aAAa;AAC/D;AACA;AACA;AACA,IAAG,mCAAmC;;AAEtC;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;;;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0EAAyE;AACzE;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAQ,iBAAiB,EAAE,cAAc,YAAY;AACrD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,IAAI;AAChB,aAAY,OAAO;AACnB,aAAY,KAAK;AACjB,aAAY,QAAQ;AACpB,cAAa,QAAQ,yCAAyC;AAC9D;AACA;AACA;AACA,0C;AACA;AACA;AACA,6DAA4D;AAC5D;AACA,yDAAwD;AACxD;AACA,0GAAyG;AACzG;AACA,yFAAwF;AACxF;AACA,6EAA4E;AAC5E,2B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC,oBAAmB,eAAe;AAClC;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA,6CAA4C;AAC5C,8DAA6D;AAC7D,wEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,IAAI;AAChB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,IAAI;AAChB,aAAY,OAAO;AACnB,cAAa,QAAQ,yCAAyC;AAC9D;AACA;AACA;AACA,gD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAmC;AACnC,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA,6CAA4C;AAC5C,8DAA6D;AAC7D,wEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH,qBAAoB;AACpB;AACA;;AAEA,2B;;;;;;;ACvJA;AACA,kDAAiD;AACjD,uCAA6C;AAC7C,sC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,iBAAiB;AACtC,oDAAmD,iCAAiC;AACpF,6CAA4C,0BAA0B;AACtE,gDAA+C,6BAA6B;AAC5E;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,iBAAiB;AAC7B,aAAY,OAAO;AACnB,aAAY,IAAI;AAChB,aAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,sDAAsD;AACjG;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,aAAY,iBAAiB;AAC7B,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;AACA;AACA,2CAA0C,uCAAuC;AACjF;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,I;AACA,mDAAkD,oCAAoC;AACtF;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,aAAY,iBAAiB;AAC7B,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;AACA;AACA,8CAA6C,uCAAuC;AACpF;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA,EAAC;AACD;AACA;AACA;;;;;;;;;;AC9JA;AACA,+CAA8C;AAC9C,uCAA6C;AAC7C,sC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kCAAkC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,QAAQ;AACpC;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;;;AAIA,yB;;;;;;AC3EA;AACA;AACA;AACA,8CAA6C;AAC7C,uCAA6C;AAC7C;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,QAAQ,yKAAyK,wBAAwB;AACvN,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;;AAEA;AACA;AACA,8BAA6B,UAAU;AACvC,wBAAuB,QAAQ;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAY,SAAS;AACrB;AACA,mB;AACA;AACA;AACA;AACA,IAAG;AACH,MAAK;AACL;AACA;AACA;;AAEA,kDAAiD;AACjD;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,6JAA4J,0BAA0B;AACtL,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA,yDAAwD;AACxD;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA,mCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAE;AACF;AACA,EAAC;AACD;AACA;;AAEA,iC","file":"test/testService.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e4f2be99914f151f0bb7","//replace with import when ready\r\nvar Finsemble = require('finsemble/lib/FrontEnd');\r\n\r\nvar baseService = Finsemble.baseService;\r\nvar RouterClient = Finsemble.Clients.RouterClient;\r\nvar StorageClient = Finsemble.Clients.StorageClient;\r\nvar launcherClient = Finsemble.Clients.launcherClient;\r\n\r\n/**\r\n * @namespace\r\n * @property {Object} \r\n * @property {string}\r\n */\r\nfunction TestService() {\r\n\tvar self = this;\r\n\r\n\tthis.initialize = function (cb) {\r\n\t\tcb();\r\n\t};\r\n\r\n};\r\n\r\n//define the rest of your service's functionality here.\r\nTestService.prototype = new baseService();\r\nvar testService = new TestService(\"TestService\");\r\n\r\n\r\ntestService.setOnConnectionComplete(function (callback) {\r\n\tlinker.initialize(function () {\r\n\t\tcallback();\r\n\t});\r\n});\r\n\r\n\r\n\r\ntestService.start();\r\n\r\n\r\nwindow.testService = testService;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/services/testService/testService.js\n// module id = 0\n// module chunks = 0","exports = function () {\r\n\tthis.baseService = require(\"../dist/services/baseService\");\r\n\tthis.Clients = {\r\n\t\tRouterClient: require(\"../dist/clients/routerClientInstance\"),\r\n\t\tStorageClient: require(\"../dist/clients/storageClient\"),\r\n\t\tlauncherClient: require(\"../dist/clients/launcherClient\")\r\n\t};\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/lib/FrontEnd.js\n// module id = 1\n// module chunks = 0","// -------------------------------------------------------------------------------------------\r\n// Copyright 2012-2017 by ChartIQ, Inc\r\n// -------------------------------------------------------------------------------------------\r\n\r\n/**\r\n * @introduction\r\n * <h2>Router Client Instance</h2>\r\n * Exports a single shared instance of the router client.  See {@link RouterClientConstructor} for the complete API definition with examples.\r\n *\r\n * Example:\r\n *\r\n *\t// get a shared instance of RouterClient (shared within the containing component or service)\r\n *\tvar RouterClient = require('./routerClientInstance');\r\n *\r\n * @namespace RouterClientInstance\r\n * @shouldBePublished false\r\n */\r\n\r\n\"use strict\";\r\n\r\nvar RouterClientConstructor = require('./routerClientConstructor');\r\n\r\nmodule.exports = new RouterClientConstructor(\"RouterSingleton\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/clients/routerClientInstance.js\n// module id = 2\n// module chunks = 0","// -------------------------------------------------------------------------------------------\r\n// Copyright 2012-2017 by ChartIQ, Inc\r\n// -------------------------------------------------------------------------------------------\r\n\r\n\"use strict\";\r\nvar RouterTransport = require(\"../common/routerTransport\");\r\nvar Utils = require(\"../utils/util\");\r\nvar console = new Utils.Console(\"RouterClient\"); // Finsemble console\r\n\r\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\r\nvar validate = new Validate(console); \r\n\r\n/**\r\n * @introduction\r\n * <h2>Router Client Constructor</h2>\r\n * This modules contains the RouterClient for sending and receiving events between Finsembe components and services. The constructor returns one instance\r\n * of a router client. The related {@link RouterClientInstance} Module behaves like a RouteClient singleton, always returning the same instance\r\n * of the router client (within the same component/service window).\r\n *\r\n * The router client interfaces to the Finsemble router service, which routes event messages between all clients. Although it's transparent, the router uses the <a href=\"http://cdn.openfin.co/jsdocs/stable/fin.desktop.module_InterApplicationBus.html\">OpenFin Bus</a> and SharedWorker threads for transporting events between clients. \r\n *\r\n * More examples are shown in the <a href=tutorial-eventRouter.html>Event Router Tutorial</a>.\r\n *\r\n * @example\r\n *\r\n * // create an instance of Router Client\r\n * RouterClientConstructor = require('./routerClientConstructor');\r\n * RouterClient = new RouterClientConstructor(\"clientname\");\r\n *\r\n * // add a listener for incoming event on the specified channel\r\n * RouterClient.addListener(\"myListenChannel\",eventHandler);\r\n * //\r\n * // transmit event to all listeners on specified channel\r\n * RouterClient.transmit(\"myListenChannel\", transmitEvent);\r\n * \r\n * // add server for incoming events on the specified channel\r\n * RouterClient.addServer(\"myServerChannel\",eventHandler);\r\n *\r\n * // query the server on the specified channel\r\n * RouterClient.query(\"myServerChannel\",queryEvent, responseEventHandler);\r\n *\r\n * // create Subscribe-Publish server for specified topic\r\n * RouterClient.addPubSubServer(\"myTopic\");\r\n *\r\n * // create Subscribe-Publish server for specified wildcard topic (i.g. using RegEx), specifiying all the optional callback\r\n * RouterClient.addPubSubServer(\\/topicA*\\/, { \"State\": \"start\" }, { subscribeCallback:subscribeCallback, publishCallback:publishCallback, unsubscribeCallback:unsubscribeCallback } );\r\n *\r\n * // subscribe to the specified PubSub server for specified topic\r\n * RouterClient.subscribe(\"myTopic\",notifyEventHandler);\r\n *\r\n * // publish to the specified PubSub server for specified topic\r\n * RouterClient.publish(\"myTopic\",publishEvent);\r\n *\r\n * @constructor\r\n * @publishedName RouterClient\r\n * @param {string} thisClientName router client name for human readable messages\r\n * @param {string} transportName router transport name (usually this is autoconfigured internally but can be selected for testing or special configurations)\r\n */\r\nvar RouterClientConstructor = function (thisClientName, transportName) {\r\n\tvalidate.args(thisClientName, \"string\", transportName, \"string=\");\r\n\r\n\t///////////////////////////\r\n\t// Private Data\r\n\t///////////////////////////\t\r\n\tvar mapListeners = {};\r\n\tvar mapServers = {};\r\n\tvar mapPubSubServers = {};\r\n\tvar mapPubSubServerState = {};\r\n\tvar mapPubSubServerRegEx = {};\r\n\tvar pubsubListOfSubscribers = {};\r\n\tvar mapSubscribersID = {};\r\n\tvar mapSubscribersTopic = {};\r\n\tvar mapQueryResponses = {};\r\n\tvar clientIDCounter = 1000;\r\n\tvar clientName;\r\n\tvar transport;\r\n\tvar self = this;\r\n\r\n\t/////////////////////////////////////////////////////////////////////\r\n\t// Private Message Contructors for Communicating with RouterService\r\n\t/////////////////////////////////////////////////////////////////////\r\n\tfunction AddListenerMessage(channel) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"addListener\",\r\n\t\t\t\"channel\": channel\r\n\t\t};\r\n\t}\r\n\tfunction TransmitMessage(toChannel, data) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"transmit\",\r\n\t\t\t\"channel\": toChannel\r\n\t\t};\r\n\t\tthis.data = data;\r\n\t}\r\n\tfunction RemoveListenerMessage(channel) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"removeListener\",\r\n\t\t\t\"channel\": channel\r\n\t\t};\r\n\t}\r\n\tfunction AddServerMessage(channel) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"addServer\",\r\n\t\t\t\"channel\": channel\r\n\t\t};\r\n\t}\r\n\tfunction QueryMessage(queryID, channel, data) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"query\",\r\n\t\t\t\"queryID\": queryID,\r\n\t\t\t\"channel\": channel\r\n\t\t};\r\n\t\tthis.data = data;\r\n\t}\r\n\tfunction QueryResponseMessage(queryID, error, data) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"queryResponse\",\r\n\t\t\t\"queryID\": queryID,\r\n\t\t\t\"error\": error\r\n\t\t};\r\n\t\tthis.data = data;\r\n\t}\r\n\tfunction RemoveServerMessage(channel) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"removeServer\",\r\n\t\t\t\"channel\": channel\r\n\t\t};\r\n\t}\r\n\tfunction SubscribeMessage(subscribeID, topic) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"subscribe\",\r\n\t\t\t\"subscribeID\": subscribeID,\r\n\t\t\t\"topic\": topic\r\n\t\t};\r\n\t}\r\n\tfunction UnsubscribeMessage(subscribeID, topic) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"unsubscribe\",\r\n\t\t\t\"subscribeID\": subscribeID,\r\n\t\t\t\"topic\": topic\r\n\t\t};\r\n\t}\r\n\tfunction PublishMessage(topic, data) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"publish\",\r\n\t\t\t\"topic\": topic\r\n\t\t};\r\n\t\tthis.data = data;\r\n\t}\r\n\tfunction NotifyMessage(subscribeID, topic, error, data) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"notify\",\r\n\t\t\t\"subscribeID\": subscribeID,\r\n\t\t\t\"topic\": topic,\r\n\t\t\t\"error\":error\r\n\t\t};\r\n\t\tthis.data = data;\r\n\t}\r\n\tfunction AddPubSubServerMessage(topic) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"addPubSubServer\",\r\n\t\t\t\"topic\": topic\r\n\t\t};\r\n\t}\r\n\tfunction RemovePubSubServerMessage(topic) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"removePubSubServer\",\r\n\t\t\t\"topic\": topic\r\n\t\t};\r\n\t}\r\n\tfunction JoinGroupMessage(group) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"joinGroup\",\r\n\t\t\t\"group\": group\r\n\t\t};\r\n\t}\r\n\tfunction LeaveGroupMessage(group) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"leaveGroup\",\r\n\t\t\t\"group\": group\r\n\t\t};\r\n\t}\r\n\tfunction GroupTransmitMessage(group, toChannel, message, data) {\r\n\t\tthis.header = {\r\n\t\t\t\"origin\": clientName,\r\n\t\t\t\"type\": \"groupTransmit\",\r\n\t\t\t\"group\": group,\r\n\t\t\t\"channel\": toChannel\r\n\t\t};\r\n\t\tthis.data = data;\r\n\t}\r\n\r\n\t//////////////////////\r\n\t// Private Functions\r\n\t//////////////////////\r\n\r\n\t// router client is being terminated so cleanup\t\r\n\tfunction destructor(event) {\r\n\t\tconsole.info(\"shutting down on event: \" + JSON.stringify(event));\r\n\t\tself.disconnectAll(); // this will let the router know the client is terminating\r\n\t\tconsole.debug(\"shutting down complete\");\r\n\t}\r\n\r\n\t// called once on router-client creation\r\n\tfunction constructor(thisClientName, transportName) {\r\n\t\tclientName = Utils.getUniqueName(thisClientName);\r\n\r\n\t\tif (typeof(transportName) === 'undefined') {\r\n\t\t\ttransport = RouterTransport.getRecommendedTransport(incomingMessageHandler, clientName, \"RouterService\");\r\n\t\t} else {\r\n\t\t\ttransport = RouterTransport.getTransport(transportName, incomingMessageHandler, clientName, \"RouterService\");\r\n\t\t}\r\n\r\n\t\t// catch \"window closing\" event so can cleanup\t\r\n\t\tvar finWindow = fin.desktop.Window.getCurrent();\r\n\t\t//finWindow.addEventListener(\"closed\", destructor); // this is the correct event to catch but currently doesn't work on mac\r\n\t\twindow.onbeforeunload = destructor; // this works for mac\r\n\r\n\t\tconsole.info(\"starting \" + clientName + \" with transport \" + transport.identifier() );\r\n\t}\r\n\r\n\t// provides unique id within one router client for queries\r\n\tfunction clientID() {\r\n\t\treturn clientName + \".\" + (++clientIDCounter);\r\n\t}\r\n\r\n\t// returns true if this routerClient originated the message\r\n\tfunction originatedHere() {\r\n\t\treturn this.header.origin ===  this.header.lastClient;\r\n\t}\r\n\r\n\t// invoke client callbacks in the input array (that are attached to a specific channel and listener type) \r\n\tfunction invokeListenerCallbacks(map, message) {\r\n\t\tvar clientCallbackArray = map[message.header.channel];\r\n\t\tif (clientCallbackArray === undefined) {\r\n\t\t\tconsole.warn(\"no handler defined for incoming message\" + JSON.stringify(message));\r\n\t\t} else {\r\n\t\t\tmessage.originatedHere = originatedHere;// add local function to test origin\r\n\t\t\tfor (var i = 0; i < clientCallbackArray.length; i++) { // for each callback defined for the channel\r\n\t\t\t\tconsole.debug(\"invoke listener callback for incoming transmit: \" + JSON.stringify(message));\r\n\t\t\t\tclientCallbackArray[i](null, message); // invoke the callback; the error parameter is always null for this case\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sendQueryResponse(err, responseData) {\r\n\t\tconsole.debug(\"send query response: \" + JSON.stringify(responseData));\r\n\t\tsendToRouterService(new QueryResponseMessage(this.header.queryID, err, responseData));\r\n\t}\r\n\r\n\t// invoke server-listener callback (attached to a specific channel) \r\n\tfunction invokeServerCallback(map, queryMessage) {\r\n\t\tvar serverCallback = map[queryMessage.header.channel];\r\n\t\tif (serverCallback === undefined) {\r\n\t\t\tconsole.warn(2, \"no server defined for incoming query message: \" + JSON.stringify(queryMessage));\r\n\t\t} else {\r\n\t\t\tif (!queryMessage.header.error) {\r\n\t\t\t\tqueryMessage.originatedHere = originatedHere; // add local function to test origin\r\n\t\t\t\tqueryMessage.sendQueryResponse = sendQueryResponse; // add callback function to message so server can respond to query\r\n\t\t\t\tconsole.debug(\"invoke server callback for incoming query: \" + JSON.stringify(queryMessage));\r\n\t\t\t\tserverCallback(null, queryMessage); // invoke the callback (no error)\r\n\t\t\t} else { // invoke the callback with error since  flag in message (from router service)\r\n\t\t\t\tserverCallback(queryMessage.header.error, null);\r\n\t\t\t\tconsole.debug(\"server callback with RouterService error: \" + JSON.stringify(queryMessage.header));\r\n\t\t\t\tdelete map[queryMessage.header.channel]; // this is a bad server (e.g. duplicate) so remove it\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// add a callbackHandler into the query-response map for the given queryID\r\n\tfunction addQueryResponseCallBack(map, queryID, responseCallback) {\r\n\t\tmap[queryID] = responseCallback;\r\n\t}\r\n\r\n\t// invoke query-response callback (that is attached to a specific channel and listener type) \r\n\tfunction invokeQueryResponseCallback(map, responseMessage) {\r\n\t\tvar clientCallback = map[responseMessage.header.queryID];\r\n\t\tif (clientCallback === undefined) {\r\n\t\t\tconsole.warn(\"no handler defined for query response: \" + JSON.stringify(responseMessage));\r\n\t\t} else {\r\n\t\t\tif (!responseMessage.header.error) {\r\n\t\t\t\tconsole.debug(\"invoke queryResponse callback for query: \" + JSON.stringify(responseMessage));\r\n\t\t\t\tclientCallback(null, responseMessage); // invoke the callback passing the response message\r\n\t\t\t} else {\r\n\t\t\t\tconsole.debug(\"queryResponse callback with RouterService error: \" + JSON.stringify(responseMessage.header));\r\n\t\t\t\tclientCallback(responseMessage.header.error, responseMessage); // error from router service so pass it back instead of a message\r\n\t\t\t}\r\n\t\t\tdelete map[responseMessage.header.queryID];\r\n\t\t}\r\n\t}\r\n\r\n\t// add server callbackHandler for the given channel\r\n\tfunction addServerCallBack(map, channel, callback) {\r\n\t\tvar status = false;\r\n\t\tvar clientCallback = map[channel];\r\n\t\tif (clientCallback === undefined) {\r\n\t\t\tmap[channel] = callback;\r\n\t\t\tstatus = true;\r\n\t\t}\r\n\t\treturn status;\r\n\t}\r\n\r\n\t// support function for sendNotifyToSubscriber -- maintains local list of subscribers for pubsub server\r\n\tfunction addToSubpubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\r\n\t\tif (!(topic in pubsubListOfSubscribers)) {\r\n\t\t\tpubsubListOfSubscribers[topic] = [subscribeID];\r\n\t\t} else {\r\n\t\t\tpubsubListOfSubscribers[topic].push(subscribeID);\r\n\t\t}\r\n\t}\r\n\r\n\t// support function for addPubSubServer -- add pubsub server callbackHandler for the given channel\r\n\tfunction addPubSubServerCallBack(topic, subscribeCallback, publishCallback, unsubscribeCallback) {\r\n\t\tvar status = false;\r\n\t\tvar callbacks = mapPubSubServers[topic.toString()];\r\n\t\tif (callbacks === undefined) {\r\n\t\t\tif (topic instanceof RegExp) {\r\n\t\t\t\tmapPubSubServerRegEx[topic.toString()] = topic; \r\n\t\t\t\tconsole.debug(\"RegEx added for topic \" + topic.toString()); // Note: topic may be a RegEx, so use toString() where applicable\r\n\t\t\t}\r\n\t\t\tmapPubSubServers[topic.toString()] = { \"subscribeCallback\":subscribeCallback, \"publishCallback\": publishCallback, \"unsubscribeCallback\":unsubscribeCallback };\r\n\t\t\tstatus = true;\r\n\t\t}\r\n\t\treturn status;\r\n\t}\r\n\r\n\t// callback function for invokeSubscribePubSubCallback to notify new subscriber\r\n\tfunction sendNotifyToSubscriber(err, notifyData) {\r\n\t\tsendToRouterService(new NotifyMessage(this.header.subscribeID, this.header.topic, err, notifyData));\r\n\t\tif (!err) {\r\n\t\t\t// add new subscriber to list\r\n\t\t\taddToSubpubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\r\n\t\t\tconsole.debug(\"subscription added pubsub server: \" + JSON.stringify(this));\r\n\t\t} else {\r\n\t\t\tconsole.debug(\"subscribe rejected by pubsub server: \" + JSON.stringify(this));\r\n\t\t}\r\n\t}\r\n\r\n\t// for incoming subscribe: invoke notify callback for pubsub server\r\n\tfunction invokeSubscribePubSubCallback(subscribeMessage) {\r\n\t\tvar callbacks = mapPubSubServers[subscribeMessage.header.topic];\r\n\r\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\r\n\t\t\tfor (var key in mapPubSubServerRegEx) {\r\n\t\t\t\tif (mapPubSubServerRegEx[key].test(subscribeMessage.header.topic)) {\r\n\t\t\t\t\tcallbacks = mapPubSubServers[key];\r\n\t\t\t\t\tvar initialState = mapPubSubServerState[subscribeMessage.header.topic]; // may already be initial state defined from publish\r\n\t\t\t\t\tif (initialState === undefined) { // if there isn't already state defined then use default from regEx\r\n\t\t\t\t\t\tinitialState = mapPubSubServerState[key]; // initialize the state from RegEx topic\t\r\n\t\t\t\t\t}\t\r\n\t\t\t\t\tmapPubSubServerState[subscribeMessage.header.topic] = initialState; \r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (callbacks === undefined) { // if still undefined\r\n\t\t\tconsole.warn(\"no pubsub server defined for incoming subscribe message: \" + JSON.stringify(subscribeMessage));\r\n\t\t} else {\r\n\t\t\tif (subscribeMessage.header.error) { // the router service uses the subscribe message in this case to return a pubsub error (ToDO: consider a generic error message)\r\n\t\t\t\tconsole.warn(\"pubsub error received from router service: \" + JSON.stringify(subscribeMessage.header.error));\r\n\t\t\t} else {\r\n\t\t\t\tsubscribeMessage.sendNotifyToSubscriber = sendNotifyToSubscriber; // add callback function to message so pubsub server can respond with Notify message\r\n\t\t\t\tif (callbacks.subscribeCallback) {\r\n\t\t\t\t\tcallbacks.subscribeCallback(null, subscribeMessage); // invoke the callback (no error)\r\n\t\t\t\t} else { // since no subscribe callback defined, use default functionality\r\n\t\t\t\t\tsubscribeMessage.sendNotifyToSubscriber(null,mapPubSubServerState[subscribeMessage.header.topic]); // must invoke from message to set this properly \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// support function for removeSubscriber callback --  remove one subscribeID from array for the given subscription topic\r\n\tfunction removeFromSubpubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\r\n\t\tvar removed = false;\r\n\t\tif (topic in pubsubListOfSubscribers) {\r\n\t\t\tvar list = pubsubListOfSubscribers[topic];\r\n\t\t\tfor (var i = 0; i < list.length; i++) {\r\n\t\t\t\tif (subscribeID === list[i]) {\r\n\t\t\t\t\tlist.splice(i, 1);\r\n\t\t\t\t\tif (list.length === 0) {\r\n\t\t\t\t\t\tdelete pubsubListOfSubscribers[topic];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tremoved = true;\r\n\t\t\t\t\tconsole.debug(\"removeListener to \" + topic + \" from \" + JSON.stringify(subscribeID));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!removed) {\r\n\t\t\tconsole.warn(\"tried to remove non-existance listener on \" + topic + \" from \" + JSON.stringify(subscribeID));\r\n\t\t}\r\n\t}\r\n\r\n\t// callback function for invokeUnsubscribePubSubCallback to remove the subscriber from the subscription\t\r\n\tfunction removeSubscriber() {\r\n\t\tremoveFromSubpubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\r\n\t}\r\n\t\r\n\t// for incoming unsubscribe: invoke unsubscribe callback for pubsub servier\r\n\tfunction invokeUnsubscribePubSubCallback(unsubscribeMessage) {\r\n\t\tvar callbacks = mapPubSubServers[unsubscribeMessage.header.topic];\r\n\r\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\r\n\t\t\tfor (var key in mapPubSubServerRegEx) {\r\n\t\t\t\tif (mapPubSubServerRegEx[key].test(unsubscribeMessage.header.topic)) {\r\n\t\t\t\t\tcallbacks = mapPubSubServers[key];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (callbacks === undefined) { // if still undefined\r\n\t\t\tconsole.warn(\"no pubsub server defined for incoming unsubscribe message: \" + JSON.stringify(unsubscribeMessage));\r\n\t\t} else {\r\n\t\t\tunsubscribeMessage.removeSubscriber = removeSubscriber; // add callback function to message for pubsub server (but must always remove)\r\n\t\t\tif (callbacks.unsubscribeCallback) {\r\n\t\t\t\tcallbacks.unsubscribeCallback(null, unsubscribeMessage); // invoke the callback (no error)\r\n\t\t\t} else { // since no unsubscribe callback defined, use default functionality\r\n\t\t\t\tunsubscribeMessage.removeSubscriber();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// callback function for invokePublishPubSubCallback to send Notify \t\r\n\tfunction sendNotifyToAllSubscribers(err, notifyData) {\r\n\t\tif (!err) {\r\n\t\t\tmapPubSubServerState[this.header.topic] = notifyData; // store new state\r\n\t\t\tvar listOfSubscribers = pubsubListOfSubscribers[this.header.topic];\r\n\t\t\tif (typeof(listOfSubscribers) !== 'undefined') { // confirm subscribers to send to, if none then nothing to do\r\n\t\t\t\tfor (var i = 0; i < listOfSubscribers.length; i++) {\r\n\t\t\t\t\tsendToRouterService(new NotifyMessage(listOfSubscribers[i], this.header.topic, err, notifyData));\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t} else {\r\n\t\t\tconsole.debug(\"income publish rejected by pubsub server: \" + JSON.stringify(err));\r\n\t\t}\r\n\t}\r\n\r\n\t// for incoming Publish: invoke publish callback for pubsub servier\r\n\tfunction invokePublishPubSubCallback(publishMessage) {\r\n\t\tvar callbacks = mapPubSubServers[publishMessage.header.topic];\r\n\r\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\r\n\t\t\tfor (var key in mapPubSubServerRegEx) {\r\n\t\t\t\tif (mapPubSubServerRegEx[key].test(publishMessage.header.topic)) {\r\n\t\t\t\t\tcallbacks = mapPubSubServers[key];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (callbacks === undefined) { // if still undefined\r\n\t\t\tconsole.warn(\"no pubsub server defined for incoming publish message: \" + JSON.stringify(publishMessage));\r\n\t\t} else {\r\n\t\t\tpublishMessage.sendNotifyToAllSubscribers = sendNotifyToAllSubscribers; // add callback function to message so pubsub server can respond to publish\r\n\t\t\tif (callbacks.publishCallback) {\r\n\t\t\t\tcallbacks.publishCallback(null, publishMessage); // invoke the callback (no error)\r\n\t\t\t} else { // since no pubish callback defined, use default functionality\r\n\t\t\t\tpublishMessage.sendNotifyToAllSubscribers(null,publishMessage.data); // must call from publish message (like a callback) so 'this' is properly set\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// for incoming Notify: invoke notify callback (that are attached to a specific channel and listener type) \r\n\tfunction invokeNotifyCallback(mapSubscribersID, notifyMessage) {\r\n\t\tvar notifyCallback = mapSubscribersID[notifyMessage.header.subscribeID];\r\n\t\tif (notifyCallback === undefined) {\r\n\t\t\tconsole.warn(\"no subscription handler defined for incoming notify: \" + JSON.stringify(notifyMessage));\r\n\t\t} else {\r\n\t\t\tif (!notifyMessage.header.error) {\r\n\t\t\t\tnotifyMessage.originatedHere = originatedHere;// add local function to test origin\r\n\t\t\t\tnotifyCallback(null, notifyMessage); // invoke the callback passing the response message\r\n\t\t\t} else {\r\n\t\t\t\tnotifyCallback(notifyMessage.header.error, notifyMessage); // error from router service so pass it back instead of a message\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// outgoing Unsubscribe: remove subscriber callbackHandler for the given channel\r\n\tfunction removeSubscriberCallBack(mapSubscribersID, subscribeID) {\r\n\t\tvar status = false;\r\n\t\tvar notifyCallback = mapSubscribersID[subscribeID];\r\n\t\tif (notifyCallback !== undefined) {\r\n\t\t\tdelete mapSubscribersID[subscribeID];\r\n\t\t\tstatus = true;\r\n\t\t}\r\n\t\treturn status;\r\n\t}\r\n\r\n\t// for outgoing addSubscriber -- add a callback Handler for the subscribe\r\n\tfunction addSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic) {\r\n\t\tmapSubscribersID[subscribeID] = notifyCallback;\r\n\t\tmapSubscribersTopic[subscribeID] = topic;\r\n\r\n\t}\r\n\t\r\n\t// for removePubSubServer: remove server callbackHandler for the given channel\r\n\tfunction removeServerCallBack(map, channel) {\r\n\t\tvar status = false;\r\n\t\tvar clientCallback = map[channel];\r\n\t\tif (clientCallback !== undefined) {\r\n\t\t\tdelete map[channel];\r\n\t\t\tstatus = true;\r\n\t\t}\r\n\t\treturn status;\r\n\t}\r\n\r\n\t// for addListener: add a callbackHandler into the specified map (which depends on listener type) for the given channel\r\n\tfunction addListenerCallBack(map, channel, callback) {\r\n\t\tvar firstChannelClient = false;\r\n\t\tvar clientCallbackArray = map[channel];\r\n\t\tif (clientCallbackArray === undefined) {\r\n\t\t\tmap[channel] = [callback];\r\n\t\t\tfirstChannelClient = true;\r\n\t\t} else {\r\n\t\t\tclientCallbackArray.push(callback);\r\n\t\t}\r\n\t\treturn firstChannelClient;\r\n\t}\r\n\r\n\t// for removeListener: remove a callbackHandler from the specified map (which depends on listener type) for the given channel\r\n\tfunction removeListenerCallBack(map, channel, callback) {\r\n\t\tvar lastChannelClient = false;\r\n\t\tvar clientCallbackArray = map[channel];\r\n\t\tif (clientCallbackArray !== undefined) {\r\n\t\t\tvar index = clientCallbackArray.indexOf(callback);\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tclientCallbackArray.splice(index, 1);\r\n\t\t\t\tif (clientCallbackArray.length === 0) {\r\n\t\t\t\t\tlastChannelClient = true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"no listener defined for channel: \" + channel);\r\n\t\t\t}\r\n\t\t} \r\n\t\treturn lastChannelClient;\r\n\t}\r\n\r\n\t// route incoming message to appropriate callback, which depends on the message type and channel\r\n\tfunction routeIncomingMessage(incomingMessage) {\r\n\t\tconsole.debug(\"Incoming Message: \" + incomingMessage.header.type, 5);\r\n\t\tswitch (incomingMessage.header.type) {\r\n\t\t\tcase \"transmit\":\r\n\t\t\t\tinvokeListenerCallbacks(mapListeners, incomingMessage);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"query\":\r\n\t\t\t\tinvokeServerCallback(mapServers, incomingMessage);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"queryResponse\":\r\n\t\t\t\tinvokeQueryResponseCallback(mapQueryResponses, incomingMessage);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"notify\":\r\n\t\t\t\tinvokeNotifyCallback(mapSubscribersID, incomingMessage);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"publish\":\r\n\t\t\t\tinvokePublishPubSubCallback(incomingMessage);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"subscribe\":\r\n\t\t\t\tinvokeSubscribePubSubCallback(incomingMessage);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"unsubscribe\":\t\r\n\t\t\t\tinvokeUnsubscribePubSubCallback(incomingMessage);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t}\r\n\t}\r\n\r\n\t// *** all incoming messages from underlying transport arrive here ***\r\n\t// although incoming transport information is available, it is not passed on because not needed \r\n\tfunction incomingMessageHandler(incomingTransportInfo, message) {\r\n\t\t// ToDo: good place to put a function to validate incoming message/data\r\n\t\tmessage.header.lastClient = clientName; // add last client for diagnostics\r\n\t\trouteIncomingMessage(message);\r\n\t}\r\n\r\n\t// *** all outbound messages exit here though the appropriate transport ***\r\n\tfunction sendToRouterService(message) {\r\n\t\tconsole.debug(\"Outgoing Message: \" + JSON.stringify(message.header.type), 5);\r\n\t\ttransport.send(message);\r\n\t}\r\n\r\n\r\n\t/////////////////////////////////////////////\r\n\t// Public Functions -- The Router Client API\r\n\t/////////////////////////////////////////////\r\n\r\n\t/**\r\n\t * Set route client name to human readable form for better diagnotics.  An random id is concatenated on the end to ensure uniqueness.\r\n\t * \r\n\t * @param {string} newClientName\r\n\t * @example\r\n\t *\r\n\t * RouterClient.setClientName(\"MyComponent\");\r\n\t */\r\n\tthis.setClientName = function (newClientName) {\r\n\t\tvalidate.args(thisClientName, \"string\");\r\n\t\tclientName = Utils.getUniqueName(newClientName);\r\n\t\tconsole.info(\"Route Client name set to \" + clientName);\r\n\t};\r\n\r\n\t/**\r\n\t * Add listener for incoming event on specified channel.\r\n\t * \r\n\t * @param {string} channel\r\n\t * @param {function} eventHandler\r\n\t * @example\r\n\t *\r\n\t * RouterClient.addListener(\"SomeChannelName\", function (error, message) {\r\n\t * \t\t// process incoming channel message\t\t\r\n\t * });\r\n\t *\r\n\t */\r\n\tthis.addListener = function(channel, eventHandler) {\r\n\t\tconsole.debug(\"addListener to channel \" + channel);\r\n\t\tvalidate.args(channel, \"string\", eventHandler, \"function\");\r\n\t\tvar firstChannelClient = addListenerCallBack(mapListeners, channel, eventHandler);\r\n\t\tif (firstChannelClient) {\r\n\t\t\tsendToRouterService(new AddListenerMessage(channel));\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Transmit event to specified channel.\r\n\t * \r\n\t * @param {string} toChannel\r\n\t * @param {any} event -- object or primitive type to be transmitted\r\n\t * @example\r\n\t *\r\n\t * RouterClient.transmit(\"SomeChannelName\", channelMessage);\r\n\t *\r\n\t */\r\n\tthis.transmit = function (toChannel, event) {\r\n\t\tconsole.debug(\"transmit to channel \" + toChannel + \" event: \" + JSON.stringify(event));\r\n\t\tvalidate.args(toChannel, \"string\", event, \"any\");\r\n\t\tsendToRouterService(new TransmitMessage(toChannel, event));\r\n\t};\r\n\r\n\t/**\r\n\t * Remove event listener from specified channel.\r\n\t * \r\n\t * @param {string} channel\r\n\t * @param {function} eventHandler for the listener\r\n\t */\r\n\tthis.removeListener = function (channel, eventHandler) {\r\n\t\tconsole.debug(\"removelistener to channel \" + channel);\r\n\t\tvalidate.args(channel, \"string\", eventHandler, \"function\");\r\n\t\tvar lastChannelListener = removeListenerCallBack(mapListeners, channel, eventHandler);\r\n\t\tif (lastChannelListener) {\r\n\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\r\n\t\t}\r\n\t};\r\n\r\n\t/** \r\n\t * Add event server to the specified channel (only one server allowed per channel)\r\n\t * \r\n\t * @param {string} channel\r\n\t * @param {function} queryEventHandler\r\n\t * @example\r\n\t *\r\n\t * RouterClient.addServer(\"ServerChannelName\", function (error, queryMessage) {\r\n\t *\tif (error) {\r\n\t *\t\tconsole.log('addServer failed: ' + JSON.stringify(error));\r\n\t *\t} else {\r\n\t *\t\t// process income query message\r\n\t *\t\t// then send query response\r\n\t *\t\tqueryMessage.sendQueryResponse(null, queryMessage.data);\r\n\t *\t}\r\n\t * });\r\n\t *\r\n\t */\r\n\tthis.addServer = function (channel, queryEventHandler) {\r\n\t\tconsole.debug(\"addServer for channel \" + channel);\r\n\t\tvalidate.args(channel, \"string\", queryEventHandler, \"function\");\r\n\t\tvar status = addServerCallBack(mapServers, channel, queryEventHandler);\r\n\t\tif (status) {\r\n\t\t\tsendToRouterService(new AddServerMessage(channel));\r\n\t\t} else {\r\n\t\t\tconsole.warn(\"Server already locally defined for channel \" + channel);\r\n\t\t\tqueryEventHandler({\r\n\t\t\t\t\"RouteClient QueryError\": \"Server already locally defined for channel\"\r\n\t\t\t}, null); // immediately invoke callback passing error\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Send query to server listening on specified channel.\r\n\t * \r\n\t * @param {any} serverChannel\r\n\t * @param {object=} queryEvent event message sent to server\r\n\t * @param {function} responseEventHandler\r\n\t */\r\n\tthis.query = function (serverChannel, queryEvent, responseEventHandler) {\r\n\t\tconsole.debug(\"query to server channel \" + serverChannel + \" passing event: \" + JSON.stringify(queryEvent));\r\n\t\tvalidate.args(serverChannel, \"string\", queryEvent, \"any=\", responseEventHandler, \"function\");\r\n\t\tvar newQueryID = clientID();\r\n\t\taddQueryResponseCallBack(mapQueryResponses, newQueryID, responseEventHandler);\r\n\t\tsendToRouterService(new QueryMessage(newQueryID, serverChannel, queryEvent));\r\n\t};\r\n\r\n\t/**\r\n\t * Remove event server from specified channel.\r\n\t * \r\n\t * @param {string} serverChannel\r\n\t */\r\n\tthis.removeServer = function (serverChannel) {\r\n\t\tconsole.debug(\"removeServer from server channel \" + serverChannel);\r\n\t\tvalidate.args(serverChannel, \"string\");\r\n\t\tvar status = removeServerCallBack(mapServers, serverChannel);\r\n\t\tif (status) {\r\n\t\t\tsendToRouterService(new RemoveServerMessage(serverChannel));\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Add a PubSub server to specified topic. Generally only one PubSub server allowed per topic;\r\n\t * however a topic may be a regular-expression, in which case the PubSub server will server all matching topics.\r\n\t * When a regEx topic is used, the same default functionality is provides for each matching topic -- the difference\r\n\t * is only on SubPub service is need to cover a set of related topics, plus the same callback hander can be used (if provided).\r\n\t *\r\n\t * Note an exact topic match will take precedence over a regEx match, but otherwise results are unpredictable for overlapping topics.\r\n\t * \r\n\t * @param {string} topic topic for this server, or a topic RegEx (e.g. '/abc.+/') to handle a set of topcis\r\n\t * @param {object} initialState for the topic (defaults to empty struct)\r\n\t * @param {object=} params optional parameters\r\n\t * @param {function=} params.subscribeCallback allows server know of the subscription and accept or reject it (default is to accept)\r\n\t * @param {function=} params.publishCallback allows server to use the publish data to form a new state (default is the publish data becomes the new state)\r\n\t * @param {function=} params.unsubscribeCallback allows server to know of the unsubscribe, but it must be accepted\r\n\t *\r\n\t * @example\r\n\t *\r\n\t * function subscribeCallback(error, subscribe) {\r\n\t * \t\tif (subscribe) {\r\n\t * \t\t\t// must make this callback to accept or reject the subscribe (default is to accept). First parm is err and second is the initial state\r\n\t * \t\t\tsubscribe.sendNotifyToSubscriber(null, { \"NOTIFICATION-STATE\": \"One\" });\r\n\t * \t\t}\r\n\t * }\r\n\t * function publishCallback(error, publish) {\r\n\t * \t\tif (publish) {\r\n\t * \t\t\t// must make this callback to send notify to all subscribers (if error parameter set then notify will not be sent)\r\n\t * \t\t\tpublish.sendNotifyToAllSubscribers(null, publish.data); \r\n\t * \t\t}\r\n\t * }\r\n\t * function unsubscribeCallback(error, unsubscribe) {\r\n\t * \t\tif (unsubscribe) {\r\n\t * \t\t\t// must make this callback to acknowledge the unsubscribe \r\n\t * \t\t\tunsubscribe.removeSubscriber();\r\n\t * \t\t}\r\n\t * }\r\n\t * RouterClient.addPubSubServer(\"topicABC\", { \"State\": \"start\" }, { subscribeCallback:subscribeCallback, publishCallback:publishCallback, unsubscribeCallback:unsubscribeCallback } );\r\n\t *\r\n\t *   or\r\n\t *\r\n\t * RouterClient.addPubSubServer(\"topicABC\", { \"State\": \"start\" });\r\n\t *\r\n\t *   or\r\n\t *\r\n\t * RouterClient.addPubSubServer(\\/topicA*\\/, { \"State\": \"start\" });\r\n\t *\r\n\t */\r\n\tthis.addPubSubServer = function (topic, initialState, params) {\r\n\t\tconsole.debug(\"addPubSubServer for topic \" + topic);\r\n\t\tvalidate.args(topic, \"any\", initialState, \"object=\", params, \"object=\");\r\n\t\tparams = params || {};\r\n\t\tvalidate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\r\n\t\t\tvalidate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\r\n\r\n\t\tvar status = addPubSubServerCallBack(topic, params.subscribeCallback, params.publishCallback, params.unsubscribeCallback);\r\n\t\tif (status) {\r\n\t\t\tinitialState = initialState || {}; \r\n\t\t\tmapPubSubServerState[topic.toString()] = initialState;\r\n\t\t\tsendToRouterService(new AddPubSubServerMessage(topic.toString()));\r\n\t\t} else {\r\n\t\t\tconsole.warn(\"PubSub Server already locally defined for topic \" + topic);\r\n\t\t\tnotifyEventHandler({\r\n\t\t\t\t\"error\": \"PubSub Server already locally defined for topic\"\r\n\t\t\t}, null); // immediately invoke callback passing error\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Remove pubsub server from specified topic.\r\n\t * \r\n\t * @param {string} topic\r\n\t */\r\n\tthis.removePubSubServer = function (topic) {\r\n\t\tconsole.debug(\"removePubSubServer for topic \" + topic);\r\n\t\tvalidate.args(topic, \"string\");\r\n\t\tvar status = removeServerCallBack(mapPubSubServers, topic);\r\n\t\tif (status) {\r\n\t\t\tdelete mapPubSubServerState[topic.toString()]; // remove corresponding state\r\n\t\t\tdelete mapPubSubServerRegEx[topic.toString()]; // may be a RegEx\r\n\t\t\tsendToRouterService(new RemovePubSubServerMessage(topic));\r\n\t\t} else {\r\n\t\t\tconsole.warn(\"removePubSubServer failed -- could not find server for topic \" + topic);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Subscribe to a PubSub Server.\r\n\t * \r\n\t * @param {string} topic\r\n\t * @param {function} notifyCallback\r\n\t * @returns subscribe object used for unsubscribing\r\n\t */\r\n\tthis.subscribe = function (topic, notifyCallback) {\r\n\t\tconsole.debug(\"subscribe for topic \" + topic);\r\n\t\tvalidate.args(topic, \"string\", notifyCallback, 'function');\r\n\t\tvar subscribeID = clientID();\r\n\t\taddSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic);\r\n\t\tsendToRouterService(new SubscribeMessage(subscribeID, topic));\r\n\t\treturn { \"subscribeID\": subscribeID, \"topic\": topic}; \r\n\t};\r\n\t\r\n\t/**\r\n\t * Publish to a PubSub Server, which will trigger a corresponding Notify to be sent to all subscribers. \r\n\t * \r\n\t * @param {string} topic\r\n\t * @param {object} event\r\n\t */\r\n\tthis.publish = function (topic, event) {\r\n\t\tvalidate.args(topic, \"string\", event, 'any');\r\n\t\tconsole.debug(\"publish to topic \" + topic + \" event: \" + JSON.stringify(event));\r\n\t\tsendToRouterService(new PublishMessage(topic, event));\r\n\t};\r\n\r\n\t/**\r\n\t * Unsubscribe from PubSub server.\r\n\t * \r\n\t * @param {object} subscribeIDStruct\r\n\t */\r\n\tthis.unsubscribe = function (subscribeIDStruct) {\r\n\t\tconsole.debug(\"unsubscribe to topic \" + subscribeIDStruct.topic + \" for subscriberID \" + subscribeIDStruct.subscribeID);\r\n\t\tvalidate.args(subscribeIDStruct, \"object\") && validate.args2(\"subscribeIDStruct.subscribeID\", subscribeIDStruct.subscribeID, \"string\");\r\n\t\tvar deletedSubscriber = removeSubscriberCallBack(mapSubscribersID, subscribeIDStruct.subscribeID);\r\n\t\tif (deletedSubscriber) {\r\n\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeIDStruct.subscribeID, subscribeIDStruct.topic));\r\n\t\t} else {\r\n\t\t\tconsole.warn(\"unsubscribe failed -- could not find subscribeID for topic \" + subscribeIDStruct.topic);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * @todo\r\n\t * Removes all listeners, servers, and subscribers for this router client -- typically called when client component is shutting down (but RouterService is staying up).\r\n\t */\r\n\tthis.disconnectAll = function () {\r\n\t\tconsole.debug(\"disconnectAll\");\r\n\r\n\t\tfor (var channel in mapListeners) {\r\n\t\t\tconsole.debug(\"removing listener on \" + channel);\r\n\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\r\n\t\t\tdelete mapListeners[channel];\r\n\t\t}\t\r\n\r\n\t\tfor (var serverChannel in mapServers) {\r\n\t\t\tconsole.debug(\"removing server on \" + serverChannel);\r\n\t\t\tsendToRouterService(new RemoveServerMessage(serverChannel));\r\n\t\t\tdelete mapServers[serverChannel];\r\n\t\t}\t\r\n\r\n\t\tfor (var topic in mapPubSubServers) {\r\n\t\t\tconsole.debug(\"removing pubsub server on \" + topic);\r\n\t\t\tsendToRouterService(new RemovePubSubServerMessage(topic));\r\n\t\t\tdelete mapPubSubServers[topic.toString()]; // could be a RegEx\r\n\t\t\tdelete mapPubSubServerState[topic.toString()]; // remove corresponding state\r\n\t\t\tdelete mapPubSubServerRegEx[topic.toString()]; // may be a RegEx\r\n\t\t}\t\r\n\t\t\r\n\t\tfor (var subscribeID in mapSubscribersID) {\r\n\t\t\tvar stopic = mapSubscribersTopic[subscribeID];\r\n\t\t\tconsole.debug(\"removing subscriber on \" + stopic);\r\n\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeID, stopic));\r\n\t\t\tdelete mapSubscribersID[subscribeID];\r\n\t\t\tdelete mapSubscribersTopic[subscribeID];\r\n\t\t}\t\r\n\t};\r\n\r\n\tconstructor(thisClientName, transportName); // on creation invoke to initialize\r\n};\r\n\r\nmodule.exports = RouterClientConstructor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/clients/routerClientConstructor.js\n// module id = 3\n// module chunks = 0","// -------------------------------------------------------------------------------------------\r\n// Copyright 2012-2017 by ChartIQ, Inc\r\n// -------------------------------------------------------------------------------------------\r\n\r\n\"use strict\";\r\nvar Utils = require(\"../utils/util\");\r\nvar console = new Utils.Console(\"RouterTransport\"); // Finsemble console\r\n\r\nvar openfinAppConfig; // config used to determine if cross-domain\r\nif (window.location.hostname === \"localhost\") { // if localhost then using desktop-local config\r\n\tconsole.debug(\"desktop-local config\");\r\n\topenfinAppConfig = require(\"../../configs/desktop-local\");\r\n} else { // else using desktop-app config\r\n\tconsole.debug(\"desktop-app config\");\r\n\topenfinAppConfig = require(\"../../configs/desktop-app\");\r\n}\r\n\r\n/**\r\n * @introduction\r\n * <h2>Router Transport</h2>\r\n * **Service-Level Module**.  Manages and contains the point-to-point transports (i.e. Layer 2) supported by Finsemble.\r\n * Each transport communicates betweew a Finsemble services or component (on one end) and the Finsemble router (on the other end).\r\n *\r\n * The OpenFinBus transport is used for cross-domain components (where SharedWorker fails).\r\n *\r\n * Requirements for adding a new transport:\r\n * 1) create new transport object with same interface provided by SharedWorkerTransport and OpenFinTransport in this file.\r\n * 2) call RouterTransport.addTransport() to make the transport available (see the bottom of this file)\r\n *\r\n * Integration into routerService.js is automatic.\r\n *\r\n * @namespace RouterTransport\r\n */\r\nvar RouterTransport = {\r\n\r\n\tactiveTransports: {},\r\n\r\n\t/**\r\n\t * Adds a new type of router transport to pass message between RouterClient and RouterService. \r\n\t * \r\n\t * @param {string} transportName identifies the new transport\r\n\t * @param {object} transportConstructor returns an instance of the new transport\r\n\t */\r\n\taddTransport: function (transportName, transportConstructor) {\r\n\t\tthis.activeTransports[transportName] = transportConstructor;\r\n\t\tconsole.info(\"RouterTransport added: \" + transportName);\r\n\t},\r\n\r\n\t/**\r\n\t * Gets array of active transports\r\n\t * \r\n\t * @returns array transport names/identifier\r\n\t */\r\n\tgetActiveTransports: function () {\r\n\t\tvar transportNames = [];\r\n\t\tfor (var transportIdentifier in this.activeTransports) {\r\n\t\t\ttransportNames.push(transportIdentifier);\r\n\t\t}\r\n\t\treturn transportNames;\r\n\t},\r\n\r\n\t/**\r\n\t * Get best client transport based on the run-time context. Will only return cross-domain transport if current context is inter-domain.  \r\n\t * \r\n\t * @param {any} incomingMessageHandler\r\n\t * @param {any} source\r\n\t * @param {any} destination\r\n\t * @returns the transport object\r\n\t */\r\n\tgetRecommendedTransport: function (incomingMessageHandler, source, destination) {\r\n\t\tvar newTransport; // return variable\r\n\r\n\t\t// Will tell you if the window is in an iframe or not (for future)\r\n\t\tfunction isInIframe () {\r\n\t\t\ttry {\r\n\t\t\t\treturn window.self !== window.top;\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// returns true if this window's location is in another domain \r\n\t\tfunction crossDomain() {\r\n\t\t\tvar parser = document.createElement('a');\r\n\t\t\tparser.href = openfinAppConfig.startup_app.url;\r\n\r\n\t\t\tvar isSameHost = (window.location.hostname === parser.hostname);\r\n\t\t\tconsole.debug(\"Transport crossDomain host comparison:\" + window.location.hostname + \"==\" + parser.hostname);\r\n\r\n\t\t\tvar isSameProtocol = (window.location.protocol === parser.protocol);\r\n\t\t\tconsole.debug(\"Transport crossDomain protocol comparison:\" + window.location.protocol + \"==\" + parser.protocol);\r\n\r\n\t\t\tvar wport = (window.location.port === undefined) ? window.location.port : 80;\r\n\t\t\tvar pport = (parser.port === undefined) ? parser.port : 80;\r\n\t\t\tvar isSamePort = (wport === pport);\r\n\t\t\tconsole.debug(\"Transport crossDomain port comparison:\" + wport + \"==\" + pport);\r\n\r\n\t\t\tvar isCrossDomain = !(isSameHost && isSamePort && isSameProtocol);\r\n\t\t\tconsole.debug(\"Transport crossDomain=\" + isCrossDomain + \" (\" + isSameHost + \":\" + isSameProtocol + \":\" + isSamePort + \")\");\r\n\t\t\treturn isCrossDomain;\r\n\t\t}\r\n\r\n\t\t// returns the best transport to communicating with router service\t\t\r\n\t\tfunction recommendedTransportName() {\r\n\t\t\tvar recommendedName = \"SharedWorker\"; // default -- fast but doesn't work cross-domain\r\n\t\t\tif (crossDomain()) {\r\n\t\t\t\trecommendedName = \"OpenFinBus\"; // required for cross-domain event messaging between windows\r\n\t\t\t}\r\n\t\t\treturn recommendedName; \r\n\t\t}\r\n\r\n\t\tvar transportName = recommendedTransportName();\r\n\t\tvar transportConstructor = this.activeTransports[transportName];\r\n\t\tif (transportConstructor) {\r\n\t\t\tnewTransport = new transportConstructor(transportName, incomingMessageHandler, source, destination);\r\n\t\t}\r\n\t\treturn newTransport;\r\n\t},\r\n\r\n\t/**\r\n\t * Get a specific transport by name. The transport must be in list of the active transports (i.e. previously added).\r\n\t * \r\n\t * @param {any} transportName\r\n\t * @param {any} incomingMessageHandler\r\n\t * @param {any} source\r\n\t * @param {any} destination\r\n\t * @returns the transport object\r\n\t */\r\n\tgetTransport: function (transportName, incomingMessageHandler, source, destination) {\r\n\t\tvar transportConstructor = this.activeTransports[transportName];\r\n\t\tif (transportConstructor) {\r\n\t\t\tvar newTransport = new transportConstructor(transportName, incomingMessageHandler, source, destination);\r\n\t\t}\r\n\t\treturn newTransport;\r\n\t}\r\n};\r\n\r\n//////////////////////////////////////////////////////////////\r\n// Below all transports are defined then added to active list\r\n//////////////////////////////////////////////////////////////\r\n\r\nvar RouterTransportImplementation = {}; // a convenience namespace for router-transport implementations\r\n\r\n/*\r\n * Implements the SharedWorker Transport.\r\n * \r\n * Required Functions (used by transport clients):\r\n * \t\tsend(eventMessage) -- transports the event \r\n * \t\tidentifier() -- returns transport name/identifier\r\n * \r\n *  @param {object=} name the name the transport will be reference by\r\n *  @param {any} parentMessageHandlerParm callback for incoming event\r\n */\r\nRouterTransportImplementation.SharedWorkerTransport = function (name, parentMessageHandlerParm, source) {\r\n\tvar parentMessageHandler;\r\n\tvar routerThread;\r\n\tvar transportName;\r\n\tvar console = new Utils.Console(\"SharedWorkerTransport.\" + source); // Finsemble console\r\n\r\n\t// receives incoming shared-worker messages then passes on to parent with correct \"wrapper\"\r\n\tfunction sharedWorkerMessageHandler(swMessage) {\r\n\t\tvar port = swMessage.data[0];\r\n\t\tvar eventMessage = swMessage.data[1];\r\n\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"port\": port };\r\n\t\tconsole.debug(\"IncomingTransport: \" + JSON.stringify(incomingTransportInfo) + \" Message: \" + JSON.stringify(eventMessage), 5);\r\n\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\r\n\t}\r\n\r\n\t//required function for parent (i.e. routeClient or routeService)\r\n\tthis.send = function (transport, eventMessage) {\r\n\t\t// handle optional transport parm\r\n\t\tif (arguments.length === 1) {\r\n\t\t\ttransport = null;\r\n\t\t\teventMessage = arguments[0];\r\n\t\t} else {\r\n\t\t\ttransport = arguments[0];\r\n\t\t\teventMessage = arguments[1];\r\n\t\t}\r\n\t\tconsole.debug(\"OutgoingTransport: \" + \" Transport: \" + JSON.stringify(transport) + \" Message: \" + JSON.stringify(eventMessage), 5);\r\n\t\trouterThread.port.postMessage([transport,eventMessage]);\r\n\t};\r\n\r\n\t//required function for parent (i.e. routeClient or routeService)\r\n\tthis.identifier = function () {\r\n\t\treturn transportName;\r\n\t};\r\n\r\n\tconsole.debug(\"SharedWorker Initializing: \" + source);\t\r\n\ttransportName = name;\r\n\tparentMessageHandler = parentMessageHandlerParm;\r\n\trouterThread = new SharedWorker(\"/common/routerSharedWorker.js\", \"Finsemble\");\r\n\trouterThread.port.onmessage = sharedWorkerMessageHandler;\r\n\trouterThread.onerror = function (e) {\r\n\t\tconsole.error(\"RouteClient SharedWorker Error\" + JSON.stringify(e));\r\n\t};\r\n\trouterThread.port.start();\r\n\r\n\tif (source === \"RouterService\") {  // send first message though shared worker to identify router service\r\n\t\trouterThread.port.postMessage({data:\"connect\",source:\"RouterService\"});\r\n\t}\r\n};\r\n\r\n/*\r\n * Implements the OpenFin Bus Transport.\r\n * \r\n * Required Functions (used by transport clients):\r\n * \t\tsend(event) -- transports the event \r\n * \t\tidentifier() -- returns transport name/identifier\r\n * \r\n *  @param {any} name -- the name the transport will be reference by\r\n *  @param {any} parentMessageHandlerParm -- callback for incoming event\r\n */\r\nRouterTransportImplementation.OpenFinTransport = function (name, parentMessageHandlerParm, source, destination) {\r\n\tvar parentMessageHandler;\r\n\tvar transportName;\r\n\tvar console = new Utils.Console(\"OpenFinTransport.\" + source); // Finsemble console\r\n\r\n\t// receives incoming OpenFin bus messages then passes on to parent with correct \"wrapper\"\r\n\tfunction openFinMessageHandler(eventMessage, senderUuid, name) {\r\n\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"senderUuid\": senderUuid, \"name\": eventMessage.header.origin };\r\n\t\tconsole.debug(\"IncomingTransport: \" + JSON.stringify(incomingTransportInfo) + \" Message: \" + JSON.stringify(eventMessage), 5);\r\n\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\r\n\t}\r\n\r\n\tfunction subscribeFailure(reason) {\r\n\t\tconsole.error(\"OpenFinBus Subscribe Failure: \" + reason);\r\n\t}\r\n\r\n\t//required function for the parent (i.e. routeClient or routeService)\r\n\tthis.send = function (transport, eventMessage) {\r\n\t\tvar destTopic;\r\n\r\n\t\t// handle optional transport parm\r\n\t\tif (arguments.length === 1) {\r\n\t\t\tdestTopic = destination;\r\n\t\t\teventMessage = arguments[0];\r\n\t\t} else {\r\n\t\t\tdestTopic = transport.name;\t\t\r\n\t\t\teventMessage = arguments[1];\r\n\t\t}\r\n\r\n\t\tconsole.debug(\"OutgoingTransport: \" + destTopic + \" Message: \" + JSON.stringify(eventMessage), 5);\r\n\t\tfin.desktop.InterApplicationBus.send(\"ChartIQ\", destTopic, eventMessage);\r\n\t};\r\n\r\n\t//required function for the parent (i.e. routeClient or routeService)\r\n\tthis.identifier = function () {\r\n\t\treturn transportName;\r\n\t};\r\n\r\n\ttransportName = name;\r\n\tparentMessageHandler = parentMessageHandlerParm;\r\n\tconsole.debug(\"OpenFinBus Initializing: \" + source);\r\n\tfin.desktop.InterApplicationBus.subscribe(\"ChartIQ\", source, openFinMessageHandler, null, subscribeFailure);\r\n};\r\n\r\n// add the transports to the available/active list\r\nRouterTransport.addTransport(\"SharedWorker\", RouterTransportImplementation.SharedWorkerTransport);\r\nRouterTransport.addTransport(\"OpenFinBus\", RouterTransportImplementation.OpenFinTransport);\r\n\r\nmodule.exports = RouterTransport;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/common/routerTransport.js\n// module id = 4\n// module chunks = 0","\r\nmodule.exports = {\r\n\t/**\r\n\t * @introduction\r\n\t * <h2>Finsemble Utility Functions</h2>\r\n\t * \r\n\t * @class Utils\r\n\t */\r\n\r\n\r\n\tretrieveMonitorDimensions: function (callback) {\r\n\t\tvar dims = {};\r\n\t\tthis.getMonitorInfo().then(function (monitorInfo) {\r\n\t\t\tvar availableMonitors = [monitorInfo.primaryMonitor].concat(monitorInfo.nonPrimaryMonitors);\r\n\t\t\tfin.desktop.Window.getCurrent().getBounds(function (bounds) {\r\n\t\t\t\tdims.defaultLeft = bounds.left;\r\n\t\t\t\tdims.defaultTop = bounds.top;\r\n\t\t\t\tfindMonitor();\r\n\t\t\t});\r\n\t\t\tfunction findMonitor() {\r\n\t\t\t\tfor (var i = 0; i < availableMonitors.length; i++) {\r\n\t\t\t\t\tvar monitor = availableMonitors[i].availableRect;\r\n\t\t\t\t\tmonitor.width = monitor.right - monitor.left;\r\n\t\t\t\t\tmonitor.height = monitor.bottom - monitor.top;\r\n\t\t\t\t\tif (dims.defaultLeft >= monitor.left && dims.defaultLeft <= monitor.right) {\r\n\t\t\t\t\t\tdims.monitorDimensions = monitor;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (callback) {\r\n\t\t\t\t\tcallback(null,dims);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\t},\r\n\t/**\r\n * finsemble console for displaying diagnostic messages (a transparent replacement for window.console)\r\n * @param {string} name prefix for all console output\r\n * @memberof Utils\r\n * @constructor\r\n */\r\n\tConsole: function (name) {\r\n\t\tvar schema = \"FSBL-Console\";\r\n\t\tvar consoleName;\r\n\t\tvar currentLevel = 2;\r\n\r\n\t\t/**\r\n\t\t * gets console display level -- the higher the number the more is displayed \r\n\t\t * @returns level\r\n\t\t */\r\n\t\tthis.getLevel = function () {\r\n\t\t\treturn currentLevel;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * sets console display level -- the higher the number the more is displayed \r\n\t\t * @default \"4\"\r\n\t\t * @param {number} newLevel: the new display level\r\n\t\t */\r\n\t\tthis.setLevel = function (newLevel) {\r\n\t\t\tcurrentLevel = newLevel;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * outputs to console an error message (level == 1)\r\n\t\t * \r\n\t\t * @param {any} message: error message to display\r\n\t\t */\r\n\t\tthis.error = function (message) {\r\n\t\t\tvar myLevel = 1;\r\n\t\t\tif (myLevel <= currentLevel) {\r\n\t\t\t\tvar theMessage = consoleName + \" Error \" + new Date().toTimeString() + ': ' + message;\r\n\t\t\t\twindow.console.error(theMessage);\r\n\t\t\t\tfin.desktop.System.log('error', theMessage);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * outputs to console a warning message (level == 2)\r\n\t\t * \r\n\t\t * @param {any} message\r\n\t\t */\r\n\t\tthis.warn = function (message) {\r\n\t\t\tvar myLevel = 2;\r\n\t\t\tif (myLevel <= currentLevel) {\r\n\t\t\t\tvar theMessage = consoleName + \" Warning \" + new Date().toTimeString() + ': ' + message;\r\n\t\t\t\twindow.console.warn(theMessage);\r\n\t\t\t\tfin.desktop.System.log('warning', theMessage);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * outputs to console a info message (level == 3)\r\n\t\t * \r\n\t\t * @param {any} message\r\n\t\t */\r\n\t\tthis.info = function (message) {\r\n\t\t\tvar myLevel = 3;\r\n\t\t\tif (myLevel <= currentLevel) {\r\n\t\t\t\tvar theMessage = consoleName + \" Info \" + new Date().toTimeString() + ': ' + message;\r\n\t\t\t\twindow.console.info(theMessage);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * outputs to console a info message (level == 3)\r\n\t\t * \r\n\t\t * @param {any} message\r\n\t\t */\r\n\t\tthis.log = function (message) {\r\n\t\t\tvar myLevel = 3;\r\n\t\t\tif (myLevel <= currentLevel) {\r\n\t\t\t\tvar theMessage = consoleName + \" Log \" + new Date().toTimeString() + ': ' + message;\r\n\t\t\t\twindow.console.info(theMessage);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * outputs to console a debug message (level == 4+)\r\n\t\t * \r\n\t\t * @param {any} message\r\n\t\t * @param {any} level\r\n\t\t */\r\n\t\tthis.debug = function (message, level) {\r\n\t\t\tvar myLevel = parseInt(level, 10) || 4;\r\n\t\t\tif (myLevel <= currentLevel) {\r\n\t\t\t\tvar theMessage = consoleName + \" Debug: \" + message + \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\twindow.console.debug(theMessage);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tconsoleName = name;\r\n\t},\r\n\r\n\t/**\r\n\t * @param {any} name\r\n\t * @param {any} payload\r\n\t * @memberof Utils\r\n\t */\r\n\tmsgWrapper: function (name, payload) {\r\n\t\tthis.name = name;\r\n\t\tthis.payload = payload;\r\n\t},\r\n\r\n\tmonitorInfo: null,\r\n\t/**\r\n\t * returns monitor infor\r\n\t * \r\n\t * @param {any} force\r\n\t * @returns object\r\n\t */\r\n\tgetMonitorInfo: function (force) {\r\n\t\treturn new Promise(function (resolve, reject) {\r\n\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\r\n\t\t\t\tmodule.exports.monitorInfo = monitorInfo;\r\n\t\t\t\tresolve(monitorInfo);\r\n\t\t\t});\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t * get the dimensions of a monitor \r\n\t * \r\n\t * @returns height and weight\r\n\t * @memberof Utils\r\n\t */\r\n\tgetMonitorDimensions: function () {\r\n\t\treturn new Promise(\r\n\t\t\tfunction (resolve, reject) {\r\n\t\t\t\tvar monitorDimensions = {\r\n\t\t\t\t\theight: null,\r\n\t\t\t\t\twidth: null\r\n\r\n\t\t\t\t};\r\n\t\t\t\tconsole.log('getting data');\r\n\t\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\r\n\t\t\t\t\tconsole.log('got monitorInfo');\r\n\t\t\t\t\t//top bar is 45..\r\n\t\t\t\t\tmonitorDimensions.height = monitorInfo.primaryMonitor.availableRect.bottom - monitorInfo.primaryMonitor.availableRect.top - 32;\r\n\t\t\t\t\tmonitorDimensions.width = monitorInfo.primaryMonitor.availableRect.right;\r\n\t\t\t\t\tmonitorDimensions.left = monitorInfo.primaryMonitor.availableRect.left;\r\n\t\t\t\t\tmonitorDimensions.top = monitorInfo.primaryMonitor.availableRect.top;\r\n\t\t\t\t\tresolve(monitorDimensions);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\tgetMyMonitorDimensions: function (windowBounds) {\r\n\t\t//returns the dimensions of the monitor that the window is on.\r\n\t\t//@todo: this.\r\n\t},\r\n\r\n\t/**\t \r\n\t *\t@returns {string} Transforms an array of strings into a camelcased string.\r\n\t * @memberof Utils\r\n\t */\r\n\tcamelCase: function () {\r\n\t\tvar str = '';\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\tstr += ' ' + arguments[i];\r\n\t\t}\r\n\t\treturn str\r\n\t\t\t.replace(/\\s(.)/g, function ($1) { return $1.toUpperCase(); })\r\n\t\t\t.replace(/\\s/g, '')\r\n\t\t\t.replace(/^(.)/, function ($1) { return $1.toLowerCase(); });\r\n\t},\r\n\r\n\t/**\r\n\t * Convenience method for cloning an object.\r\n\t * @param  {any} from The thing you want to copy\r\n\t * @param {any} to Where you want your copy to end up.\r\n\t * @return {any} to Where you want your copy to end up.\r\n\t */\r\n\tclone: function (from, to) {\r\n\t\tif (from === null || typeof from !== \"object\") { return from; }\r\n\t\t// if (from.constructor != Object && from.constructor != Array) return from;\r\n\t\tif (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||\r\n\t\t\tfrom.constructor == String || from.constructor == Number || from.constructor == Boolean)\r\n\t\t{ return new from.constructor(from); }\r\n\r\n\t\tto = to || new from.constructor();\r\n\r\n\t\tfor (var n in from) {\r\n\t\t\tto[n] = typeof to[n] === \"undefined\" ? module.exports.clone(from[n], null) : to[n];\r\n\t\t}\r\n\r\n\t\treturn to;\r\n\t},\r\n\r\n\tgetUniqueName: function (baseName) {\r\n\t\tif (!baseName) {\r\n\t\t\tbaseName = \"RouterClient\";\r\n\t\t}\r\n\t\tvar uuid = baseName + \".\" + Math.floor(Math.random() * 10000) + Math.floor(Math.random() * 10000);\r\n\t\treturn uuid;\r\n\t},\r\n\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/utils/util.js\n// module id = 5\n// module chunks = 0","\r\n/**\r\n * @introduction\r\n * <h2>Finsemble Vaidate Functions</h2>\r\n * \r\n * @class Validate\r\n */\r\n\r\n/**\r\n * Constructor for Finsemble argment validator.\r\n *\r\n * Validatation logic is ONLY RAN when the console diagnotics level is set to debug (i.e. 4 or above)\r\n * A failed validation will generate a warning message, but nothing more; however application logic can check the validation results.\r\n *\r\n * @param {string} console Finsemble console object used to display messages and check diagnotic level\r\n * @memberof Utils\r\n * @constructor\r\n */\t\r\nvar Validate = function (console) {\r\n\r\n\tfunction warningMsg(paramDescript, thisArg, thisArgType) {\r\n\r\n\t\tfunction getErrorObject() {\r\n\t\t\ttry { throw Error(''); } catch (err) { return err; }\r\n\t\t}\r\n\r\n\t\tvar err = getErrorObject();\r\n\r\n\t\tvar caller_line1 = err.stack.split(\"\\n\")[5];\r\n\t\tvar index1 = caller_line1.indexOf(\"at \");\r\n\t\tvar msgPart1 = caller_line1.slice(index1 + 2, caller_line1.length);\r\n\r\n\t\tvar caller_line2 = err.stack.split(\"\\n\")[6];\r\n\t\tvar index2 = caller_line2.indexOf(\"at \");\r\n\t\tvar msgPart2 = caller_line2.slice(index2 + 2, caller_line2.length);\r\n\r\n\t\tconsole.warn(\"parameter validation failed: parameter \" + paramDescript + \" is of type '\" + typeof (thisArg) + \"' but should be of type '\" + thisArgType + \"' in\" + msgPart1 + \" called by\" + msgPart2);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Confirm parameters are valid. A variable number of parameter pairs are supported. \r\n\t * @param {any} param1 is arg to validate\r\n\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \r\n\t * @param {any=} param2 is next arg to validate\r\n\t * @param {string=} paramType2 os required type for next arg \r\n\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\r\n\t *\r\n\t * @example\r\n\t *\r\n\t * var validate = new Validate(console); \r\n\t * validate.args(name, \"string\", age, \"number\")\r\n\t *\r\n\t * validate.args(topic, \"string\", initialState, \"object=\"); // with optional paramter (represented by \"=\")\r\n\t *\r\n\t * validate.args(topic, \"string\", initialState, \"any\"); // with \"any\" type\r\n\t *\r\n\t * validate.args(subscribeIDStruct, \"object\") && validate.args(subscribeIDStruct.subscribeID, \"string\"); // only do second varidate if first test successful\r\n\t *\r\n\t * validate.args(subscribeIDStruct, \"object\", subscribeIDStruct.subscribeID, \"string\"); // only check second parm if first validated successful\r\n\t *\r\n\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\"); // depending on logic, can break into seperate validations\r\n\t * params = params || {}; \r\n\t * validate.args(params.subscribeCallback, \"function=\", params.publishCallback, \"function=\", params.unsubscribeCallback, \"function=\");\r\n\t */\r\n\tthis.args = function (param1, paramType1, param2, paramType2 /*.....optional more paramter pairs....*/) {\r\n\t\tvar returnCode = true;\r\n\t\t/*if (console.getLevel() >= 4) {\r\n\t\t\tvar parmCount = arguments.length;\r\n\t\t\tif ((parmCount + 1) % 2 !== 0) { // parameters must come in pairs (i.e. even number)\r\n\t\t\t\tfor (var i = 0; i < parmCount; i = i + 2) {\r\n\t\t\t\t\tvar optionalArg = false;\r\n\t\t\t\t\tvar thisArg = arguments[i];\r\n\t\t\t\t\tvar thisArgType = arguments[i + 1];\r\n\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\r\n\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\r\n\t\t\t\t\t\toptionalArg = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\r\n\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\r\n\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\r\n\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\r\n\t\t\t\t\t\t\t\twarningMsg(parameterPosition, thisArg, thisArgType);\r\n\t\t\t\t\t\t\t\treturnCode = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"verifyParmas requires even number of parameters: \" + JSON.stringify(arguments));\r\n\t\t\t}\r\n\t\t}*/\r\n\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \r\n\t};\r\n\r\n\t/**\r\n\t * Confirm parameters are valid. args2() has the same functionality as args() except a third \"parameter description\" is passed in for each argument varified\r\n\t * Typically this for passing in a properties name for better diagnostic messages when varifying object properties.\r\n\t * A variable number of parameter \"triples\"\" are supported.\r\n\t *\r\n\t * @param {string} paramName1 is descriptive name of param1 (for diagnostic message)\r\n\t * @param {any} param1 is arg to validate\r\n\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\").\r\n\t * @param {string} paramName2 is descriptive name of param1 (for diagnostic message)\r\n\t * @param {any} param2 is arg to validate\r\n\t * @param {string} paramType2 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \r\n\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\r\n\t *\r\n\t * @example\r\n\t *\r\n\t * var validate = new Utils.Validate(console); \r\n\t * validate.args2(\"record.name\", record.name, \"string\", \"record.age\", age, \"number\")\r\n\t *\r\n\t * // common case using args() and args2() together\r\n\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\") &&\r\n\t *   validate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\r\n\t *   validate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\r\n\t */\r\n\tthis.args2 = function (paramName1, param1, paramType1, paramName2, param2, paramType2 /*.....optional, more paramter sets of three....*/) {\r\n\r\n\t\tvar returnCode = true;\r\n\t\t/*if (console.getLevel() >= 4) {\r\n\t\t\tvar parmCount = arguments.length;\r\n\t\t\tif ((parmCount + 1) % 3 !== 0) { // parameters must come in sets of three \r\n\t\t\t\tfor (var i = 0; i < parmCount; i = i + 3) {\r\n\t\t\t\t\tvar optionalArg = false;\r\n\t\t\t\t\tvar thisArgName = arguments[i];\r\n\t\t\t\t\tvar thisArg = arguments[i + 1];\r\n\t\t\t\t\tvar thisArgType = arguments[i + 2];\r\n\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\r\n\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\r\n\t\t\t\t\t\toptionalArg = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\r\n\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\r\n\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\r\n\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\r\n\t\t\t\t\t\t\t\twarningMsg(thisArgName, thisArg, thisArgType);\r\n\t\t\t\t\t\t\t\treturnCode = false;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"verifyParmas requires even number of parameters: \" + JSON.stringify(arguments));\r\n\t\t\t}\r\n\t\t}*/\r\n\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \r\n\t};\r\n};\r\n\r\nmodule.exports = Validate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/common/validate.js\n// module id = 6\n// module chunks = 0","\r\nvar Utils = require(\"../utils/util\");\r\nvar console = new Utils.Console(\"StorageClient\"); // Finsemble console\r\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\r\nvar validate = new Validate(console); \r\n\r\n/**\r\n * \r\n * Public API for The Storage Service\r\n * StorageClient.[storageType].action(name,[data],cb);\r\n */\r\nvar RouterClient = require('./routerClientInstance');\r\nvar BaseClient = require(\"./baseClient\");\r\n/**\r\n *  @todo add clear method\r\n *  @example\r\n *\r\n * // Save a key value pair to local storage\r\n * FSBL.StorageClient.save(\"localStorage\",\"testKey\",\"testValue\")\r\n * // Save a key value pair to the default storage\r\n * FSBL.StorageClient.save(,\"testKey\",\"testValue\")\r\n * // Get an value from local storage\r\n * FSBL.StorageClient.get(\"localStorage\",\"testKey\",)\r\n * // Get an value from the default storage\r\n * FSBL.StorageClient.get(testKey\")\r\n * //Delete a value from local storage\r\n * FSBL.StorageClient.delete(\"localStorage\",\"testKey\")\r\n * //Delete a value from the default storage\r\n * FSBL.StorageClient.delete(\"testKey\")\r\n * \r\n * \r\n * @constructor\r\n */\r\nvar StorageClient = function (params) {\r\n\tvalidate.args(params, \"object=\") && params && validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\tvar self = this;\r\n\tBaseClient.call(this, params);\r\n\tthis.RouterClient = RouterClient;\r\n\tvar defaultStorage = null;\r\n\t//should probably come from some config;\r\n\tvar storageTypes = [\"localStorage\"];\r\n\tthis.startup =function(){\r\n\t\r\n\t};\r\n\tfunction loadStorageTypes() {\r\n\t\tfunction loadType(type) {\r\n\t\t\tif (!self[type]) { self[type] = {}; }\r\n\t\t\tself[type][\"save\"] = function (name, data, cb) { self.save(type, name, data, cb); };\r\n\t\t\tself[type][\"get\"] = function (name, cb) { self.get(type, name, cb); };\r\n\t\t\tself[type][\"delete\"] = function (name, cb) { self.delete(type, name, cb); };\r\n\t\t}\r\n\t\tfor (var i = 0; i < storageTypes.length; i++) {\r\n\t\t\tloadType(storageTypes[i]);\r\n\t\t}\r\n\t\tdefaultStorage = \"localStorage\";\r\n\t}\r\n\r\n\t/**\r\n\t * Save a key value pair into storage.\r\n\t * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t * @param {string} name - The key to be stored under\r\n\t * @param {any} data -  the value to be stored\r\n\t * @param {function=} [cb] -  callback to be called on success\r\n\t * \r\n\t * @example\r\n\t * StorageClient.save(\"localStorage\",\"testKey\",\"testValue\")\r\n\t */\r\n\tthis.save = function (storageType, name, data, cb) {\r\n\t\t//use the first storage if no type is given\r\n\t\tif (arguments.length < 4 && typeof data === \"function\") {\r\n\t\t\tcb = arguments[2];\r\n\t\t\tdata = arguments[1];\r\n\t\t\tname = arguments[0];\r\n\t\t\tstorageType = defaultStorage;\r\n\t\t}\r\n\t\tvalidate.args(storageType, \"any\", name, \"string\", data, \"any\", cb, \"function=\");\r\n\t\tself.RouterClient.query('Storage.save', { storageType: storageType, name: name, payload: data }, function (err, response) {\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t/**\r\n\t * Get a value from storage.\r\n\t * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t * @param {string} name - The key to pull from storage\r\n\t * @param {function} [cb] -  callback to be called on success\r\n\t * \r\n\t * @todo use default\r\n\t * @example\r\n\t * StorageClient.get(\"localStorage\",\"testKey\")\r\n\t */\r\n\tthis.get = function (storageType, name, cb) {\r\n\t\tif (arguments.length < 3 && typeof name === \"function\") {\r\n\t\t\tcb = arguments[1];\r\n\t\t\tname = arguments[0];\r\n\t\t\tstorageType = defaultStorage;\r\n\t\t} \r\n\t\tvalidate.args(storageType, \"string\", name, \"string\", cb, \"function=\");\r\n\t\tself.RouterClient.query('Storage.get', { storageType: storageType, name: name }, function (err, response) {\r\n\t\t\tconsole.log('clienterr', err);\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tthis.getMultiple = function(storageType,query,cb){\r\n\t\tif (arguments.length < 3 && typeof query === \"function\") {\r\n\t\t\tcb = arguments[1];\r\n\t\t\tquery = arguments[0];\r\n\t\t\tstorageType = defaultStorage;\r\n\t\t} \r\n\t\tself.RouterClient.query('Storage.getMultiple', {storageType:storageType,query:query}, function (err, response) {\r\n\t\t\tconsole.log('clienterr', err,response);\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t/**\r\n\t * Delete a value from storage.\r\n\t * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t * @param {string} name - The key to delete from storage\r\n\t * @param {function} [cb] -  callback to be called on success\r\n\t * @todo use default\r\n\t * @example\r\n\t * StorageClient.get(\"localStorage\",\"testKey\")\r\n\t */\r\n\tthis.delete = function (storageType, name, cb) {\r\n\t\tif (arguments.length < 3 && typeof name === \"function\") {\r\n\t\t\tcb = arguments[1];\r\n\t\t\tname = arguments[0];\r\n\t\t\tstorageType = defaultStorage.keys[0];\r\n\t\t} \r\n\t\tvalidate.args(storageType, \"any\", name, \"string\", cb, \"function=\");\r\n\t\tself.RouterClient.query('Storage.delete', { storageType: storageType, name: name }, function (err, response) {\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t//Load the storage types\r\n\tloadStorageTypes();\r\n};\r\n\r\n\r\nvar storageClient = new StorageClient({\r\n\tonReady: function (cb) {\r\n\t\tstorageClient.startup();\r\n\t\tconsole.log(\"storage online\");\r\n\t\tcb();\r\n\t},\r\n\tname:\"storageClient\"\r\n});\r\nstorageClient.requiredServices = [];\r\nstorageClient.initialize();\r\nmodule.exports = storageClient;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/clients/storageClient.js\n// module id = 7\n// module chunks = 0","\r\nvar Utils = require(\"../utils/util\");\r\nvar console = new Utils.Console(\"BaseClient\"); // Finsemble console\r\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\r\nvar validate = new Validate(console); \r\n\r\nvar Client = function (params) {\r\n\tvalidate.args(params, \"object=\");\r\n\tvar self = this;\r\n\tvar status = \"offline\";\r\n\tvar onReady;\r\n\tthis.name ;\r\n\tif (params) {\r\n\t\tonReady = params.onReady;\r\n\t\tthis.name = params.name;\r\n\t}\r\n\tthis.finWindow = fin.desktop.Window.getCurrent();\r\n\tthis.clientName = this.finWindow.name;//The current window\r\n\r\n\tthis.routerClient = require('./routerClientInstance');\r\n\tthis.requiredServices = [];\r\n\tthis.onlineServices = [];\r\n\r\n\tthis.addServices = function (services) {\r\n\t\tvalidate.args(services, \"any\");\r\n\t\tif (!services) { return; }\r\n\t\tif (!Array.isArray(services)) {\r\n\t\t\tservices = [services];\r\n\t\t}\r\n\t\tfor (var i = 0; i < services.length; i++) {\r\n\t\t\tif (this.onlineServices.indexOf(services[i]) === -1) {\r\n\t\t\t\tthis.onlineServices.push(services[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.checkRequiredServices();\r\n\t};\r\n\tthis.checkRequiredServices = function () {\r\n\t\tfor (var i = 0; i < this.requiredServices.length; i++) {\r\n\r\n\t\t\tif (this.onlineServices.indexOf(this.requiredServices[i]) > -1) {\r\n\t\t\t\tthis.requiredServices.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.checkOnline();\r\n\t};\r\n\tthis.checkOnline = function () {\r\n\t\tvar self = this;\r\n\t\tif (status === \"online\") { return; }\r\n\t\tif (this.requiredServices.length === 0) {\r\n\t\t\t\r\n\t\t\tif (onReady) {\r\n\t\t\t\treturn onReady(function () {\r\n\t\t\t\t\tstatus = \"online\";\r\n\t\t\t\t\tself.routerClient.transmit(self.clientName + \"FSBLClient\",self.name);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tthis.initialize = function () {\r\n\t\tsetup();\r\n\t\tthis.checkRequiredServices();\r\n\t};\r\n\tfunction setup() {\r\n\t\tself.routerClient.query(\"ServiceManager.getServices\", {}, function (err, event) {\r\n\t\t\tself.addServices(event.data);\r\n\t\t});\r\n\t\tself.routerClient.addListener(\"ServiceManager.serviceOnline\", function (err, event) {\r\n\t\t\tself.addServices(event.data);\r\n\t\t});\r\n\t};\r\n};\r\n\r\n\r\n\r\nmodule.exports = Client;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/clients/baseClient.js\n// module id = 8\n// module chunks = 0","var RouterClient = require('./routerClientInstance');\r\nvar BaseClient = require(\"./baseClient\");\r\nvar util = require(\"../utils/util\");\r\nvar console = new util.Console(\"BaseClient\"); // Finsemble console\r\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\r\nvar validate = new Validate(console);\r\n\r\n/**\r\n * Finsemble windowDescriptor. This is a superset of the Openfin Window object.\r\n * @typedef {Object} windowDescriptor\r\n * @property {string} url url to load.\r\n * @property {number} defaultTop Top pixel of the window. The top left of the screen is 0.\r\n * @property {number} defaultLeft Left edge of the window.\r\n * @property {number} defaultWidth Window width.\r\n * @property {number} defaultHeight Window height\r\n * @property {boolean} [showTaskbarIcon=true] Whether to show the icon in the taskbar.\r\n * @property {number} [minWidth=0] Minimum width that the window can be resized to.\r\n * @property {number} [minHeight=0] Minimum height that the window can be resized to.\r\n * @property {boolean} [autoShow=true] Whether the window should render in the background. If this option is set to false, you must tell the window to show itself at some point. You can use {@link WindowClient#show}.\r\n * @property {boolean} [frame=false] Whether the window should be rendered with a sytem frame. \r\n * @property {boolean} [resizable=true] Whether the window can be resized.\r\n * @property {boolean} [maximizable=true] Whether the window can be maximized.\r\n * @property {boolean} [alwaysOnTop=false] Whether the window should always sit on top of other finsemble windows.\r\n * @property {boolean} [fixedPosition=false] Whether the window should remain where it was spawned.\r\n * @property {Object} [resizeRegion] \r\n * @property {number} [resizeRegion.size=10]\r\n * @property {number} [resizeRegion.bottomCorner= 10]\r\n */\r\n\r\n/**\r\n * \"Private\" properties of the windowDescriptor\r\n * @private @property @todo { boolean } [hoverFocus = false]\r\n * @private @property {boolean} [saveWindowState=false] Openfin window state saving. Don't want to\r\n * have them saving the window state since we are.Turning this to true is untested.Do not change.\r\n */\r\n\r\n/**\r\n * \r\n * The launcher client handles spawning windows for the application.\r\n * @constructor\r\n */\r\nfunction LauncherClient(params) {\r\n\tvalidate.args(params, \"object=\") && params && validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\r\n\t/** @alias LauncherClient# */\r\n\tvar self = this;\r\n\tBaseClient.call(this, params);\r\n\r\n\t/**\r\n\t * Get a list of available components. This is useful if you need to list all of your components (e.g., in a toolbar).\r\n\t * @param {Function} cb Callback to be invoked after function is completed.\r\n\t * @example <caption>Something like this could be done to retrieve the list of components inside of something like a Toolbar or a launcher.</caption>\r\n\t * var self=this; \r\n\t * FSBL.LauncherClient.getComponentList(function(err, data){\r\n\t *\tself.setState({\r\n\t\tcomponentList: data\r\n\t });\r\n\t * });\r\n\t */\r\n\tthis.getComponentList = function (cb) {\r\n\t\tvalidate.args(cb, \"function\");\r\n\r\n\t\tRouterClient.query('Launcher.componentList', {}, function (err, response) {\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response.data);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t/**\r\n\t * Get the defaults for an individual component.\r\n\t * @param {String} componentType The type of the component you are looking for\r\n\t * @param {Function} cb Callback to be invoked after function is completed.\r\n\t * @example\r\n\t * FSBL.launcherClient.getComponentInfo('Advanced Chart', function(err, data){\r\n\t *\t//do something with the default values for Advanced chart.\r\n\t * });\r\n\t */\r\n\tthis.getComponentInfo = function (componentType, cb) {\r\n\t\tvalidate.args(cb, \"function\");\r\n\t\tconsole.log(\"getComponentInfo \" + componentType);\r\n\t\tRouterClient.query('Launcher.componentList', {}, function (err, response) {\r\n\t\t\twindow.console.log(\"got the info\", err, response, cb);\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response.data[componentType]);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t/**\r\n\t * Asks the Launcher service to spawn a window. The examples below show the basic functionality that the launcher offers. Please see the [Window Spawning]{@tutorial spawningWindows} tutorial for advanced functionality.\r\n\t * @param {String} component - Type of the component to launch\r\n\t * @param {Object} params Properties to merge with the default windowDescriptor.\r\n\t * @param {Function=} cb Callback to be invoked after function is completed.'\r\n\t *\r\n\t * @example\r\n\t * //Spawns an advanced chart with the default positioning.\r\n\t * FSBL.LauncherClient.spawn(\"Advanced Chart\");\r\n\t * //Spawns an advanced chart in the center of the monitor from where the spawn call originated. If A component on monitor 3 invokes Spawn and passes in a <code>defaultLeft</code> of 'center', it will spawn on monitor 3.\r\n\t * FSBL.LauncherClient.spawn(\"Advanced Chart\", {\r\n\t * \tdefaultLeft: 'center',\r\n\t * \tdefaultTop: 'center'\r\n\t * });\r\n\t */\r\n\tthis.spawn = function (component, params, cb) {\r\n\t\tparams.component = component;\r\n\t\tif (!params.customData) {\r\n\t\t\tparams.customData = {};\r\n\t\t}\r\n\t\tif (!params.customData.monitorDimensions) {\r\n\r\n\t\t\treturn util.retrieveMonitorDimensions(function(err,dims){\r\n\t\t\t\twindow.console.log(\"dims\",dims);\r\n\t\t\t\tparams.customData.monitorDimensions = dims.monitorDimensions;\r\n\t\t\t\twindow.console.log(\"params\",params);\r\n\t\t\t\tcallSpawn(params,cb);\r\n\t\t\t});\r\n\t\t}\r\n\t\tcallSpawn(params,cb);\r\n\t\t\r\n\t};\r\n\tfunction callSpawn(params,cb){\r\n\t\tRouterClient.query('Launcher.spawn', params, function (err, response) {\r\n\t\t\tif (cb) {\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\t/**\r\n\t* Spawns a new openfin window.\r\n\t* @param {string} windowName\tThe name of the window you are looking for\r\n\t* @param {function} cb Callback\r\n\t*/\r\n\tthis.getWindow = function (windowName, cb) {\r\n\t\tRouterClient.query('Launcher.getWindow', windowName, function (err, response) {\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response);\r\n\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t/**\r\n\t* Spawns a new openfin window.\r\n\t* @param {string} windowName\tThe name of the window you are looking for\r\n\t* @param {function} cb Callback\r\n\t*/\r\n\tthis.isWindowOpen = function (windowName, cb) {\r\n\t\tRouterClient.query('Launcher.isWindowOpen', windowName, function (err, response) {\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response);\r\n\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t\r\n\tthis.getActiveDescriptors = function(cb){\r\n\t\tRouterClient.query('Launcher.getActiveDescriptors', {}, function (err, response) {\r\n\t\t\tif (cb) {\r\n\t\t\t\tcb(err, response);\r\n\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t/**\r\n\t* Spawns a new openfin window.\r\n\t* @param {object} params\tThe name of the window you are looking for\r\n\t* @param {object} params.monitorDimensions\r\n\t* @param {number} params.width\r\n\t* @param {number} params.hight\r\n\t* @param {number} [params.widnow]\r\n\t* @param {function} cb Callback\r\n\t*/\r\n\tthis.moveWindowCenter = function (params) {\r\n\t\tif (!params.monitorDimensions) { return; }\r\n\t\tvar centerTop = (params.monitorDimensions.height - params.height) / 2;\r\n\t\tvar centerLeft = (params.monitorDimensions.width - params.width) / 2;\r\n\t\twindow.console.log(params,centerTop,centerLeft+ params.monitorDimensions.left);\r\n\t\tif (!params.window) {\r\n\t\t\treturn fin.desktop.Window.getCurrent().moveTo(centerLeft + params.monitorDimensions.left, centerTop);\r\n\t\t}\r\n\t\tconsole.log(\"move this window\");\r\n\t\treturn params.window.moveTo(centerLeft+ params.monitorDimensions.left, centerTop,function(){\r\n\t\t\tparams.window.bringToFront();\r\n\t\t});\r\n\t};\r\n\treturn this;\r\n};\r\n\r\n\r\nvar launcherClient = new LauncherClient({\r\n\tonReady: function (cb) {\r\n\t\tcb();\r\n\t},\r\n\tname: \"launchClient\"\r\n});\r\nlauncherClient.requiredServices = [];\r\nlauncherClient.initialize();\r\n\r\nmodule.exports = launcherClient;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../nodeProjects/testFin/~/finsemble/dist/clients/launcherClient.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}