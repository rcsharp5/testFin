{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap ea28eb2aa83855378b6a","webpack:///./testComponent/testComponent.js","webpack:///C:/Users/BradC/git/testFin/~/path-browserify/index.js","webpack:///C:/Users/BradC/git/testFin/~/process/browser.js","webpack:///../clients/testClient.js","webpack:///C:/Users/BradC/git/finsemble/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA,8B;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACnLtC;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA6C;AAC7C,mCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,GAAE;AACF;AACA,EAAC;AACD;;AAEA,iC;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,UAAU;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,KAAI;AACJ,+BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA,yC;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kC;AACA,qBAAoB,mCAAmC;AACvD,mC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,6D;AACJ;AACA,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,qBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAI;AACJ,IAAG;;AAEH;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,mBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,uCAAsC,yBAAyB,EAAE;AACjE;AACA,qCAAoC,yBAAyB,EAAE;AAC/D,IAAG;;AAEH;AACA;AACA,eAAc,IAAI;AAClB,cAAa,IAAI;AACjB,eAAc,IAAI;AAClB;AACA;AACA,oDAAmD,aAAa;AAChE;AACA;AACA;AACA,KAAI,mCAAmC;;AAEvC;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;;AAGA,QAAO;AACP;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mC;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS,iBAAiB,EAAE,cAAc,YAAY;AACtD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,KAAK;AAClB,cAAa,QAAQ;AACrB,eAAc,QAAQ,yCAAyC;AAC/D;AACA;AACA;AACA,2C;AACA;AACA;AACA,8DAA6D;AAC7D;AACA,0DAAyD;AACzD;AACA,2GAA0G;AAC1G;AACA,0FAAyF;AACzF;AACA,8EAA6E;AAC7E,4B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC,qBAAoB,eAAe;AACnC;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA,8CAA6C;AAC7C,+DAA8D;AAC9D,yEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,eAAc,QAAQ,yCAAyC;AAC/D;AACA;AACA;AACA,iD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC;AACpC,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA,8CAA6C;AAC7C,+DAA8D;AAC9D,yEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAiE,8BAA8B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC;AACvC,kDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,mBAAmB,GAAG,gHAAgH;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,qDAAoD;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,6CAA4C;AAC5C,oBAAmB,gCAAgC,OAAO;AAC1D;AACA,4CAA2C,wBAAwB;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,mDAAkD;AAClD,yDAAwD;AACxD;AACA,yCAAwC;AACxC,MAAK,OAAO;AACZ;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,4CAA2C;AAC3C,MAAK;AACL;AACA,oEAAmE;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qD;AACA,iEAAgE;AAChE;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAiC;AACjC;AACA;AACA;AACA,8EAA6E;AAC7E,wCAAuC;AACvC,iDAAgD;AAChD,Q;AACA,0E;AACA;AACA;AACA;AACA;;AAEA,kCAAiC;AACjC;AACA,KAAI;AACJ,yCAAwC;AACxC;AACA,MAAK;AACL,uEAAsE;AACtE;AACA,2DAA0D;AAC1D,OAAM,OAAO;AACb,yGAAwG;AACxG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAiC;AACjC;AACA;AACA;AACA;AACA,O;AACA;AACA;;AAEA,kCAAiC;AACjC;AACA,KAAI;AACJ,4DAA2D;AAC3D;AACA,8DAA6D;AAC7D,MAAK,OAAO;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAAyD;AACzD;AACA,qDAAoD;AACpD,qBAAoB,8BAA8B;AAClD;AACA;AACA,M;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAiC;AACjC;AACA;AACA;AACA;AACA,O;AACA;AACA;;AAEA,kCAAiC;AACjC;AACA,KAAI;AACJ,4EAA2E;AAC3E;AACA,sDAAqD;AACrD,MAAK,OAAO;AACZ,0EAAyE;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,oDAAmD;AACnD,0CAAyC;AACzC,MAAK;AACL,gEAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,K;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK,QAAQ;AACb;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,8BAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA,gE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,mBAAmB,GAAG,gHAAgH;AACrL;AACA;AACA;AACA,gDAA+C,mBAAmB;AAClE;AACA;AACA;AACA,iDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uC;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK,QAAQ;AACb;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD,mDAAkD;AAClD;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,6C;AACX;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;AACA,K;;AAEA;AACA;AACA;AACA,+CAA8C;AAC9C,mDAAkD;AAClD,mDAAkD;AAClD,K;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;;AAEA,8CAA6C;AAC7C;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAoD;;AAEpD,uBAAsB;AACtB,iDAAgD;AAChD;AACA;AACA,GAAE,OAAO;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB;;AAEtB;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAAyC;AACzC;AACA,qCAAoC;AACpC;AACA,4B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA,sEAAqE;;AAErE;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAmC;AACnC,mCAAkC,sCAAsC;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA,iEAAgE;;AAEhE;AACA;AACA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ,gC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA,wBAAuB;AACvB;AACA,wBAAuB;AACvB,uBAAsB;AACtB,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,4BAA4B;AACrE,KAAI;AACJ;AACA;AACA,0CAAyC,4BAA4B;AACrE,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA,mBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,gCAAgC;AACnC;;AAEA;AACA;AACA;AACA;AACA,mBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH,mBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;;AAGA;AACA,mDAAkD;AAClD,wCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB,iBAAiB;AACvC,qDAAoD,iCAAiC;AACrF,8CAA6C,0BAA0B;AACvE,iDAAgD,6BAA6B;AAC7E;AACA,mBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,sDAAsD;AAClG;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;AACA,4CAA2C,uCAAuC;AAClF;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,K;AACA,oDAAmD,oCAAoC;AACvF;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;AACA,+CAA8C,uCAAuC;AACrF;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF;AACA;AACA;;;;;AAKA,QAAO;AACP;AACA;;;AAGA;AACA,gDAA+C;AAC/C,wCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,mBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,kCAAkC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,QAAQ;AACrC;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;;;;AAIA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,+CAA8C;AAC9C,wCAAuC;;AAEvC;AACA;AACA,eAAc,OAAO;AACrB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ,yKAAyK,wBAAwB;AACxN,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA,+BAA8B,UAAU;AACxC,yBAAwB,QAAQ;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA,oB;AACA;AACA;AACA;AACA,KAAI;AACJ,OAAM;AACN;AACA;AACA;;AAEA,mDAAkD;AAClD;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,8JAA6J,0BAA0B;AACvL,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;AACJ;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,0DAAyD;AACzD;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA,oCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA,gDAA+C;AAC/C,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC,cAAa,mBAAmB;AAChC,cAAa,qBAAqB;AAClC;AACA;AACA,gCAA+B,qCAAqC,EAAE,qCAAqC;AAC3G;AACA;AACA;AACA;AACA,mDAAkD,mDAAmD;AACrG;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC,cAAa,OAAO;AACpB,cAAa,qBAAqB;AAClC;AACA;AACA,kCAAiC,qCAAqC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC,cAAa,OAAO;AACpB,cAAa,qBAAqB;AAClC;AACA;AACA,oCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,uBAAuB;AACtE;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,cAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,iBAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,QAAQ;AACpB,aAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,OAAM;AACN,KAAI;AACJ;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,IAAI;AAChB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,6BAA6B;AACtF,yCAAwC,6BAA6B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,oBAAmB,+BAA+B;AAClD;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA,8CAA6C;AAC7C;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF;AACA;AACA;;;AAGA;AACA;AACA,cAAa,OAAO;AACpB,gBAAe,OAAO;AACtB,gBAAe,MAAM;AACrB,gBAAe,MAAM;AACrB;AACA;AACA;AACA,cAAa,OAAO;AACpB,gBAAe,uBAAuB;AACtC;AACA;AACA;AACA,cAAa,OAAO;AACpB,gBAAe,sBAAsB;AACrC;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,gBAAe,mBAAmB;AAClC;AACA;AACA;AACA,cAAa,OAAO;AACpB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,mBAAmB;AAC9B;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,qBAAqB;AAChC;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,mBAAmB;AAC9B;;;AAGA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iMAAgM,iCAAiC;;AAEjO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4D;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA8G,qBAAqB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,KAAI,E;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL,KAAI;AACJ;;;AAGA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,EAAE,kBAAkB,oBAAoB,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,kBAAkB,oBAAoB,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,qBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA,+DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,UAAU;AACvB;AACA;AACA;AACA,qCAAoC,mCAAmC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA,0CAAyC,8CAA8C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,UAAS;AACT;AACA;AACA,SAAQ;AACR;AACA,SAAQ;AACR;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,uCAAsC,iCAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gDAA+C;AAC/C,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,2JAA0J,qBAAqB;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA,4KAA2K,qBAAqB;AAChM,+BAA8B,qCAAqC;AACnE;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,gCAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA,cAAa,UAAU;AACvB;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,gCAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,GAAG;AAClC;AACA;AACA;AACA,O;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,UAAU;AACvB;AACA,mC;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;;AAEA;AACA;AACA,gCAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,UAAU;AACvB;AACA,wCAAuC,gBAAgB;AACvD;AACA,KAAI;AACJ;AACA;AACA;AACA,gCAA+B,GAAG;AAClC;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,UAAU;AACvB;AACA,mC;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,gCAA+B,GAAG;AAClC,oF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA,kC;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,gCAA+B,GAAG;AAClC;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,gCAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA,mC;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,gCAA+B,GAAG;;AAElC,qE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA,qC;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,E;AACL,KAAI,E;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,UAAU;AACtB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA,K;AACA;AACA,uCAAsC,kBAAkB;AACxD;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA,iDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF,6DAA4D;AAC5D,qCAAoC;;AAEpC;;;;AAIA;AACA;AACA,EAAC;AACD;AACA,iC","file":"testComponent\\testComponent.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ea28eb2aa83855378b6a","var path = require('path');\r\nvar testClient = require('../../clients/testClient.js');\r\n\r\nFSBL.addClient('TestClient', testClient);\r\nFSBL.useAllClients();\r\n\r\nFSBL.initialize(onReady);\r\n\r\nvar StorageClient = FSBL.Clients.StorageClient,\r\n\tLinkerClient = FSBL.Clients.LinkerClient,\r\n\tWindowClient = FSBL.Clients.WindowClient,\r\n\tTestClient = testClient,\r\n\tmyInput,\r\n\tmyButton;\r\n\r\nfunction setInputValue(val) {\r\n\tmyInput.value = val;\r\n\tsaveState();\r\n}\r\nfunction saveState() {\r\n\tWindowClient.setAppState({\r\n\t\tfield: 'symbol',\r\n\t\tvalue: myInput.value\r\n\t});\r\n}\r\nfunction restoreState() {\r\n\tWindowClient.getAppState({\r\n\t\tfield: 'symbol'\r\n\t}, function (err, state) {\r\n\t\tif (err) {\r\n\t\t\talert(err.message);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsetInputValue(state);\r\n\t});\r\n}\r\n\r\nfunction handleInputKeyup(e) {\r\n\tsaveState();\r\n\tif (e.keyIdentifier === 'enter') {\r\n\t\tpublishSymbolChange();\r\n\t}\r\n}\r\nfunction publishSymbolChange() {\r\n\tLinkerClient.publish('symbol', myInput.value);\r\n}\r\n\r\nfunction spawnADialog() {\r\n\tTestClient.spawnADialog();\r\n}\r\nfunction onReady() {\r\n\t\r\n\t//gathering references.\r\n\tmyInput = document.querySelector('#linkerInput');\r\n\tmyButton = document.querySelector('#linkerButton');\r\n\tdialogButton = document.querySelector('#dialogButton');\r\n\t//Broadcast changes when the user clicks our button.\r\n\tmyInput.addEventListener('keyup', handleInputKeyup);\r\n\tmyButton.addEventListener('click', publishSymbolChange);\r\n\t//When symbol changes, set it locally.\r\n\tLinkerClient.registerListener('symbol', function (symbol) {\r\n\t\tsetInputValue(symbol);\r\n\t});\r\n\t\r\n\tdialogButton.addEventListener('click', spawnADialog);\r\n\trestoreState();\r\n}\r\n\r\nvar myComponent = {};\r\nmodule.exports = myComponent;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./testComponent/testComponent.js\n// module id = 0\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// C:/Users/BradC/git/testFin/~/path-browserify/index.js\n// module id = 1\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// C:/Users/BradC/git/testFin/~/process/browser.js\n// module id = 2\n// module chunks = 0","var Finsemble = require('finsemble');\r\nvar RouterClient = Finsemble.Clients.RouterClient;\r\nvar BaseClient = Finsemble.Clients.BaseClient;\r\nvar WindowClient = Finsemble.Clients.WindowClient;\r\nvar DialogManager = Finsemble.Clients.DialogManager;\r\n\r\nvar util = Finsemble.Utils;\r\nvar console = new util.Console(\"BaseClient\"); // Finsemble console\r\nvar Validate = Finsemble.Validate; // Finsemble args validator\r\n\r\n/**\r\n * \r\n * The launcher client handles spawning windows for the application.\r\n * @constructor\r\n */\r\nfunction testClient(params) {\r\n\tBaseClient.call(this, params);\r\n\tValidate.args(params, \"object=\") && params && Validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\r\n\tconsole.log('holaaa!');\r\n\tthis.spawnADialog = function () {\r\n\t\tDialogManager.spawnDialog({\r\n\t\t\tdefaultTop: 'center',\r\n\t\t\tdefaultLeft: 'center',\r\n\t\t\tdefaultWidth: 350,\r\n\t\t\tdefaultHeight: 125,\r\n\t\t\turl: '/components/dialogs/yesNo.html'\r\n\r\n\t\t},\r\n\t\t{\r\n\t\t\tquestion: 'Would you like to close this window?'\r\n\t\t}, function (err, response) {\r\n\t\t\tif (err) {\r\n\t\t\t\tconsole.error(err);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (response.choice === 'affirmative') {\r\n\t\t\t\tWindowClient.close();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn this;\r\n};\r\n\r\n\r\nvar clientInstance = new testClient({\r\n\tonReady: function (cb) {\r\n\t\tcb();\r\n\t},\r\n\tname: \"testClient\"\r\n});\r\nclientInstance.requiredServices = [];\r\n\r\nmodule.exports = clientInstance;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../clients/testClient.js\n// module id = 3\n// module chunks = 0","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FSBL\"] = factory();\n\telse\n\t\troot[\"FSBL\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Utils = __webpack_require__(1);\r\n\tvar Validate = __webpack_require__(3);\r\n\t\r\n\tvar FronEndLib =function(){\r\n\t\tvar self = this;\r\n\t\tvar onlineClients = [];\r\n\t\tvar clients = [];\r\n\t\tvar status = \"offline\";\r\n\t\tvar windowName = fin.desktop.Window.getCurrent().name;\r\n\t\tthis.RouterClient = __webpack_require__(4);\r\n\t\t\r\n\t\r\n\t\tthis.baseService = __webpack_require__(9);\r\n\t\tthis.Utils = Utils;\r\n\t\tthis.Validate = Validate;\r\n\t\tthis.Clients = {\r\n\t\t\tRouterClient: this.RouterClient,\r\n\t\t\tStorageClient: __webpack_require__(10),\r\n\t\t\tLauncherClient: __webpack_require__(12),\r\n\t\t\tLinkerClient: __webpack_require__(13),\r\n\t\t\tWindowClient: __webpack_require__(14),\r\n\t\t\tWorkspaceClient: __webpack_require__(15),\r\n\t\t\tDialogManager: __webpack_require__(16),\r\n\t\t\tBaseClient: __webpack_require__(11)\r\n\t\t};\r\n\t\tthis.addClient =function(name, obj){\r\n\t\t\tif (!this.Clients[name]) {\r\n\t\t\t\tthis.Clients[name] = obj;\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.useClients=function(clientList){\r\n\t\t\tfor(var i =0;i<clientList.length;i++){\r\n\t\t\t\tif(this.Clients[clientList[i]] && clients.indexOf(clients[i]) === -1){\r\n\t\t\t\t\tclients.push(clientList[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.useAllClients=function(){\r\n\t\t\tfor(var key in this.Clients){\r\n\t\t\t\tif(clients.indexOf(key) === -1){\r\n\t\t\t\t\tif(!this.Clients[key].initialize){continue;}//hack for now\r\n\t\t\t\t\tclients.push(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tthis.initialize = function(cb){\r\n\t\t\tthis.RouterClient.addListener(windowName + \"FSBLClient\",function(err,data){\r\n\t\t\t\tif(err){return console.error(err);}\r\n\t\t\t\tself.setClientOnline(data.data);\r\n\t\t\t});\r\n\t\t\tif (clients.length === 0) { return cb; }\r\n\t\t\tif (!clients.includes('RouterClient')) {\r\n\t\t\t\tclients.push('RouterClient');\r\n\t\t\t}\r\n\t\t\tif (cb) {\r\n\t\t\t\tthis.addEventListener(\"onReady\",cb);\t\t\t\r\n\t\t\t}\r\n\t\t\tfor(var i=0;i<clients.length;i++){\r\n\t\t\t\tconsole.log(\"clients[i]\",clients[i]);\r\n\t\t\t\tthis.Clients[clients[i]].initialize();\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tthis.setClientOnline = function (clientName) {\r\n\t\t\tValidate.args(clientName, \"string\");\r\n\t\t\tif (onlineClients.includes(clientName)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tconsole.log('Client Online: ' + clientName);\r\n\t\t\tonlineClients.push(clientName);\r\n\t\t\tconsole.log(onlineClients.length ,clients.length);\r\n\t\t\tif (onlineClients.length ===clients.length) {\r\n\t\t\t\tstatus = \"online\";\r\n\t\r\n\t\t\t\tif (this.listeners.onReady) {\t\t\t\t\r\n\t\t\t\t\tfor (var i = 0; i < this.listeners.onReady.length; i++){\r\n\t\t\t\t\t\tthis.listeners.onReady[i]();\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.listeners.onReady = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.listeners = {};\r\n\t\tthis.addEventListener = function (listenerType, callback) {\r\n\t\t\tconsole.log(\"adding listen\",callback);\r\n\t\t\tValidate.args(listenerType, \"string\", callback, \"function\");\r\n\t\r\n\t\t\tif (!this.listeners[listenerType]) {\r\n\t\t\t\tthis.listeners[listenerType] = [];\r\n\t\t\t\tif(status === 'online' && listenerType === 'onReady'){\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t\tthis.listeners[listenerType].push(callback);\r\n\t\t\t} else if (status === 'online' && listenerType === 'onReady'){\t\t\t\r\n\t\t\t\tcallback();\r\n\t\t\t} else {\r\n\t\t\t\tthis.listeners[listenerType].push(callback);\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tvar fronEndLib =new FronEndLib();\r\n\tmodule.exports  =fronEndLib;\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar SystemSettings = __webpack_require__(2);\r\n\t\r\n\tmodule.exports = {\r\n\t\t/**\r\n\t\t * @introduction\r\n\t\t * <h2>Finsemble Utility Functions</h2>\r\n\t\t * \r\n\t\t * @class Utils\r\n\t\t */\r\n\t\r\n\t\tretrieveMonitorDimensions: function (callback) {\r\n\t\t\tvar dims = {};\r\n\t\t\tthis.getMonitorInfo().then(function (monitorInfo) {\r\n\t\t\t\tvar availableMonitors = [monitorInfo.primaryMonitor].concat(monitorInfo.nonPrimaryMonitors);\r\n\t\t\t\tfin.desktop.Window.getCurrent().getBounds(function (bounds) {\r\n\t\t\t\t\tdims.defaultLeft = bounds.left;\r\n\t\t\t\t\tdims.defaultTop = bounds.top;\r\n\t\t\t\t\tfindMonitor();\r\n\t\t\t\t});\r\n\t\t\t\tfunction findMonitor() {\r\n\t\t\t\t\tfor (var i = 0; i < availableMonitors.length; i++) {\r\n\t\t\t\t\t\tvar monitor = availableMonitors[i].availableRect;\r\n\t\t\t\t\t\tmonitor.width = monitor.right - monitor.left;\r\n\t\t\t\t\t\tmonitor.height = monitor.bottom - monitor.top;\r\n\t\t\t\t\t\tif (dims.defaultLeft >= monitor.left && dims.defaultLeft <= monitor.right) {\r\n\t\t\t\t\t\t\tdims.monitorDimensions = monitor;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (callback) {\r\n\t\t\t\t\t\tcallback(null,dims);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t * finsemble console for displaying diagnostic messages (a transparent replacement for window.console)\r\n\t * @param {string} name prefix for all console output\r\n\t * @memberof Utils\r\n\t * @constructor\r\n\t */\r\n\t\tConsole: function (name) {\r\n\t\t\tvar schema = \"FSBL-Console\";\r\n\t\t\tvar consoleName;\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function for console.error, with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 1\r\n\t\t\t * \r\n\t\t\t */\r\n\t\t\tthis.error = function () {\r\n\t\t\t\tvar myLevel = 1;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Error: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.error.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function for console.warn, with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 2\r\n\t\t\t * \r\n\t\t\t */\r\n\t\t\tthis.warn = function () {\r\n\t\t\t\tvar myLevel = 2;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Warn: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.warn.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function for console.info, with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 3\r\n\t\t\t * \r\n\t\t\t */\r\n\t\t\tthis.info = function () {\r\n\t\t\t\tvar myLevel = 3;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Info: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.info.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function for console.log (but redirected to console.info), with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 3\r\n\t\t\t * \r\n\t\t\t */\r\n\t\t\tthis.log = function () {\r\n\t\t\t\tvar myLevel = 3;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Log: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.info.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function for console.debug, with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 4\r\n\t\t\t * \r\n\t\t\t */\r\n\t\t\tthis.debug = function () {\r\n\t\t\t\tvar myLevel = 4;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Debug: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.debug.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 5\r\n\t\t\t * \r\n\t\t\t */\t\t\r\n\t\t\tthis.debug2 = function () {\r\n\t\t\t\tvar myLevel = 5;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Debug2: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.debug.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 6\r\n\t\t\t * \r\n\t\t\t */\t\t\t\t\r\n\t\t\tthis.debug3 = function () {\r\n\t\t\t\tvar myLevel = 6;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Debug3: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.debug.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\r\n\t\t\t * All output ignored unless SystemSetting.diagLevel() >= 7\r\n\t\t\t * \r\n\t\t\t */\t\t\t\t\r\n\t\t\tthis.debug4 = function () {\r\n\t\t\t\tvar myLevel = 7;\r\n\t\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\r\n\t\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\r\n\t\t\t\t\tvar preface = consoleName + \" Debug4: \";\r\n\t\t\t\t\targs.unshift(preface);\r\n\t\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\r\n\t\t\t\t\targs.push(arguments, suffix);\r\n\t\t\t\t\twindow.console.debug.apply(console, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\tconsoleName = name;\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * @param {any} name\r\n\t\t * @param {any} payload\r\n\t\t * @memberof Utils\r\n\t\t */\r\n\t\tmsgWrapper: function (name, payload) {\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.payload = payload;\r\n\t\t},\r\n\t\r\n\t\tmonitorInfo: null,\r\n\t\t/**\r\n\t\t * returns monitor infor\r\n\t\t * \r\n\t\t * @param {any} force\r\n\t\t * @returns object\r\n\t\t */\r\n\t\tgetMonitorInfo: function (force) {\r\n\t\t\treturn new Promise(function (resolve, reject) {\r\n\t\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\r\n\t\t\t\t\tmodule.exports.monitorInfo = monitorInfo;\r\n\t\t\t\t\tresolve(monitorInfo);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * get the dimensions of a monitor \r\n\t\t * \r\n\t\t * @returns height and weight\r\n\t\t * @memberof Utils\r\n\t\t */\r\n\t\tgetMonitorDimensions: function () {\r\n\t\t\treturn new Promise(\r\n\t\t\t\tfunction (resolve, reject) {\r\n\t\t\t\t\tvar monitorDimensions = {\r\n\t\t\t\t\t\theight: null,\r\n\t\t\t\t\t\twidth: null\r\n\t\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconsole.log('getting data');\r\n\t\t\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\r\n\t\t\t\t\t\tconsole.log('got monitorInfo');\r\n\t\t\t\t\t\t//top bar is 45..\r\n\t\t\t\t\t\tmonitorDimensions.height = monitorInfo.primaryMonitor.availableRect.bottom - monitorInfo.primaryMonitor.availableRect.top - 32;\r\n\t\t\t\t\t\tmonitorDimensions.width = monitorInfo.primaryMonitor.availableRect.right;\r\n\t\t\t\t\t\tmonitorDimensions.left = monitorInfo.primaryMonitor.availableRect.left;\r\n\t\t\t\t\t\tmonitorDimensions.top = monitorInfo.primaryMonitor.availableRect.top;\r\n\t\t\t\t\t\tresolve(monitorDimensions);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t},\r\n\t\r\n\t\tgetMyMonitorDimensions: function (windowBounds) {\r\n\t\t\t//returns the dimensions of the monitor that the window is on.\r\n\t\t\t//@todo: this.\r\n\t\t},\r\n\t\r\n\t\t/**\t \r\n\t\t *\t@returns {string} Transforms an array of strings into a camelcased string.\r\n\t\t * @memberof Utils\r\n\t\t */\r\n\t\tcamelCase: function () {\r\n\t\t\tvar str = '';\r\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\t\tstr += ' ' + arguments[i];\r\n\t\t\t}\r\n\t\t\treturn str\r\n\t\t\t\t.replace(/\\s(.)/g, function ($1) { return $1.toUpperCase(); })\r\n\t\t\t\t.replace(/\\s/g, '')\r\n\t\t\t\t.replace(/^(.)/, function ($1) { return $1.toLowerCase(); });\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Convenience method for cloning an object.\r\n\t\t * @param  {any} from The thing you want to copy\r\n\t\t * @param {any} to Where you want your copy to end up.\r\n\t\t * @return {any} to Where you want your copy to end up.\r\n\t\t */\r\n\t\tclone: function (from, to) {\r\n\t\t\tif (from === null || typeof from !== \"object\") { return from; }\r\n\t\t\t// if (from.constructor != Object && from.constructor != Array) return from;\r\n\t\t\tif (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||\r\n\t\t\t\tfrom.constructor == String || from.constructor == Number || from.constructor == Boolean)\r\n\t\t\t{ return new from.constructor(from); }\r\n\t\r\n\t\t\tto = to || new from.constructor();\r\n\t\r\n\t\t\tfor (var n in from) {\r\n\t\t\t\tto[n] = typeof to[n] === \"undefined\" ? module.exports.clone(from[n], null) : to[n];\r\n\t\t\t}\r\n\t\r\n\t\t\treturn to;\r\n\t\t},\r\n\t\r\n\t\tgetUniqueName: function (baseName) {\r\n\t\t\tif (!baseName) {\r\n\t\t\t\tbaseName = \"RouterClient\";\r\n\t\t\t}\r\n\t\t\tvar uuid = baseName + \".\" + Math.floor(Math.random() * 10000) + Math.floor(Math.random() * 10000);\r\n\t\t\treturn uuid;\r\n\t\t},\r\n\t\r\n\t};\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\r\n\t/**\r\n\t * @introduction\r\n\t * <h2>Finsemble system wide settings for use by all components and services</h2>\r\n\t * \r\n\t * @class SystemSettings\r\n\t */\r\n\t\r\n\t/**\r\n\t * Constructor for Finsemble SystemSettings\r\n\t *\r\n\t * @constructor\r\n\t */\t\r\n\tvar SystemSettings = function () {\r\n\t\r\n\t\tvar currentDiagLevel = 5;\r\n\t\r\n\t\t/**\r\n\t\t * Returns diagnostic level\r\n\t\t *\r\n\t\t *@returns current diagnostic level\r\n\t\t */\t\r\n\t\tthis.diagLevel = function () {\r\n\t\t\treturn currentDiagLevel; \r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Returns true if parameter validation is enabled\r\n\t\t *\r\n\t\t *@returns true if enable\r\n\t\t */\r\n\t\tthis.validationEnabled = function () {\r\n\t\t\treturn (currentDiagLevel >= 4); \r\n\t\t};\r\n\t};\r\n\t\r\n\tmodule.exports = new SystemSettings();\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar SystemSettings = __webpack_require__(2);\r\n\t\r\n\t/**\r\n\t * @introduction\r\n\t * <h2>Finsemble Vaidate Functions</h2>\r\n\t * \r\n\t * @class Validate\r\n\t */\r\n\t\r\n\t/**\r\n\t * Constructor for Finsemble argment validator.\r\n\t *\r\n\t * Validatation logic is ONLY RAN when the console diagnotics level is set to debug (i.e. 4 or above)\r\n\t * A failed validation will generate a warning message, but nothing more; however application logic can check the validation results.\r\n\t *\r\n\t * @param {string} console Finsemble console object used to display messages and check diagnotic level\r\n\t * @memberof Utils\r\n\t * @constructor\r\n\t */\t\r\n\tvar Validate = function () {\r\n\t\r\n\t\tfunction warningMsg(paramDescript, thisArg, thisArgType) {\r\n\t\r\n\t\t\tfunction getErrorObject() {\r\n\t\t\t\ttry { throw Error(''); } catch (err) { return err; }\r\n\t\t\t}\r\n\t\r\n\t\t\tvar err = getErrorObject();\r\n\t\r\n\t\t\tvar caller_line1 = err.stack.split(\"\\n\")[5];\r\n\t\t\tvar index1 = caller_line1.indexOf(\"at \");\r\n\t\t\tvar msgPart1 = caller_line1.slice(index1 + 2, caller_line1.length);\r\n\t\r\n\t\t\tvar caller_line2 = err.stack.split(\"\\n\")[6];\r\n\t\t\tvar index2 = caller_line2.indexOf(\"at \");\r\n\t\t\tvar msgPart2 = caller_line2.slice(index2 + 2, caller_line2.length);\r\n\t\r\n\t\t\tconsole.warn(\"parameter validation failed: parameter \" + paramDescript + \" is of type '\" + typeof (thisArg) + \"' but should be of type '\" + thisArgType + \"' in\" + msgPart1 + \" called by\" + msgPart2);\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Confirm parameters are valid. A variable number of parameter pairs are supported. \r\n\t\t * @param {any} param1 is arg to validate\r\n\t\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \r\n\t\t * @param {any=} param2 is next arg to validate\r\n\t\t * @param {string=} paramType2 os required type for next arg \r\n\t\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\r\n\t\t *\r\n\t\t * @example\r\n\t\t *\r\n\t\t * var validate = new Validate(console); \r\n\t\t * validate.args(name, \"string\", age, \"number\")\r\n\t\t *\r\n\t\t * validate.args(topic, \"string\", initialState, \"object=\"); // with optional paramter (represented by \"=\")\r\n\t\t *\r\n\t\t * validate.args(topic, \"string\", initialState, \"any\"); // with \"any\" type\r\n\t\t *\r\n\t\t * validate.args(subscribeIDStruct, \"object\") && validate.args(subscribeIDStruct.subscribeID, \"string\"); // only do second varidate if first test successful\r\n\t\t *\r\n\t\t * validate.args(subscribeIDStruct, \"object\", subscribeIDStruct.subscribeID, \"string\"); // only check second parm if first validated successful\r\n\t\t *\r\n\t\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\"); // depending on logic, can break into seperate validations\r\n\t\t * params = params || {}; \r\n\t\t * validate.args(params.subscribeCallback, \"function=\", params.publishCallback, \"function=\", params.unsubscribeCallback, \"function=\");\r\n\t\t */\r\n\t\tthis.args = function (param1, paramType1, param2, paramType2 /*.....optional more paramter pairs....*/) {\r\n\t\t\tvar returnCode = true;\r\n\t\t\tif (SystemSettings.validationEnabled()) {\r\n\t\t\t\tvar parmCount = arguments.length;\r\n\t\t\t\tif ((parmCount + 1) % 2 !== 0) { // parameters must come in pairs (i.e. even number)\r\n\t\t\t\t\tfor (var i = 0; i < parmCount; i = i + 2) {\r\n\t\t\t\t\t\tvar optionalArg = false;\r\n\t\t\t\t\t\tvar thisArg = arguments[i];\r\n\t\t\t\t\t\tvar thisArgType = arguments[i + 1];\r\n\t\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\r\n\t\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\r\n\t\t\t\t\t\t\toptionalArg = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\r\n\t\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\r\n\t\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\r\n\t\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\r\n\t\t\t\t\t\t\t\t\twarningMsg(parameterPosition, thisArg, thisArgType);\r\n\t\t\t\t\t\t\t\t\treturnCode = false;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.warn(\"validate.args requires even number of parameters: \" + JSON.stringify(arguments));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Confirm parameters are valid. args2() has the same functionality as args() except a third \"parameter description\" is passed in for each argument varified\r\n\t\t * Typically this for passing in a properties name for better diagnostic messages when varifying object properties.\r\n\t\t * A variable number of parameter \"triples\"\" are supported.\r\n\t\t *\r\n\t\t * @param {string} paramName1 is descriptive name of param1 (for diagnostic message)\r\n\t\t * @param {any} param1 is arg to validate\r\n\t\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\").\r\n\t\t * @param {string} paramName2 is descriptive name of param1 (for diagnostic message)\r\n\t\t * @param {any} param2 is arg to validate\r\n\t\t * @param {string} paramType2 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \r\n\t\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\r\n\t\t *\r\n\t\t * @example\r\n\t\t *\r\n\t\t * var validate = new Utils.Validate(console); \r\n\t\t * validate.args2(\"record.name\", record.name, \"string\", \"record.age\", age, \"number\")\r\n\t\t *\r\n\t\t * // common case using args() and args2() together\r\n\t\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\") &&\r\n\t\t *   validate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\r\n\t\t *   validate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\r\n\t\t */\r\n\t\tthis.args2 = function (paramName1, param1, paramType1, paramName2, param2, paramType2 /*.....optional, more paramter sets of three....*/) {\r\n\t\r\n\t\t\tvar returnCode = true;\r\n\t\t\tif (SystemSettings.validationEnabled()) {\r\n\t\t\t\tvar parmCount = arguments.length;\r\n\t\t\t\tif ((parmCount + 1) % 3 !== 0) { // parameters must come in sets of three \r\n\t\t\t\t\tfor (var i = 0; i < parmCount; i = i + 3) {\r\n\t\t\t\t\t\tvar optionalArg = false;\r\n\t\t\t\t\t\tvar thisArgName = arguments[i];\r\n\t\t\t\t\t\tvar thisArg = arguments[i + 1];\r\n\t\t\t\t\t\tvar thisArgType = arguments[i + 2];\r\n\t\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\r\n\t\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\r\n\t\t\t\t\t\t\toptionalArg = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\r\n\t\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\r\n\t\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\r\n\t\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\r\n\t\t\t\t\t\t\t\t\twarningMsg(thisArgName, thisArg, thisArgType);\r\n\t\t\t\t\t\t\t\t\treturnCode = false;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.warn(\"validate.args requires even number of parameters: \" + JSON.stringify(arguments));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \r\n\t\t};\r\n\t};\r\n\t\r\n\tmodule.exports = new Validate();\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\r\n\t// Copyright 2012-2017 by ChartIQ, Inc\r\n\t// -------------------------------------------------------------------------------------------\r\n\t\r\n\t/**\r\n\t * @introduction\r\n\t * <h2>Router Client Instance</h2>\r\n\t * Exports a single shared instance of the router client.  See {@link RouterClientConstructor} for the complete API definition with examples.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *\t// get a shared instance of RouterClient (shared within the containing component or service)\r\n\t *\tvar RouterClient = require('./routerClientInstance');\r\n\t *\r\n\t * @namespace RouterClientInstance\r\n\t * @shouldBePublished false\r\n\t */\r\n\t\r\n\t\"use strict\";\r\n\t\r\n\tvar RouterClientConstructor = __webpack_require__(5);\r\n\t\r\n\tmodule.exports = new RouterClientConstructor(\"RouterSingleton\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\r\n\t// Copyright 2012-2017 by ChartIQ, Inc\r\n\t// -------------------------------------------------------------------------------------------\r\n\t\r\n\t\"use strict\";\r\n\tvar RouterTransport = __webpack_require__(6);\r\n\tvar Utils = __webpack_require__(1);\r\n\tvar Validate = __webpack_require__(3); // Finsemble args validator\r\n\tvar console = new Utils.Console(\"RouterClient\"); // Finsemble console\r\n\t\r\n\t/**\r\n\t * @introduction\r\n\t *\r\n\t * <h2>Router Client</h2>\r\n\t *\r\n\t * This modules contains the RouterClient for sending and receiving events between Finsemble components and services.\r\n\t * See <a href=tutorial-eventRouter.html>Event Router Tutorial</a> for an overview of the router's functionality.\r\n\t *\r\n\t * The RouterClientConstructor() returns one instance of a router client; however FSBL.RouterClient is always \r\n\t * initialized with an instance of the router exported by the RouterClient module (making it essentially a singleton\r\n\t * when referenced in the same window). Still, there are no restriction on the number of router clients created\r\n\t * within the same window. \r\n\t *\r\n\t * Although it's transparent, the router uses the <a href=\"http://cdn.openfin.co/jsdocs/stable/fin.desktop.module_InterApplicationBus.html\">OpenFin Bus</a> and SharedWorker threads for transporting events between router clients and the router service. \r\n\t *\r\n\t * **Event Callbacks**: Note all router callbacks are in the form of `callback(error, event)`\r\n\t *\r\n\t * @example\r\n\t *\r\n\t * // user FSBL.RouterClient or create an instance of Router Client\r\n\t * RouterClientConstructor = require('./routerClientConstructor');\r\n\t * RouterClient = new RouterClientConstructor(\"clientname\");\r\n\t *\r\n\t * // add a listener for incoming event on the specified channel\r\n\t * RouterClient.addListener(\"myListenChannel\",eventHandler);\r\n\t * //\r\n\t * // transmit event to all listeners on specified channel\r\n\t * RouterClient.transmit(\"myListenChannel\", transmitEvent);\r\n\t * \r\n\t * // add server for incoming events on the specified channel\r\n\t * RouterClient.addServer(\"myServerChannel\",eventHandler);\r\n\t *\r\n\t * // query the server on the specified channel\r\n\t * RouterClient.query(\"myServerChannel\",queryEvent, responseEventHandler);\r\n\t *\r\n\t * // create Subscribe-Publish server for specified topic\r\n\t * RouterClient.addPubSubServer(\"myTopic\");\r\n\t *\r\n\t * // create Subscribe-Publish server for specified wildcard topic (i.g. using RegEx), specifiying all the optional callback\r\n\t * RouterClient.addPubSubServer(\\/topicA*\\/, { \"State\": \"start\" }, { subscribeCallback:subscribeCallback, publishCallback:publishCallback, unsubscribeCallback:unsubscribeCallback } );\r\n\t *\r\n\t * // subscribe to the specified PubSub server for specified topic\r\n\t * RouterClient.subscribe(\"myTopic\",notifyEventHandler);\r\n\t *\r\n\t * // publish to the specified PubSub server for specified topic\r\n\t * RouterClient.publish(\"myTopic\",publishEvent);\r\n\t *\r\n\t * @constructor\r\n\t * @publishedName RouterClient\r\n\t * @param {string} thisClientName router client name for human readable messages\r\n\t * @param {string} transportName router transport name (usually this is autoconfigured internally but can be selected for testing or special configurations)\r\n\t */\r\n\tvar RouterClientConstructor = function (thisClientName, transportName) {\r\n\t\tValidate.args(thisClientName, \"string\", transportName, \"string=\");\r\n\t\r\n\t\t///////////////////////////\r\n\t\t// Private Data\r\n\t\t///////////////////////////\t\r\n\t\tvar mapListeners = {};\r\n\t\tvar mapServers = {};\r\n\t\tvar mapPubSubServers = {};\r\n\t\tvar mapPubSubServerState = {};\r\n\t\tvar mapPubSubServerRegEx = {};\r\n\t\tvar pubsubListOfSubscribers = {};\r\n\t\tvar mapSubscribersID = {};\r\n\t\tvar mapSubscribersTopic = {};\r\n\t\tvar mapQueryResponses = {};\r\n\t\tvar clientIDCounter = 1000;\r\n\t\tvar clientName;\r\n\t\tvar transport;\r\n\t\tvar self = this;\r\n\t\r\n\t\t/////////////////////////////////////////////////////////////////////\r\n\t\t// Private Message Contructors for Communicating with RouterService\r\n\t\t/////////////////////////////////////////////////////////////////////\r\n\t\tfunction AddListenerMessage(channel) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"addListener\",\r\n\t\t\t\t\"channel\": channel\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction TransmitMessage(toChannel, data) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"transmit\",\r\n\t\t\t\t\"channel\": toChannel\r\n\t\t\t};\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tfunction RemoveListenerMessage(channel) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"removeListener\",\r\n\t\t\t\t\"channel\": channel\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction AddServerMessage(channel) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"addServer\",\r\n\t\t\t\t\"channel\": channel\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction QueryMessage(queryID, channel, data) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"query\",\r\n\t\t\t\t\"queryID\": queryID,\r\n\t\t\t\t\"channel\": channel\r\n\t\t\t};\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tfunction QueryResponseMessage(queryID, error, data) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"queryResponse\",\r\n\t\t\t\t\"queryID\": queryID,\r\n\t\t\t\t\"error\": error\r\n\t\t\t};\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tfunction RemoveServerMessage(channel) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"removeServer\",\r\n\t\t\t\t\"channel\": channel\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction SubscribeMessage(subscribeID, topic) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"subscribe\",\r\n\t\t\t\t\"subscribeID\": subscribeID,\r\n\t\t\t\t\"topic\": topic\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction UnsubscribeMessage(subscribeID, topic) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"unsubscribe\",\r\n\t\t\t\t\"subscribeID\": subscribeID,\r\n\t\t\t\t\"topic\": topic\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction PublishMessage(topic, data) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"publish\",\r\n\t\t\t\t\"topic\": topic\r\n\t\t\t};\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tfunction NotifyMessage(subscribeID, topic, error, data) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"notify\",\r\n\t\t\t\t\"subscribeID\": subscribeID,\r\n\t\t\t\t\"topic\": topic,\r\n\t\t\t\t\"error\":error\r\n\t\t\t};\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tfunction AddPubSubServerMessage(topic) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"addPubSubServer\",\r\n\t\t\t\t\"topic\": topic\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction RemovePubSubServerMessage(topic) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"removePubSubServer\",\r\n\t\t\t\t\"topic\": topic\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction JoinGroupMessage(group) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"joinGroup\",\r\n\t\t\t\t\"group\": group\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction LeaveGroupMessage(group) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"leaveGroup\",\r\n\t\t\t\t\"group\": group\r\n\t\t\t};\r\n\t\t}\r\n\t\tfunction GroupTransmitMessage(group, toChannel, message, data) {\r\n\t\t\tthis.header = {\r\n\t\t\t\t\"origin\": clientName,\r\n\t\t\t\t\"type\": \"groupTransmit\",\r\n\t\t\t\t\"group\": group,\r\n\t\t\t\t\"channel\": toChannel\r\n\t\t\t};\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\r\n\t\t//////////////////////\r\n\t\t// Private Functions\r\n\t\t//////////////////////\r\n\t\r\n\t\t// router client is being terminated so cleanup\t\r\n\t\tfunction destructor(event) {\r\n\t\t\tconsole.info(\"shutting down on event: \" + JSON.stringify(event));\r\n\t\t\tself.disconnectAll(); // this will let the router know the client is terminating\r\n\t\t\tconsole.debug(\"shutting down complete\");\r\n\t\t}\r\n\t\r\n\t\t// called once on router-client creation\r\n\t\tfunction constructor(thisClientName, transportName) {\r\n\t\t\tclientName = Utils.getUniqueName(thisClientName);\r\n\t\r\n\t\t\tif (typeof(transportName) === 'undefined') {\r\n\t\t\t\ttransport = RouterTransport.getRecommendedTransport(incomingMessageHandler, clientName, \"RouterService\");\r\n\t\t\t} else {\r\n\t\t\t\ttransport = RouterTransport.getTransport(transportName, incomingMessageHandler, clientName, \"RouterService\");\r\n\t\t\t}\r\n\t\r\n\t\t\t// catch \"window closing\" event so can cleanup\t\r\n\t\t\tvar finWindow = fin.desktop.Window.getCurrent();\r\n\t\t\tfinWindow.addEventListener(\"closed\", destructor); // this is the correct event to catch but currently doesn't work on mac\r\n\t\r\n\t\t\tconsole.info(\"starting \" + clientName + \" with transport \" + transport.identifier() );\r\n\t\t}\r\n\t\r\n\t\t// provides unique id within one router client for queries\r\n\t\tfunction clientID() {\r\n\t\t\treturn clientName + \".\" + (++clientIDCounter);\r\n\t\t}\r\n\t\r\n\t\t// returns true if this routerClient originated the message\r\n\t\tfunction originatedHere() {\r\n\t\t\treturn this.header.origin ===  this.header.lastClient;\r\n\t\t}\r\n\t\r\n\t\t// invoke client callbacks in the input array (that are attached to a specific channel and listener type) \r\n\t\tfunction invokeListenerCallbacks(map, message) {\r\n\t\t\tvar clientCallbackArray = map[message.header.channel];\r\n\t\t\tif (clientCallbackArray === undefined) {\r\n\t\t\t\tconsole.warn(\"no handler defined for incoming message\" + JSON.stringify(message));\r\n\t\t\t} else {\r\n\t\t\t\tmessage.originatedHere = originatedHere;// add local function to test origin\r\n\t\t\t\tfor (var i = 0; i < clientCallbackArray.length; i++) { // for each callback defined for the channel\r\n\t\t\t\t\tconsole.debug(\"invoke listener callback for incoming transmit: \" + JSON.stringify(message));\r\n\t\t\t\t\tclientCallbackArray[i](null, message); // invoke the callback; the error parameter is always null for this case\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction sendQueryResponse(err, responseData) {\r\n\t\t\tconsole.debug(\"send query response: \" + JSON.stringify(responseData));\r\n\t\t\tsendToRouterService(new QueryResponseMessage(this.header.queryID, err, responseData));\r\n\t\t}\r\n\t\r\n\t\t// invoke server-listener callback (attached to a specific channel) \r\n\t\tfunction invokeServerCallback(map, queryMessage) {\r\n\t\t\tvar serverCallback = map[queryMessage.header.channel];\r\n\t\t\tif (serverCallback === undefined) {\r\n\t\t\t\tconsole.warn(2, \"no server defined for incoming query message: \" + JSON.stringify(queryMessage));\r\n\t\t\t} else {\r\n\t\t\t\tif (!queryMessage.header.error) {\r\n\t\t\t\t\tqueryMessage.originatedHere = originatedHere; // add local function to test origin\r\n\t\t\t\t\tqueryMessage.sendQueryResponse = sendQueryResponse; // add callback function to message so server can respond to query\r\n\t\t\t\t\tconsole.debug(\"invoke server callback for incoming query: \" + JSON.stringify(queryMessage));\r\n\t\t\t\t\tserverCallback(null, queryMessage); // invoke the callback (no error)\r\n\t\t\t\t} else { // invoke the callback with error since  flag in message (from router service)\r\n\t\t\t\t\tserverCallback(queryMessage.header.error, null);\r\n\t\t\t\t\tconsole.debug(\"server callback with RouterService error: \" + JSON.stringify(queryMessage.header));\r\n\t\t\t\t\tdelete map[queryMessage.header.channel]; // this is a bad server (e.g. duplicate) so remove it\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// add a callbackHandler into the query-response map for the given queryID\r\n\t\tfunction addQueryResponseCallBack(map, queryID, responseCallback) {\r\n\t\t\tmap[queryID] = responseCallback;\r\n\t\t}\r\n\t\r\n\t\t// invoke query-response callback (that is attached to a specific channel and listener type) \r\n\t\tfunction invokeQueryResponseCallback(map, responseMessage) {\r\n\t\t\tvar clientCallback = map[responseMessage.header.queryID];\r\n\t\t\tif (clientCallback === undefined) {\r\n\t\t\t\tconsole.warn(\"no handler defined for query response: \" + JSON.stringify(responseMessage));\r\n\t\t\t} else {\r\n\t\t\t\tif (!responseMessage.header.error) {\r\n\t\t\t\t\tconsole.debug(\"invoke queryResponse callback for query: \" + JSON.stringify(responseMessage));\r\n\t\t\t\t\tclientCallback(null, responseMessage); // invoke the callback passing the response message\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.debug(\"queryResponse callback with RouterService error: \" + JSON.stringify(responseMessage.header));\r\n\t\t\t\t\tclientCallback(responseMessage.header.error, responseMessage); // error from router service so pass it back instead of a message\r\n\t\t\t\t}\r\n\t\t\t\tdelete map[responseMessage.header.queryID];\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// add server callbackHandler for the given channel\r\n\t\tfunction addServerCallBack(map, channel, callback) {\r\n\t\t\tvar status = false;\r\n\t\t\tvar clientCallback = map[channel];\r\n\t\t\tif (clientCallback === undefined) {\r\n\t\t\t\tmap[channel] = callback;\r\n\t\t\t\tstatus = true;\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\t\t}\r\n\t\r\n\t\t// support function for sendNotifyToSubscriber -- maintains local list of subscribers for pubsub server\r\n\t\tfunction addToSubpubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\r\n\t\t\tif (!(topic in pubsubListOfSubscribers)) {\r\n\t\t\t\tpubsubListOfSubscribers[topic] = [subscribeID];\r\n\t\t\t} else {\r\n\t\t\t\tpubsubListOfSubscribers[topic].push(subscribeID);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// support function for addPubSubServer -- add pubsub server callbackHandler for the given channel\r\n\t\tfunction addPubSubServerCallBack(topic, subscribeCallback, publishCallback, unsubscribeCallback) {\r\n\t\t\tvar status = false;\r\n\t\t\tvar callbacks = mapPubSubServers[topic.toString()];\r\n\t\t\tif (callbacks === undefined) {\r\n\t\t\t\tif (topic instanceof RegExp) {\r\n\t\t\t\t\tmapPubSubServerRegEx[topic.toString()] = topic; \r\n\t\t\t\t\tconsole.debug(\"RegEx added for topic \" + topic.toString()); // Note: topic may be a RegEx, so use toString() where applicable\r\n\t\t\t\t}\r\n\t\t\t\tmapPubSubServers[topic.toString()] = { \"subscribeCallback\":subscribeCallback, \"publishCallback\": publishCallback, \"unsubscribeCallback\":unsubscribeCallback };\r\n\t\t\t\tstatus = true;\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\t\t}\r\n\t\r\n\t\t// callback function for invokeSubscribePubSubCallback to notify new subscriber\r\n\t\tfunction sendNotifyToSubscriber(err, notifyData) {\r\n\t\t\tsendToRouterService(new NotifyMessage(this.header.subscribeID, this.header.topic, err, notifyData));\r\n\t\t\tif (!err) {\r\n\t\t\t\t// add new subscriber to list\r\n\t\t\t\taddToSubpubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\r\n\t\t\t\tconsole.debug(\"subscription added pubsub server: \" + JSON.stringify(this));\r\n\t\t\t} else {\r\n\t\t\t\tconsole.debug(\"subscribe rejected by pubsub server: \" + JSON.stringify(this));\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// for incoming subscribe: invoke notify callback for pubsub server\r\n\t\tfunction invokeSubscribePubSubCallback(subscribeMessage) {\r\n\t\t\tvar callbacks = mapPubSubServers[subscribeMessage.header.topic];\r\n\t\r\n\t\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\r\n\t\t\t\tfor (var key in mapPubSubServerRegEx) {\r\n\t\t\t\t\tif (mapPubSubServerRegEx[key].test(subscribeMessage.header.topic)) {\r\n\t\t\t\t\t\tcallbacks = mapPubSubServers[key];\r\n\t\t\t\t\t\tvar initialState = mapPubSubServerState[subscribeMessage.header.topic]; // may already be initial state defined from publish\r\n\t\t\t\t\t\tif (initialState === undefined) { // if there isn't already state defined then use default from regEx\r\n\t\t\t\t\t\t\tinitialState = mapPubSubServerState[key]; // initialize the state from RegEx topic\t\r\n\t\t\t\t\t\t}\t\r\n\t\t\t\t\t\tmapPubSubServerState[subscribeMessage.header.topic] = initialState; \r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tif (callbacks === undefined) { // if still undefined\r\n\t\t\t\tconsole.warn(\"no pubsub server defined for incoming subscribe message: \" + JSON.stringify(subscribeMessage));\r\n\t\t\t} else {\r\n\t\t\t\tif (subscribeMessage.header.error) { // the router service uses the subscribe message in this case to return a pubsub error (ToDO: consider a generic error message)\r\n\t\t\t\t\tconsole.warn(\"pubsub error received from router service: \" + JSON.stringify(subscribeMessage.header.error));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsubscribeMessage.sendNotifyToSubscriber = sendNotifyToSubscriber; // add callback function to message so pubsub server can respond with Notify message\r\n\t\t\t\t\tif (callbacks.subscribeCallback) {\r\n\t\t\t\t\t\tcallbacks.subscribeCallback(null, subscribeMessage); // invoke the callback (no error)\r\n\t\t\t\t\t} else { // since no subscribe callback defined, use default functionality\r\n\t\t\t\t\t\tsubscribeMessage.sendNotifyToSubscriber(null,mapPubSubServerState[subscribeMessage.header.topic]); // must invoke from message to set this properly \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// support function for removeSubscriber callback --  remove one subscribeID from array for the given subscription topic\r\n\t\tfunction removeFromSubpubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\r\n\t\t\tvar removed = false;\r\n\t\t\tif (topic in pubsubListOfSubscribers) {\r\n\t\t\t\tvar list = pubsubListOfSubscribers[topic];\r\n\t\t\t\tfor (var i = 0; i < list.length; i++) {\r\n\t\t\t\t\tif (subscribeID === list[i]) {\r\n\t\t\t\t\t\tlist.splice(i, 1);\r\n\t\t\t\t\t\tif (list.length === 0) {\r\n\t\t\t\t\t\t\tdelete pubsubListOfSubscribers[topic];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tremoved = true;\r\n\t\t\t\t\t\tconsole.debug(\"removeListener to \" + topic + \" from \" + JSON.stringify(subscribeID));\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!removed) {\r\n\t\t\t\tconsole.warn(\"tried to remove non-existance listener on \" + topic + \" from \" + JSON.stringify(subscribeID));\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// callback function for invokeUnsubscribePubSubCallback to remove the subscriber from the subscription\t\r\n\t\tfunction removeSubscriber() {\r\n\t\t\tremoveFromSubpubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\r\n\t\t}\r\n\t\t\r\n\t\t// for incoming unsubscribe: invoke unsubscribe callback for pubsub servier\r\n\t\tfunction invokeUnsubscribePubSubCallback(unsubscribeMessage) {\r\n\t\t\tvar callbacks = mapPubSubServers[unsubscribeMessage.header.topic];\r\n\t\r\n\t\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\r\n\t\t\t\tfor (var key in mapPubSubServerRegEx) {\r\n\t\t\t\t\tif (mapPubSubServerRegEx[key].test(unsubscribeMessage.header.topic)) {\r\n\t\t\t\t\t\tcallbacks = mapPubSubServers[key];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tif (callbacks === undefined) { // if still undefined\r\n\t\t\t\tconsole.warn(\"no pubsub server defined for incoming unsubscribe message: \" + JSON.stringify(unsubscribeMessage));\r\n\t\t\t} else {\r\n\t\t\t\tunsubscribeMessage.removeSubscriber = removeSubscriber; // add callback function to message for pubsub server (but must always remove)\r\n\t\t\t\tif (callbacks.unsubscribeCallback) {\r\n\t\t\t\t\tcallbacks.unsubscribeCallback(null, unsubscribeMessage); // invoke the callback (no error)\r\n\t\t\t\t} else { // since no unsubscribe callback defined, use default functionality\r\n\t\t\t\t\tunsubscribeMessage.removeSubscriber();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// callback function for invokePublishPubSubCallback to send Notify \t\r\n\t\tfunction sendNotifyToAllSubscribers(err, notifyData) {\r\n\t\t\tif (!err) {\r\n\t\t\t\tmapPubSubServerState[this.header.topic] = notifyData; // store new state\r\n\t\t\t\tvar listOfSubscribers = pubsubListOfSubscribers[this.header.topic];\r\n\t\t\t\tif (typeof(listOfSubscribers) !== 'undefined') { // confirm subscribers to send to, if none then nothing to do\r\n\t\t\t\t\tfor (var i = 0; i < listOfSubscribers.length; i++) {\r\n\t\t\t\t\t\tsendToRouterService(new NotifyMessage(listOfSubscribers[i], this.header.topic, err, notifyData));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\r\n\t\t\t} else {\r\n\t\t\t\tconsole.debug(\"income publish rejected by pubsub server: \" + JSON.stringify(err));\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// for incoming Publish: invoke publish callback for pubsub servier\r\n\t\tfunction invokePublishPubSubCallback(publishMessage) {\r\n\t\t\tvar callbacks = mapPubSubServers[publishMessage.header.topic];\r\n\t\r\n\t\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\r\n\t\t\t\tfor (var key in mapPubSubServerRegEx) {\r\n\t\t\t\t\tif (mapPubSubServerRegEx[key].test(publishMessage.header.topic)) {\r\n\t\t\t\t\t\tcallbacks = mapPubSubServers[key];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tif (callbacks === undefined) { // if still undefined\r\n\t\t\t\tconsole.warn(\"no pubsub server defined for incoming publish message: \" + JSON.stringify(publishMessage));\r\n\t\t\t} else {\r\n\t\t\t\tpublishMessage.sendNotifyToAllSubscribers = sendNotifyToAllSubscribers; // add callback function to message so pubsub server can respond to publish\r\n\t\t\t\tif (callbacks.publishCallback) {\r\n\t\t\t\t\tcallbacks.publishCallback(null, publishMessage); // invoke the callback (no error)\r\n\t\t\t\t} else { // since no pubish callback defined, use default functionality\r\n\t\t\t\t\tpublishMessage.sendNotifyToAllSubscribers(null,publishMessage.data); // must call from publish message (like a callback) so 'this' is properly set\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// for incoming Notify: invoke notify callback (that are attached to a specific channel and listener type) \r\n\t\tfunction invokeNotifyCallback(mapSubscribersID, notifyMessage) {\r\n\t\t\tvar notifyCallback = mapSubscribersID[notifyMessage.header.subscribeID];\r\n\t\t\tif (notifyCallback === undefined) {\r\n\t\t\t\tconsole.warn(\"no subscription handler defined for incoming notify: \" + JSON.stringify(notifyMessage));\r\n\t\t\t} else {\r\n\t\t\t\tif (!notifyMessage.header.error) {\r\n\t\t\t\t\tnotifyMessage.originatedHere = originatedHere;// add local function to test origin\r\n\t\t\t\t\tnotifyCallback(null, notifyMessage); // invoke the callback passing the response message\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnotifyCallback(notifyMessage.header.error, notifyMessage); // error from router service so pass it back instead of a message\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// outgoing Unsubscribe: remove subscriber callbackHandler for the given channel\r\n\t\tfunction removeSubscriberCallBack(mapSubscribersID, subscribeID) {\r\n\t\t\tvar status = false;\r\n\t\t\tvar notifyCallback = mapSubscribersID[subscribeID];\r\n\t\t\tif (notifyCallback !== undefined) {\r\n\t\t\t\tdelete mapSubscribersID[subscribeID];\r\n\t\t\t\tstatus = true;\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\t\t}\r\n\t\r\n\t\t// for outgoing addSubscriber -- add a callback Handler for the subscribe\r\n\t\tfunction addSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic) {\r\n\t\t\tmapSubscribersID[subscribeID] = notifyCallback;\r\n\t\t\tmapSubscribersTopic[subscribeID] = topic;\r\n\t\r\n\t\t}\r\n\t\t\r\n\t\t// for removePubSubServer: remove server callbackHandler for the given channel\r\n\t\tfunction removeServerCallBack(map, channel) {\r\n\t\t\tvar status = false;\r\n\t\t\tvar clientCallback = map[channel];\r\n\t\t\tif (clientCallback !== undefined) {\r\n\t\t\t\tdelete map[channel];\r\n\t\t\t\tstatus = true;\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\t\t}\r\n\t\r\n\t\t// for addListener: add a callbackHandler into the specified map (which depends on listener type) for the given channel\r\n\t\tfunction addListenerCallBack(map, channel, callback) {\r\n\t\t\tvar firstChannelClient = false;\r\n\t\t\tvar clientCallbackArray = map[channel];\r\n\t\t\tif (clientCallbackArray === undefined) {\r\n\t\t\t\tmap[channel] = [callback];\r\n\t\t\t\tfirstChannelClient = true;\r\n\t\t\t} else {\r\n\t\t\t\tclientCallbackArray.push(callback);\r\n\t\t\t}\r\n\t\t\treturn firstChannelClient;\r\n\t\t}\r\n\t\r\n\t\t// for removeListener: remove a callbackHandler from the specified map (which depends on listener type) for the given channel\r\n\t\tfunction removeListenerCallBack(map, channel, callback) {\r\n\t\t\tvar lastChannelClient = false;\r\n\t\t\tvar clientCallbackArray = map[channel];\r\n\t\t\tif (clientCallbackArray !== undefined) {\r\n\t\t\t\tvar index = clientCallbackArray.indexOf(callback);\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tclientCallbackArray.splice(index, 1);\r\n\t\t\t\t\tif (clientCallbackArray.length === 0) {\r\n\t\t\t\t\t\tlastChannelClient = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.warn(\"no listener defined for channel: \" + channel);\r\n\t\t\t\t}\r\n\t\t\t} \r\n\t\t\treturn lastChannelClient;\r\n\t\t}\r\n\t\r\n\t\t// route incoming message to appropriate callback, which depends on the message type and channel\r\n\t\tfunction routeIncomingMessage(incomingMessage) {\r\n\t\t\tconsole.debug2(\"Incoming Message: \" + incomingMessage.header.type);\r\n\t\t\tswitch (incomingMessage.header.type) {\r\n\t\t\t\tcase \"transmit\":\r\n\t\t\t\t\tinvokeListenerCallbacks(mapListeners, incomingMessage);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"query\":\r\n\t\t\t\t\tinvokeServerCallback(mapServers, incomingMessage);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"queryResponse\":\r\n\t\t\t\t\tinvokeQueryResponseCallback(mapQueryResponses, incomingMessage);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"notify\":\r\n\t\t\t\t\tinvokeNotifyCallback(mapSubscribersID, incomingMessage);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"publish\":\r\n\t\t\t\t\tinvokePublishPubSubCallback(incomingMessage);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"subscribe\":\r\n\t\t\t\t\tinvokeSubscribePubSubCallback(incomingMessage);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"unsubscribe\":\t\r\n\t\t\t\t\tinvokeUnsubscribePubSubCallback(incomingMessage);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// *** all incoming messages from underlying transport arrive here ***\r\n\t\t// although incoming transport information is available, it is not passed on because not needed \r\n\t\tfunction incomingMessageHandler(incomingTransportInfo, message) {\r\n\t\t\t// ToDo: good place to put a function to validate incoming message/data\r\n\t\t\tmessage.header.lastClient = clientName; // add last client for diagnostics\r\n\t\t\trouteIncomingMessage(message);\r\n\t\t}\r\n\t\r\n\t\t// *** all outbound messages exit here though the appropriate transport ***\r\n\t\tfunction sendToRouterService(message) {\r\n\t\t\tconsole.debug2(\"Outgoing Message: \" + JSON.stringify(message.header.type));\r\n\t\t\ttransport.send(message);\r\n\t\t}\r\n\t\r\n\t\r\n\t\t/////////////////////////////////////////////\r\n\t\t// Public Functions -- The Router Client API\r\n\t\t/////////////////////////////////////////////\r\n\t\r\n\t\t/**\r\n\t\t * Set route client name to human readable form for better diagnotics.  An random id is concatenated on the end to ensure uniqueness.\r\n\t\t * \r\n\t\t * @param {string} newClientName\r\n\t\t * @example\r\n\t\t *\r\n\t\t * RouterClient.setClientName(\"MyComponent\");\r\n\t\t */\r\n\t\tthis.setClientName = function (newClientName) {\r\n\t\t\tValidate.args(thisClientName, \"string\");\r\n\t\t\tclientName = Utils.getUniqueName(newClientName);\r\n\t\t\tconsole.info(\"Route Client name set to \" + clientName);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Add listener for incoming transmit events on specified channel.\r\n\t\t * \r\n\t\t * @param {string} channel\r\n\t\t * @param {function} eventHandler\r\n\t\t * @example\r\n\t\t *\r\n\t\t * RouterClient.addListener(\"SomeChannelName\", function (error, message) {\r\n\t\t * \t\t// process incoming channel message\t\t\r\n\t\t * });\r\n\t\t *\r\n\t\t */\r\n\t\tthis.addListener = function(channel, eventHandler) {\r\n\t\t\tconsole.debug(\"addListener to channel \" + channel);\r\n\t\t\tValidate.args(channel, \"string\", eventHandler, \"function\");\r\n\t\t\tvar firstChannelClient = addListenerCallBack(mapListeners, channel, eventHandler);\r\n\t\t\tif (firstChannelClient) {\r\n\t\t\t\tsendToRouterService(new AddListenerMessage(channel));\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Transmit event to all listeners on the specified channel.\r\n\t\t * \r\n\t\t * @param {string} toChannel\r\n\t\t * @param {any} event -- object or primitive type to be transmitted\r\n\t\t * @example\r\n\t\t *\r\n\t\t * RouterClient.transmit(\"SomeChannelName\", channelMessage);\r\n\t\t *\r\n\t\t */\r\n\t\tthis.transmit = function (toChannel, event) {\r\n\t\t\tconsole.debug(\"transmit to channel \" + toChannel + \" event: \" + JSON.stringify(event));\r\n\t\t\tValidate.args(toChannel, \"string\", event, \"any\");\r\n\t\t\tsendToRouterService(new TransmitMessage(toChannel, event));\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Remove event listener from specified channel.\r\n\t\t * \r\n\t\t * @param {string} channel\r\n\t\t * @param {function} eventHandler for the listener\r\n\t\t */\r\n\t\tthis.removeListener = function (channel, eventHandler) {\r\n\t\t\tconsole.debug(\"removelistener to channel \" + channel);\r\n\t\t\tValidate.args(channel, \"string\", eventHandler, \"function\");\r\n\t\t\tvar lastChannelListener = removeListenerCallBack(mapListeners, channel, eventHandler);\r\n\t\t\tif (lastChannelListener) {\r\n\t\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/** \r\n\t\t * Add query server to the specified channel (only one server allowed per channel)\r\n\t\t * \r\n\t\t * @param {string} channel\r\n\t\t * @param {function} queryEventHandler\r\n\t\t * @example\r\n\t\t *\r\n\t\t * RouterClient.addServer(\"ServerChannelName\", function (error, queryMessage) {\r\n\t\t *\tif (error) {\r\n\t\t *\t\tconsole.log('addServer failed: ' + JSON.stringify(error));\r\n\t\t *\t} else {\r\n\t\t *\t\t// process income query message\r\n\t\t *\t\t// then send query response\r\n\t\t *\t\tqueryMessage.sendQueryResponse(null, queryMessage.data);\r\n\t\t *\t}\r\n\t\t * });\r\n\t\t *\r\n\t\t */\r\n\t\tthis.addServer = function (channel, queryEventHandler) {\r\n\t\t\tconsole.debug(\"addServer for channel \" + channel);\r\n\t\t\tValidate.args(channel, \"string\", queryEventHandler, \"function\");\r\n\t\t\tvar status = addServerCallBack(mapServers, channel, queryEventHandler);\r\n\t\t\tif (status) {\r\n\t\t\t\tsendToRouterService(new AddServerMessage(channel));\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"Server already locally defined for channel \" + channel);\r\n\t\t\t\tqueryEventHandler({\r\n\t\t\t\t\t\"RouteClient QueryError\": \"Server already locally defined for channel\"\r\n\t\t\t\t}, null); // immediately invoke callback passing error\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Send a query to server listening on specified channel.\r\n\t\t * \r\n\t\t * @param {any} serverChannel\r\n\t\t * @param {object=} queryEvent event message sent to server\r\n\t\t * @param {function} responseEventHandler\r\n\t\t */\r\n\t\tthis.query = function (serverChannel, queryEvent, responseEventHandler) {\r\n\t\t\tconsole.debug(\"query to server channel \" + serverChannel + \" passing event: \" + JSON.stringify(queryEvent));\r\n\t\t\tValidate.args(serverChannel, \"string\", queryEvent, \"any=\", responseEventHandler, \"function\");\r\n\t\t\tvar newQueryID = clientID();\r\n\t\t\taddQueryResponseCallBack(mapQueryResponses, newQueryID, responseEventHandler);\r\n\t\t\tsendToRouterService(new QueryMessage(newQueryID, serverChannel, queryEvent));\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Remove query server from specified channel.\r\n\t\t * \r\n\t\t * @param {string} serverChannel\r\n\t\t */\r\n\t\tthis.removeServer = function (serverChannel) {\r\n\t\t\tconsole.debug(\"removeServer from server channel \" + serverChannel);\r\n\t\t\tValidate.args(serverChannel, \"string\");\r\n\t\t\tvar status = removeServerCallBack(mapServers, serverChannel);\r\n\t\t\tif (status) {\r\n\t\t\t\tsendToRouterService(new RemoveServerMessage(serverChannel));\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Add a PubSub server for specified topic. Only one PubSub server allowed per topic value; however, the topic value\r\n\t\t * may be a regular-expression representing a set of related topics, in which case the PubSub server will server all matching topics.\r\n\t\t * When a regEx topic is used, the same default functionality is provides for each matching topic -- the difference\r\n\t\t * is only one SubPub server is needed to cover a set of related topics, plus the same callback handers can be used (if provided).\r\n\t\t *\r\n\t\t * Note an exact topic match will take precedence over a regEx match, but otherwise results are unpredictable for overlapping RegEx topics.\r\n\t\t * \r\n\t\t * @param {string} topic topic for this server, or a topic RegEx (e.g. '/abc.+/') to handle a set of topics\r\n\t\t * @param {object} initialState for the topic (defaults to empty struct)\r\n\t\t * @param {object=} params optional parameters\r\n\t\t * @param {function=} params.subscribeCallback allows server know of the subscription and accept or reject it (default is to accept)\r\n\t\t * @param {function=} params.publishCallback allows server to use the publish data to form a new state (default is the publish data becomes the new state)\r\n\t\t * @param {function=} params.unsubscribeCallback allows server to know of the unsubscribe, but it must be accepted\r\n\t\t *\r\n\t\t * @example\r\n\t\t *\r\n\t\t * function subscribeCallback(error, subscribe) {\r\n\t\t * \t\tif (subscribe) {\r\n\t\t * \t\t\t// must make this callback to accept or reject the subscribe (default is to accept). First parm is err and second is the initial state\r\n\t\t * \t\t\tsubscribe.sendNotifyToSubscriber(null, { \"NOTIFICATION-STATE\": \"One\" });\r\n\t\t * \t\t}\r\n\t\t * }\r\n\t\t * function publishCallback(error, publish) {\r\n\t\t * \t\tif (publish) {\r\n\t\t * \t\t\t// must make this callback to send notify to all subscribers (if error parameter set then notify will not be sent)\r\n\t\t * \t\t\tpublish.sendNotifyToAllSubscribers(null, publish.data); \r\n\t\t * \t\t}\r\n\t\t * }\r\n\t\t * function unsubscribeCallback(error, unsubscribe) {\r\n\t\t * \t\tif (unsubscribe) {\r\n\t\t * \t\t\t// must make this callback to acknowledge the unsubscribe \r\n\t\t * \t\t\tunsubscribe.removeSubscriber();\r\n\t\t * \t\t}\r\n\t\t * }\r\n\t\t * RouterClient.addPubSubServer(\"topicABC\", { \"State\": \"start\" }, { subscribeCallback:subscribeCallback, publishCallback:publishCallback, unsubscribeCallback:unsubscribeCallback } );\r\n\t\t *\r\n\t\t *   or\r\n\t\t *\r\n\t\t * RouterClient.addPubSubServer(\"topicABC\", { \"State\": \"start\" });\r\n\t\t *\r\n\t\t *   or\r\n\t\t *\r\n\t\t * RouterClient.addPubSubServer(\\/topicA*\\/, { \"State\": \"start\" });\r\n\t\t *\r\n\t\t */\r\n\t\tthis.addPubSubServer = function (topic, initialState, params) {\r\n\t\t\tconsole.debug(\"addPubSubServer for topic \" + topic);\r\n\t\t\tValidate.args(topic, \"any\", initialState, \"object=\", params, \"object=\");\r\n\t\t\tparams = params || {};\r\n\t\t\tValidate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\r\n\t\t\t\tValidate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\r\n\t\r\n\t\t\tvar status = addPubSubServerCallBack(topic, params.subscribeCallback, params.publishCallback, params.unsubscribeCallback);\r\n\t\t\tif (status) {\r\n\t\t\t\tinitialState = initialState || {}; \r\n\t\t\t\tmapPubSubServerState[topic.toString()] = initialState;\r\n\t\t\t\tsendToRouterService(new AddPubSubServerMessage(topic.toString()));\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"PubSub Server already locally defined for topic \" + topic);\r\n\t\t\t\tnotifyEventHandler({\r\n\t\t\t\t\t\"error\": \"PubSub Server already locally defined for topic\"\r\n\t\t\t\t}, null); // immediately invoke callback passing error\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t * Remove pubsub server from specified topic.\r\n\t\t * \r\n\t\t * @param {string} topic for server being removed (may be RegEx)\r\n\t\t */\r\n\t\tthis.removePubSubServer = function (topic) {\r\n\t\t\tconsole.debug(\"removePubSubServer for topic \" + topic);\r\n\t\t\tValidate.args(topic, \"any\");\r\n\t\t\tvar status = removeServerCallBack(mapPubSubServers, topic);\r\n\t\t\tif (status) {\r\n\t\t\t\tdelete mapPubSubServerState[topic.toString()]; // remove corresponding state\r\n\t\t\t\tdelete mapPubSubServerRegEx[topic.toString()]; // may be a RegEx\r\n\t\t\t\tsendToRouterService(new RemovePubSubServerMessage(topic));\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"removePubSubServer failed -- could not find server for topic \" + topic);\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Subscribe to a PubSub Server.\r\n\t\t * \r\n\t\t * @param {string} topic\r\n\t\t * @param {function} notifyCallback\r\n\t\t * @returns subscribe object used for unsubscribing\r\n\t\t */\r\n\t\tthis.subscribe = function (topic, notifyCallback) {\r\n\t\t\tconsole.debug(\"subscribe for topic \" + topic);\r\n\t\t\tValidate.args(topic, \"string\", notifyCallback, 'function');\r\n\t\t\tvar subscribeID = clientID();\r\n\t\t\taddSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic);\r\n\t\t\tsendToRouterService(new SubscribeMessage(subscribeID, topic));\r\n\t\t\treturn { \"subscribeID\": subscribeID, \"topic\": topic}; \r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t * Publish to a PubSub Server, which will trigger a corresponding Notify to be sent to all subscribers. \r\n\t\t * \r\n\t\t * @param {string} topic\r\n\t\t * @param {object} event\r\n\t\t */\r\n\t\tthis.publish = function (topic, event) {\r\n\t\t\tValidate.args(topic, \"string\", event, 'any');\r\n\t\t\tconsole.debug(\"publish to topic \" + topic + \" event: \" + JSON.stringify(event));\r\n\t\t\tsendToRouterService(new PublishMessage(topic, event));\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Unsubscribe from PubSub server.\r\n\t\t * \r\n\t\t * @param {object} subscribeIDStruct\r\n\t\t */\r\n\t\tthis.unsubscribe = function (subscribeIDStruct) {\r\n\t\t\tconsole.debug(\"unsubscribe to topic \" + subscribeIDStruct.topic + \" for subscriberID \" + subscribeIDStruct.subscribeID);\r\n\t\t\tValidate.args(subscribeIDStruct, \"object\") && Validate.args2(\"subscribeIDStruct.subscribeID\", subscribeIDStruct.subscribeID, \"string\");\r\n\t\t\tvar deletedSubscriber = removeSubscriberCallBack(mapSubscribersID, subscribeIDStruct.subscribeID);\r\n\t\t\tif (deletedSubscriber) {\r\n\t\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeIDStruct.subscribeID, subscribeIDStruct.topic));\r\n\t\t\t} else {\r\n\t\t\t\tconsole.warn(\"unsubscribe failed -- could not find subscribeID for topic \" + subscribeIDStruct.topic);\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * @todo\r\n\t\t * Removes all listeners, servers, and subscribers for this router client -- typically called when client component is shutting down (but RouterService is staying up).\r\n\t\t */\r\n\t\tthis.disconnectAll = function () {\r\n\t\t\tconsole.debug(\"disconnectAll\");\r\n\t\r\n\t\t\tfor (var channel in mapListeners) {\r\n\t\t\t\tconsole.debug(\"removing listener on \" + channel);\r\n\t\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\r\n\t\t\t\tdelete mapListeners[channel];\r\n\t\t\t}\t\r\n\t\r\n\t\t\tfor (var serverChannel in mapServers) {\r\n\t\t\t\tconsole.debug(\"removing server on \" + serverChannel);\r\n\t\t\t\tsendToRouterService(new RemoveServerMessage(serverChannel));\r\n\t\t\t\tdelete mapServers[serverChannel];\r\n\t\t\t}\t\r\n\t\r\n\t\t\tfor (var topic in mapPubSubServers) {\r\n\t\t\t\tconsole.debug(\"removing pubsub server on \" + topic);\r\n\t\t\t\tsendToRouterService(new RemovePubSubServerMessage(topic));\r\n\t\t\t\tdelete mapPubSubServers[topic.toString()]; // could be a RegEx\r\n\t\t\t\tdelete mapPubSubServerState[topic.toString()]; // remove corresponding state\r\n\t\t\t\tdelete mapPubSubServerRegEx[topic.toString()]; // may be a RegEx\r\n\t\t\t}\t\r\n\t\t\t\r\n\t\t\tfor (var subscribeID in mapSubscribersID) {\r\n\t\t\t\tvar stopic = mapSubscribersTopic[subscribeID];\r\n\t\t\t\tconsole.debug(\"removing subscriber on \" + stopic);\r\n\t\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeID, stopic));\r\n\t\t\t\tdelete mapSubscribersID[subscribeID];\r\n\t\t\t\tdelete mapSubscribersTopic[subscribeID];\r\n\t\t\t}\t\r\n\t\t};\r\n\t\r\n\t\tconstructor(thisClientName, transportName); // on creation invoke to initialize\r\n\t};\r\n\t\r\n\tmodule.exports = RouterClientConstructor;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\r\n\t// Copyright 2012-2017 by ChartIQ, Inc\r\n\t// -------------------------------------------------------------------------------------------\r\n\t\r\n\t// This routerTransport file is shared between router clients and the router service.  It supports\r\n\t// the addition of new transports without any change to the router code. Each transport is \r\n\t// point-to-point between a router client and the router service (i.e. hub and spoke).  Each router\r\n\t// client can use a different transport (i.e. the router service connects to them all). \r\n\t\r\n\t\"use strict\";\r\n\tvar Utils = __webpack_require__(1);\r\n\tvar console = new Utils.Console(\"RouterTransport\"); // Finsemble console\r\n\t\r\n\tvar openfinAppConfig; // config used to determine if cross-domain\r\n\tif (window.location.hostname === \"localhost\") { // if localhost then using desktop-local config\r\n\t\tconsole.debug(\"desktop-local config\");\r\n\t\topenfinAppConfig = __webpack_require__(7);\r\n\t} else { // else using desktop-app config\r\n\t\tconsole.debug(\"desktop-app config\");\r\n\t\topenfinAppConfig = __webpack_require__(8);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @introduction\r\n\t * <h2>Router Transport</h2>\r\n\t * **Service-Level Module**.  Manages and contains the point-to-point transports (i.e. Layer 2) supported by Finsemble.\r\n\t * Each transport communicates betweew a Finsemble services or component (on one end) and the Finsemble router (on the other end).\r\n\t *\r\n\t * The OpenFinBus transport is used for cross-domain components (where SharedWorker fails).\r\n\t *\r\n\t * Requirements for adding a new transport:\r\n\t * 1) create new transport object with same interface provided by SharedWorkerTransport and OpenFinTransport in this file.\r\n\t * 2) call RouterTransport.addTransport() to make the transport available (see the bottom of this file)\r\n\t *\r\n\t * Integration into routerService.js is automatic.\r\n\t *\r\n\t * @namespace RouterTransport\r\n\t */\r\n\tvar RouterTransport = {\r\n\t\r\n\t\tactiveTransports: {},\r\n\t\r\n\t\t/**\r\n\t\t * Adds a new type of router transport to pass message between RouterClient and RouterService. \r\n\t\t * \r\n\t\t * @param {string} transportName identifies the new transport\r\n\t\t * @param {object} transportConstructor returns an instance of the new transport\r\n\t\t */\r\n\t\taddTransport: function (transportName, transportConstructor) {\r\n\t\t\tthis.activeTransports[transportName] = transportConstructor;\r\n\t\t\tconsole.info(\"RouterTransport added: \" + transportName);\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Gets array of active transports\r\n\t\t * \r\n\t\t * @returns array transport names/identifier\r\n\t\t */\r\n\t\tgetActiveTransports: function () {\r\n\t\t\tvar transportNames = [];\r\n\t\t\tfor (var transportIdentifier in this.activeTransports) {\r\n\t\t\t\ttransportNames.push(transportIdentifier);\r\n\t\t\t}\r\n\t\t\treturn transportNames;\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Get best client transport based on the run-time context. Will only return cross-domain transport if current context is inter-domain.  \r\n\t\t * \r\n\t\t * @param {any} incomingMessageHandler\r\n\t\t * @param {any} source\r\n\t\t * @param {any} destination\r\n\t\t * @returns the transport object\r\n\t\t */\r\n\t\tgetRecommendedTransport: function (incomingMessageHandler, source, destination) {\r\n\t\t\tvar newTransport; // return variable\r\n\t\r\n\t\t\t// Will tell you if the window is in an iframe or not (for future)\r\n\t\t\tfunction isInIframe () {\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn window.self !== window.top;\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t// returns true if this window's location is in another domain \r\n\t\t\tfunction crossDomain() {\r\n\t\t\t\tvar parser = document.createElement('a');\r\n\t\t\t\tparser.href = openfinAppConfig.startup_app.url;\r\n\t\r\n\t\t\t\tvar isSameHost = (window.location.hostname === parser.hostname);\r\n\t\t\t\tconsole.debug(\"Transport crossDomain host comparison:\" + window.location.hostname + \"==\" + parser.hostname);\r\n\t\r\n\t\t\t\tvar isSameProtocol = (window.location.protocol === parser.protocol);\r\n\t\t\t\tconsole.debug(\"Transport crossDomain protocol comparison:\" + window.location.protocol + \"==\" + parser.protocol);\r\n\t\r\n\t\t\t\tvar wport = (window.location.port === undefined) ? window.location.port : 80;\r\n\t\t\t\tvar pport = (parser.port === undefined) ? parser.port : 80;\r\n\t\t\t\tvar isSamePort = (wport === pport);\r\n\t\t\t\tconsole.debug(\"Transport crossDomain port comparison:\" + wport + \"==\" + pport);\r\n\t\r\n\t\t\t\tvar isCrossDomain = !(isSameHost && isSamePort && isSameProtocol);\r\n\t\t\t\tconsole.debug(\"Transport crossDomain=\" + isCrossDomain + \" (\" + isSameHost + \":\" + isSameProtocol + \":\" + isSamePort + \")\");\r\n\t\t\t\treturn isCrossDomain;\r\n\t\t\t}\r\n\t\r\n\t\t\t// returns the best transport to communicating with router service\t\t\r\n\t\t\tfunction recommendedTransportName() {\r\n\t\t\t\tvar recommendedName = \"SharedWorker\"; // default -- fast but doesn't work cross-domain\r\n\t\t\t\tif (crossDomain()) {\r\n\t\t\t\t\trecommendedName = \"OpenFinBus\"; // required for cross-domain event messaging between windows\r\n\t\t\t\t}\r\n\t\t\t\treturn recommendedName; \r\n\t\t\t}\r\n\t\r\n\t\t\tvar transportName = recommendedTransportName();\r\n\t\t\tvar transportConstructor = this.activeTransports[transportName];\r\n\t\t\tif (transportConstructor) {\r\n\t\t\t\tnewTransport = new transportConstructor(transportName, incomingMessageHandler, source, destination);\r\n\t\t\t}\r\n\t\t\treturn newTransport;\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Get a specific transport by name. The transport must be in list of the active transports (i.e. previously added).\r\n\t\t * \r\n\t\t * @param {any} transportName\r\n\t\t * @param {any} incomingMessageHandler\r\n\t\t * @param {any} source\r\n\t\t * @param {any} destination\r\n\t\t * @returns the transport object\r\n\t\t */\r\n\t\tgetTransport: function (transportName, incomingMessageHandler, source, destination) {\r\n\t\t\tvar transportConstructor = this.activeTransports[transportName];\r\n\t\t\tif (transportConstructor) {\r\n\t\t\t\tvar newTransport = new transportConstructor(transportName, incomingMessageHandler, source, destination);\r\n\t\t\t}\r\n\t\t\treturn newTransport;\r\n\t\t}\r\n\t};\r\n\t\r\n\t//////////////////////////////////////////////////////////////\r\n\t// Below all transports are defined then added to active list\r\n\t//////////////////////////////////////////////////////////////\r\n\t\r\n\tvar RouterTransportImplementation = {}; // a convenience namespace for router-transport implementations\r\n\t\r\n\t/*\r\n\t * Implements the SharedWorker Transport.\r\n\t * \r\n\t * Required Functions (used by transport clients):\r\n\t * \t\tsend(eventMessage) -- transports the event \r\n\t * \t\tidentifier() -- returns transport name/identifier\r\n\t * \r\n\t *  @param {object=} name the name the transport will be reference by\r\n\t *  @param {any} parentMessageHandlerParm callback for incoming event\r\n\t */\r\n\tRouterTransportImplementation.SharedWorkerTransport = function (name, parentMessageHandlerParm, source) {\r\n\t\tvar parentMessageHandler;\r\n\t\tvar routerThread;\r\n\t\tvar transportName;\r\n\t\tvar console = new Utils.Console(\"SharedWorkerTransport.\" + source); // Finsemble console\r\n\t\r\n\t\t// receives incoming shared-worker messages then passes on to parent with correct \"wrapper\"\r\n\t\tfunction sharedWorkerMessageHandler(swMessage) {\r\n\t\t\tvar port = swMessage.data[0];\r\n\t\t\tvar eventMessage = swMessage.data[1];\r\n\t\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"port\": port };\r\n\t\t\tconsole.debug2(\"IncomingTransport: \" + JSON.stringify(incomingTransportInfo) + \" Message: \" + JSON.stringify(eventMessage));\r\n\t\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\r\n\t\t}\r\n\t\r\n\t\t//required function for parent (i.e. routeClient or routeService)\r\n\t\tthis.send = function (transport, eventMessage) {\r\n\t\t\t// handle optional transport parm\r\n\t\t\tif (arguments.length === 1) {\r\n\t\t\t\ttransport = null;\r\n\t\t\t\teventMessage = arguments[0];\r\n\t\t\t} else {\r\n\t\t\t\ttransport = arguments[0];\r\n\t\t\t\teventMessage = arguments[1];\r\n\t\t\t}\r\n\t\t\tconsole.debug2(\"OutgoingTransport: \" + \" Transport: \" + JSON.stringify(transport) + \" Message: \" + JSON.stringify(eventMessage));\r\n\t\t\trouterThread.port.postMessage([transport,eventMessage]);\r\n\t\t};\r\n\t\r\n\t\t//required function for parent (i.e. routeClient or routeService)\r\n\t\tthis.identifier = function () {\r\n\t\t\treturn transportName;\r\n\t\t};\r\n\t\r\n\t\tconsole.debug(\"SharedWorker Initializing: \" + source);\t\r\n\t\ttransportName = name;\r\n\t\tparentMessageHandler = parentMessageHandlerParm;\r\n\t\trouterThread = new SharedWorker(\"/common/routerSharedWorker.js\", \"Finsemble\");\r\n\t\trouterThread.port.onmessage = sharedWorkerMessageHandler;\r\n\t\trouterThread.onerror = function (e) {\r\n\t\t\tconsole.error(\"RouteClient SharedWorker Error\" + JSON.stringify(e));\r\n\t\t};\r\n\t\trouterThread.port.start();\r\n\t\r\n\t\tif (source === \"RouterService\") {  // send first message though shared worker to identify router service\r\n\t\t\trouterThread.port.postMessage({data:\"connect\",source:\"RouterService\"});\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*\r\n\t * Implements the OpenFin Bus Transport.\r\n\t * \r\n\t * Required Functions (used by transport clients):\r\n\t * \t\tsend(event) -- transports the event \r\n\t * \t\tidentifier() -- returns transport name/identifier\r\n\t * \r\n\t *  @param {any} name -- the name the transport will be reference by\r\n\t *  @param {any} parentMessageHandlerParm -- callback for incoming event\r\n\t */\r\n\tRouterTransportImplementation.OpenFinTransport = function (name, parentMessageHandlerParm, source, destination) {\r\n\t\tvar parentMessageHandler;\r\n\t\tvar transportName;\r\n\t\tvar console = new Utils.Console(\"OpenFinTransport.\" + source); // Finsemble console\r\n\t\r\n\t\t// receives incoming OpenFin bus messages then passes on to parent with correct \"wrapper\"\r\n\t\tfunction openFinMessageHandler(eventMessage, senderUuid, name) {\r\n\t\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"senderUuid\": senderUuid, \"name\": eventMessage.header.origin };\r\n\t\t\tconsole.debug2(\"IncomingTransport: \" + JSON.stringify(incomingTransportInfo) + \" Message: \" + JSON.stringify(eventMessage));\r\n\t\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\r\n\t\t}\r\n\t\r\n\t\tfunction subscribeFailure(reason) {\r\n\t\t\tconsole.error(\"OpenFinBus Subscribe Failure: \" + reason);\r\n\t\t}\r\n\t\r\n\t\t//required function for the parent (i.e. routeClient or routeService)\r\n\t\tthis.send = function (transport, eventMessage) {\r\n\t\t\tvar destTopic;\r\n\t\r\n\t\t\t// handle optional transport parm\r\n\t\t\tif (arguments.length === 1) {\r\n\t\t\t\tdestTopic = destination;\r\n\t\t\t\teventMessage = arguments[0];\r\n\t\t\t} else {\r\n\t\t\t\tdestTopic = transport.name;\t\t\r\n\t\t\t\teventMessage = arguments[1];\r\n\t\t\t}\r\n\t\r\n\t\t\tconsole.debug2(\"OutgoingTransport: \" + destTopic + \" Message: \" + JSON.stringify(eventMessage));\r\n\t\t\tfin.desktop.InterApplicationBus.send(\"ChartIQ\", destTopic, eventMessage);\r\n\t\t};\r\n\t\r\n\t\t//required function for the parent (i.e. routeClient or routeService)\r\n\t\tthis.identifier = function () {\r\n\t\t\treturn transportName;\r\n\t\t};\r\n\t\r\n\t\ttransportName = name;\r\n\t\tparentMessageHandler = parentMessageHandlerParm;\r\n\t\tconsole.debug(\"OpenFinBus Initializing: \" + source);\r\n\t\tfin.desktop.InterApplicationBus.subscribe(\"ChartIQ\", source, openFinMessageHandler, null, subscribeFailure);\r\n\t};\r\n\t\r\n\t// add the transports to the available/active list\r\n\tRouterTransport.addTransport(\"SharedWorker\", RouterTransportImplementation.SharedWorkerTransport);\r\n\tRouterTransport.addTransport(\"OpenFinBus\", RouterTransportImplementation.OpenFinTransport);\r\n\t\r\n\tmodule.exports = RouterTransport;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"FSBL\": {\n\t\t\t\"main_component\": {\n\t\t\t\t\"url\": \"http://localhost/components/toolbar/toolbar.html\",\n\t\t\t\t\"name\": \"Launcher\"\n\t\t\t}\n\t\t},\n\t\t\"devtools_port\": 9090,\n\t\t\"startup_app\": {\n\t\t\t\"name\": \"ChartIQ Local\",\n\t\t\t\"url\": \"http://localhost/components/serviceManager/serviceManager.html\",\n\t\t\t\"uuid\": \"ChartIQ\",\n\t\t\t\"applicationIcon\": \"http://localhost/components/assets/img/CIQ_Taskbar_Icon.png\",\n\t\t\t\"defaultTop\": 0,\n\t\t\t\"defaultLeft\": 0,\n\t\t\t\"showTaskbarIcon\": true,\n\t\t\t\"autoShow\": true,\n\t\t\t\"frame\": false,\n\t\t\t\"resizable\": false,\n\t\t\t\"maximizable\": false,\n\t\t\t\"delay_connection\": true,\n\t\t\t\"contextMenu\": true,\n\t\t\t\"cornerRounding\": {\n\t\t\t\t\"width\": 4,\n\t\t\t\t\"height\": 4\n\t\t\t},\n\t\t\t\"alwaysOnTop\": false,\n\t\t\t\"frameConnect\": \"main-window\",\n\t\t\t\"customData\": {\n\t\t\t\t\"finsemble\": {\n\t\t\t\t\t\"services\": {\n\t\t\t\t\t\t\"beforeLaunch\": [],\n\t\t\t\t\t\t\"workers\": []\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"runtime\": {\n\t\t\t\"arguments\": \"--noerrdialogs  --v=1 --force-device-scale-factor=1\",\n\t\t\t\"version\": \"stable\"\n\t\t},\n\t\t\"shortcut\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"description\": \"ChartIQ Local\",\n\t\t\t\"icon\": \"http://localhost/components/assets/img/CIQ_Taskbar_Icon.ico\",\n\t\t\t\"name\": \"ChartIQ - LOCAL\",\n\t\t\t\"target\": [\n\t\t\t\t\"desktop\",\n\t\t\t\t\"start-menu\"\n\t\t\t],\n\t\t\t\"force\": false,\n\t\t\t\"startMenuRootFolder\": \"ChartIQ Local\"\n\t\t},\n\t\t\"dialogSettings\": {\n\t\t\t\"logo\": \"http://localhost/components/assets/img/ciq-banner-100x25.png\",\n\t\t\t\"bgColor\": 4280798349,\n\t\t\t\"textColor\": 4293521652,\n\t\t\t\"progressBarBgColor\": 4294967295,\n\t\t\t\"progressBarFillColor\": 4282684881,\n\t\t\t\"progressBarBorderColor\": 4293521652\n\t\t},\n\t\t\"supportInformation\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"product\": \"ChartIQ Desktop\",\n\t\t\t\"email\": \"support@chartiq.com\"\n\t\t},\n\t\t\"fileName\": \"ChartIQ-local-installer\"\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"FSBL\": {\n\t\t\t\"main_component\": {\n\t\t\t\t\"url\": \"http://finsemble.chartiq.com/components/toolbar/toolbar.html\",\n\t\t\t\t\"name\": \"Launcher\"\n\t\t\t}\n\t\t},\n\t\t\"devtools_port\": 9090,\n\t\t\"startup_app\": {\n\t\t\t\"name\": \"ChartIQ\",\n\t\t\t\"url\": \"http://finsemble.chartiq.com/components/serviceManager/serviceManager.html\",\n\t\t\t\"uuid\": \"ChartIQ\",\n\t\t\t\"applicationIcon\": \"http://finsemble.chartiq.com/components/assets/img/CIQ_Taskbar_Icon.png\",\n\t\t\t\"defaultTop\": 0,\n\t\t\t\"defaultLeft\": 0,\n\t\t\t\"showTaskbarIcon\": true,\n\t\t\t\"autoShow\": false,\n\t\t\t\"frame\": false,\n\t\t\t\"resizable\": false,\n\t\t\t\"maximizable\": false,\n\t\t\t\"delay_connection\": true,\n\t\t\t\"cornerRounding\": {\n\t\t\t\t\"width\": 4,\n\t\t\t\t\"height\": 4\n\t\t\t},\n\t\t\t\"alwaysOnTop\": true,\n\t\t\t\"frameConnect\": \"main-window\"\n\t\t},\n\t\t\"runtime\": {\n\t\t\t\"arguments\": \"--v=1 --force-device-scale-factor=1\",\n\t\t\t\"version\": \"stable\"\n\t\t},\n\t\t\"shortcut\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"description\": \"ChartIQ\",\n\t\t\t\"icon\": \"http://finsemble.chartiq.com/components/assets/img/CIQ_Taskbar_Icon.ico\",\n\t\t\t\"name\": \"ChartIQ\",\n\t\t\t\"target\": [\n\t\t\t\t\"desktop\",\n\t\t\t\t\"start-menu\"\n\t\t\t],\n\t\t\t\"force\": false,\n\t\t\t\"startMenuRootFolder\": \"ChartIQ\"\n\t\t},\n\t\t\"dialogSettings\": {\n\t\t\t\"logo\": \"http://finsemble.chartiq.com/components/assets/img/ciq-banner-100x25.png\",\n\t\t\t\"bgColor\": 4280798349,\n\t\t\t\"textColor\": 4293521652,\n\t\t\t\"progressBarBgColor\": 4294967295,\n\t\t\t\"progressBarFillColor\": 4282684881,\n\t\t\t\"progressBarBorderColor\": 4293521652\n\t\t},\n\t\t\"supportInformation\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"product\": \"ChartIQ Desktop\",\n\t\t\t\"email\": \"support@chartiq.com\"\n\t\t},\n\t\t\"fileName\": \"ChartIQ-installer\"\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\r\n\t// Copyright 2012-2017 by ChartIQ, Inc\r\n\t// -------------------------------------------------------------------------------------------\r\n\t\r\n\t// This file contains the Fensemble router service, which routes event messages between \r\n\t// other services and components.  All event messages flow though here (never peer to peer).\r\n\t\r\n\tvar FSBLUtils = __webpack_require__(1);\r\n\tvar serviceObj = function (params) {\r\n\t\tif (params) {\r\n\t\t\tthis.name = params[0];\r\n\t\t}\r\n\t\tvar self = this;\r\n\t\tthis.name = name;\r\n\t\tthis.servicesNeeded = [\"routerService\"];// All the services that are required before the connection to the service manager is complete.\r\n\t\tthis.onlineServices = [];\r\n\t\tthis.__parent = null;//Should be service manager\r\n\t\tthis.clients = [];\r\n\t\tthis.beforeEach = [];//A list of fucntions that are called before every message\r\n\t\tthis.afterEach = [];//A list of fucntions that are called after every message\r\n\t\tthis.status = \"offline\";//The services status\r\n\t\tthis.onConnectionComplete = null;\r\n\t\t//Turn the the service online. This only happens when all servicesNeeded are online.\r\n\t\t//Also, the online is only sent to the parent once all of the 'onConnectionComplete' functions are complete\r\n\t\tthis.setOnline = function () {\r\n\t\t\tif (self.servicesNeeded.length === 0 && self.status !== \"online\") {\r\n\t\t\t\tif (self.onConnectionComplete) {\r\n\t\t\t\t\treturn self.onConnectionComplete(function () {\r\n\t\t\t\t\t\tself.status = \"online\";\r\n\t\t\t\t\t\tself.sendOnlineToParent();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tself.status = \"online\";\r\n\t\t\t\tself.sendOnlineToParent();\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.setOnConnectionComplete = function (func) {\r\n\t\t\tself.onConnectionComplete = func;\r\n\t\t};\r\n\t\t//Add a function to be processed before every message\r\n\t\tthis.addBefore = function (func) {\r\n\t\t\tif (typeof (func) === \"function\") {\r\n\t\t\t\tthis.beforeEach.push(func);\r\n\t\t\t}\r\n\t\t};\r\n\t\t//Add a function to be processed after every message\r\n\t\tthis.addAfter = function (func) {\r\n\t\t\tif (typeof (func) === \"function\") {\r\n\t\t\t\tthis.afterEach.push(func);\r\n\t\t\t}\r\n\t\t};\r\n\t\t//Add a service to services needed list. This service will wait for all services in this list to be complete.\r\n\t\tthis.addNeededServices = function (services) {\r\n\t\t\tif (!Array.isArray(services)) {\r\n\t\t\t\tservices = [services];\r\n\t\t\t}\r\n\t\t\tfor (var i = 0; i < services.length; i++) {\r\n\t\t\t\tif (this.servicesNeeded.indexOf(services[i]) === -1) {\r\n\t\t\t\t\tthis.servicesNeeded.push(services[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t//Clear the services needed list\r\n\t\tthis.clearServicesNeeded = function () {\r\n\t\t\tthis.servicesNeeded = [];\r\n\t\t};\r\n\t\t//Check to see if services are online and remove them from the services needed if they are \r\n\t\tthis.checkServicesNeeded = function () {\r\n\t\t\tfor (var i = 0; i < self.servicesNeeded.length; i++) {\r\n\t\t\t\tif (self.onlineServices.indexOf(self.servicesNeeded[i]) > -1) {\r\n\t\t\t\t\tself.servicesNeeded.splice(i, 1);\r\n\t\t\t\t\ti--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tself.setOnline();\r\n\t\t};\r\n\t\t//Base listeners\r\n\t\tthis.listeners = {\r\n\t\t\tserviceOnline: [function (msg) {\r\n\t\t\t\tself.onlineServices.push(msg.payload);\r\n\t\t\t\tif (self.servicesNeeded.length > 0) { self.checkServicesNeeded(); };\r\n\t\t\t}],\r\n\t\t\tserviceList: [function (msg) {\r\n\t\t\t\tself.onlineServices = msg.payload;\r\n\t\t\t\tif (self.servicesNeeded.length > 0) { self.checkServicesNeeded(); };\r\n\t\t\t}],\r\n\t\t\twindowConnect: [function (msg) {\r\n\t\t\t\tself.sendHandShake();\r\n\t\t\t}],\r\n\t\t\tonConnectionComplete: []\r\n\t\t};\r\n\t};\r\n\t//Processes all messages\r\n\tserviceObj.prototype.receiveMessage = function (msg) {\r\n\t\tfor (var i = 0; i < this.beforeEach.length; i++) {\r\n\t\t\tthis.beforeEach[i](msg);\r\n\t\t}\r\n\t\tvar eventName = msg.name;\r\n\t\tif (eventName && this.listeners[eventName].length > 0) {\r\n\t\t\tfor (var i = 0; i < this.listeners[eventName].length; i++) {\r\n\t\t\t\tif (typeof this.listeners[eventName][i] === \"function\") {\r\n\t\t\t\t\tthis.listeners[eventName][i](msg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (var i = 0; i < this.afterEach.length; i++) {\r\n\t\t\tthis.afterEach[i](msg);\r\n\t\t}\r\n\t};\r\n\t//Listen for a new message type\r\n\tserviceObj.prototype.addListener = function (eventName, cb) {\r\n\t\tif (!this.listeners[eventName])\r\n\t\t{ this.listeners[eventName] = []; }\r\n\t\tthis.listeners[eventName].push(cb);\r\n\t\r\n\t};\r\n\t//remove a listener\r\n\tserviceObj.prototype.removeListener = function (eventName, func) {\r\n\t\tif (this.listeners[eventName] && this.listeners[eventName].length > 0) {\r\n\t\t\tfor (var i = 0; i < this.listeners[eventName].length; i++) {\r\n\t\t\t\tif (this.listeners[eventName][i] === func) {\r\n\t\t\t\t\tthis.listeners[eventName].splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t//log a message to the parent.\r\n\tserviceObj.prototype.log = function (message) {\r\n\t\tvar msg = new FSBLUtils.msgWrapper('debug', JSON.stringify(message));\r\n\t\tthis.sendToParent(msg);\r\n\t};\r\n\t//Broadcast a message to all connected clients.\r\n\tserviceObj.prototype.broadcast = function (message) {\r\n\t\r\n\t\tif (this.route) {\r\n\t\r\n\t\t} else {\r\n\t\t\tfor (var i = 0; i < this.clients.length; i++) {\r\n\t\t\t\tport = this.clients[i];\r\n\t\t\t\tport.postMessage(message);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t//Send a message to the parent\r\n\tserviceObj.prototype.sendToParent = function (message) {\r\n\t\tmessage.location = this.name;\r\n\t\tif (typeof window !== 'undefined') {\r\n\t\t\tif (!this.__parent) { this.__parent = window.opener; }\r\n\t\t\treturn this.__parent.postMessage(message, \"*\");\r\n\t\t}\r\n\t\tthis.__parent.postMessage(message);\r\n\t};\r\n\t//Set this service online\r\n\tserviceObj.prototype.sendOnlineToParent = function () {\r\n\t\tvar msg = new FSBLUtils.msgWrapper(\"online\", {\r\n\t\t\tstatus: true\r\n\t\t});\r\n\t\tthis.sendToParent(msg);\r\n\t};\r\n\t//Tell the parent that this service received the connection\r\n\tserviceObj.prototype.sendHandShake = function () {\r\n\t\tvar msg = new FSBLUtils.msgWrapper(\"handshake\", {\r\n\t\t\tstatus: true\r\n\t\t});\r\n\t\tvar self = this;\r\n\t\tthis.sendToParent(msg);\r\n\t\tif (this.servicesNeeded.length > 0) {\r\n\t\t\tthis.getActiveServiceList();\r\n\t\t} else {\r\n\t\t\tthis.setOnline();\r\n\t\t}\r\n\t};\r\n\t//Get a list of all active services\r\n\tserviceObj.prototype.getActiveServiceList = function () {\r\n\t\tvar msg = new FSBLUtils.msgWrapper(\"getActiveServices\");\r\n\t\tthis.sendToParent(msg);\r\n\t};\r\n\t//Start this service.\r\n\tserviceObj.prototype.start = function () {\r\n\t\tvar service = this;\r\n\t\tif (typeof window !== 'undefined') {\r\n\t\t\twindow.addEventListener(\"message\", function (msg) {\r\n\t\t\t\tservice.receiveMessage(msg.data);\r\n\t\t\t});\r\n\t\r\n\t\t\tthis.__parent = window.opener;\r\n\t\t} else {\r\n\t\t\tself.onerror = function (e) {\r\n\t\t\t\tvar msg = new FSBLUtils.msgWrapper(\"debug\", e);\r\n\t\t\t\tservice.sendToParent(msg);\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tself.onconnect = function (e) {\r\n\t\t\t\tvar port = e.ports[0];\r\n\t\t\t\tservice.clients.push(port);\r\n\t\r\n\t\t\t\tport.onmessage = function (msg) {\r\n\t\t\t\t\tservice.receiveMessage(msg.data);\r\n\t\t\t\t};\r\n\t\t\t\tif (service.clients.length === 1) {\r\n\t\t\t\t\tservice.__parent = port;\r\n\t\t\t\t\tservice.sendHandShake();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\t\r\n\tmodule.exports = serviceObj;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\tvar Utils = __webpack_require__(1);\r\n\tvar console = new Utils.Console(\"StorageClient\"); // Finsemble console\r\n\tvar Validate = __webpack_require__(3); // Finsemble args validator\r\n\t\r\n\t/**\r\n\t * \r\n\t * Public API for The Storage Service\r\n\t * StorageClient.[storageType].action(name,[data],cb);\r\n\t */\r\n\tvar RouterClient = __webpack_require__(4);\r\n\tvar BaseClient = __webpack_require__(11);\r\n\t/**\r\n\t *  @todo add clear method\r\n\t *  @example\r\n\t *\r\n\t * // Save a key value pair to local storage\r\n\t * FSBL.StorageClient.save(\"localStorage\",\"testKey\",\"testValue\")\r\n\t * // Save a key value pair to the default storage\r\n\t * FSBL.StorageClient.save(,\"testKey\",\"testValue\")\r\n\t * // Get an value from local storage\r\n\t * FSBL.StorageClient.get(\"localStorage\",\"testKey\",)\r\n\t * // Get an value from the default storage\r\n\t * FSBL.StorageClient.get(testKey\")\r\n\t * //Delete a value from local storage\r\n\t * FSBL.StorageClient.delete(\"localStorage\",\"testKey\")\r\n\t * //Delete a value from the default storage\r\n\t * FSBL.StorageClient.delete(\"testKey\")\r\n\t * \r\n\t * \r\n\t * @constructor\r\n\t */\r\n\tvar StorageClient = function (params) {\r\n\t\tValidate.args(params, \"object=\") && params && Validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\t\tvar self = this;\r\n\t\tBaseClient.call(this, params);\r\n\t\tthis.RouterClient = RouterClient;\r\n\t\tvar defaultStorage = null;\r\n\t\t//should probably come from some config;\r\n\t\tvar storageTypes = [\"localStorage\"];\r\n\t\tthis.startup =function(){\r\n\t\t\r\n\t\t};\r\n\t\tfunction loadStorageTypes() {\r\n\t\t\tfunction loadType(type) {\r\n\t\t\t\tif (!self[type]) { self[type] = {}; }\r\n\t\t\t\tself[type][\"save\"] = function (name, data, cb) { self.save(type, name, data, cb); };\r\n\t\t\t\tself[type][\"get\"] = function (name, cb) { self.get(type, name, cb); };\r\n\t\t\t\tself[type][\"delete\"] = function (name, cb) { self.delete(type, name, cb); };\r\n\t\t\t}\r\n\t\t\tfor (var i = 0; i < storageTypes.length; i++) {\r\n\t\t\t\tloadType(storageTypes[i]);\r\n\t\t\t}\r\n\t\t\tdefaultStorage = \"localStorage\";\r\n\t\t}\r\n\t\r\n\t\t/**\r\n\t\t * Save a key value pair into storage.\r\n\t\t * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t\t * @param {string} name - The key to be stored under\r\n\t\t * @param {any} data -  the value to be stored\r\n\t\t * @param {function=} [cb] -  callback to be called on success\r\n\t\t * \r\n\t\t * @example\r\n\t\t * StorageClient.save(\"localStorage\",\"testKey\",\"testValue\")\r\n\t\t */\r\n\t\tthis.save = function (storageType, name, data, cb) {\r\n\t\t\t//use the first storage if no type is given\r\n\t\t\tif (arguments.length < 4 && typeof data === \"function\") {\r\n\t\t\t\tcb = arguments[2];\r\n\t\t\t\tdata = arguments[1];\r\n\t\t\t\tname = arguments[0];\r\n\t\t\t\tstorageType = defaultStorage;\r\n\t\t\t}\r\n\t\t\tValidate.args(storageType, \"any\", name, \"string\", data, \"any\", cb, \"function=\");\r\n\t\t\tself.RouterClient.query('Storage.save', { storageType: storageType, name: name, payload: data }, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Get a value from storage.\r\n\t\t * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t\t * @param {string} name - The key to pull from storage\r\n\t\t * @param {function} [cb] -  callback to be called on success\r\n\t\t * \r\n\t\t * @todo use default\r\n\t\t * @example\r\n\t\t * StorageClient.get(\"localStorage\",\"testKey\")\r\n\t\t */\r\n\t\tthis.get = function (storageType, name, cb) {\r\n\t\t\tif (arguments.length < 3 && typeof name === \"function\") {\r\n\t\t\t\tcb = arguments[1];\r\n\t\t\t\tname = arguments[0];\r\n\t\t\t\tstorageType = defaultStorage;\r\n\t\t\t} \r\n\t\t\tValidate.args(storageType, \"string\", name, \"string\", cb, \"function=\");\r\n\t\t\tself.RouterClient.query('Storage.get', { storageType: storageType, name: name }, function (err, response) {\r\n\t\t\t\tconsole.log('clienterr', err);\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\tthis.getMultiple = function(storageType,query,cb){\r\n\t\t\tif (arguments.length < 3 && typeof query === \"function\") {\r\n\t\t\t\tcb = arguments[1];\r\n\t\t\t\tquery = arguments[0];\r\n\t\t\t\tstorageType = defaultStorage;\r\n\t\t\t} \r\n\t\t\tself.RouterClient.query('Storage.getMultiple', {storageType:storageType,query:query}, function (err, response) {\r\n\t\t\t\tconsole.log('clienterr', err,response);\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Delete a value from storage.\r\n\t\t * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t\t * @param {string} name - The key to delete from storage\r\n\t\t * @param {function} [cb] -  callback to be called on success\r\n\t\t * @todo use default\r\n\t\t * @example\r\n\t\t * StorageClient.get(\"localStorage\",\"testKey\")\r\n\t\t */\r\n\t\tthis.delete = function (storageType, name, cb) {\r\n\t\t\tif (arguments.length < 3 && typeof name === \"function\") {\r\n\t\t\t\tcb = arguments[1];\r\n\t\t\t\tname = arguments[0];\r\n\t\t\t\tstorageType = defaultStorage.keys[0];\r\n\t\t\t} \r\n\t\t\tValidate.args(storageType, \"any\", name, \"string\", cb, \"function=\");\r\n\t\t\tself.RouterClient.query('Storage.delete', { storageType: storageType, name: name }, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t//Load the storage types\r\n\t\tloadStorageTypes();\r\n\t};\r\n\t\r\n\t\r\n\tvar storageClient = new StorageClient({\r\n\t\tonReady: function (cb) {\r\n\t\t\tstorageClient.startup();\r\n\t\t\tconsole.log(\"storage online\");\r\n\t\t\tcb();\r\n\t\t},\r\n\t\tname:\"storageClient\"\r\n\t});\r\n\tstorageClient.requiredServices = [];\r\n\t//storageClient.initialize();\r\n\tmodule.exports = storageClient;\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\tvar Utils = __webpack_require__(1);\r\n\tvar console = new Utils.Console(\"BaseClient\"); // Finsemble console\r\n\tvar Validate = __webpack_require__(3); // Finsemble args validator\r\n\t\r\n\tvar Client = function (params) {\r\n\t\tValidate.args(params, \"object=\");\r\n\t\tvar self = this;\r\n\t\tvar status = \"offline\";\r\n\t\tvar onReady;\r\n\t\tthis.name ;\r\n\t\tif (params) {\r\n\t\t\tonReady = params.onReady;\r\n\t\t\tthis.name = params.name;\r\n\t\t}\r\n\t\tthis.finWindow = fin.desktop.Window.getCurrent();\r\n\t\tthis.clientName = this.finWindow.name;//The current window\r\n\t\r\n\t\tthis.routerClient = __webpack_require__(4);\r\n\t\tthis.requiredServices = [];\r\n\t\tthis.onlineServices = [];\r\n\t\r\n\t\tthis.addServices = function (services) {\r\n\t\t\tValidate.args(services, \"any\");\r\n\t\r\n\t\t\tif (!services) { return; }\r\n\t\t\tif (!Array.isArray(services)) {\r\n\t\t\t\tservices = [services];\r\n\t\t\t}\r\n\t\t\tfor (var i = 0; i < services.length; i++) {\r\n\t\t\t\tif (this.onlineServices.indexOf(services[i]) === -1) {\r\n\t\t\t\t\tthis.onlineServices.push(services[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.checkRequiredServices();\r\n\t\t};\r\n\t\tthis.checkRequiredServices = function () {\r\n\t\t\tfor (var i = 0; i < this.requiredServices.length; i++) {\r\n\t\r\n\t\t\t\tif (this.onlineServices.indexOf(this.requiredServices[i]) > -1) {\r\n\t\t\t\t\tthis.requiredServices.splice(i, 1);\r\n\t\t\t\t\ti--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.checkOnline();\r\n\t\t};\r\n\t\tthis.checkOnline = function () {\r\n\t\t\twindow.console.log(\"services\",this.name,this.onlineServices);\r\n\t\t\tvar self = this;\r\n\t\t\tif (status === \"online\") { return; }\r\n\t\t\tif (this.requiredServices.length === 0) {\r\n\t\t\t\t\r\n\t\t\t\tif (onReady) {\r\n\t\t\t\t\treturn onReady(function () {\r\n\t\t\t\t\t\tstatus = \"online\";\r\n\t\t\t\t\t\tself.routerClient.transmit(self.clientName + \"FSBLClient\",self.name);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.initialize = function () {\r\n\t\t\twindow.console.log(\"client started\", this.name);\r\n\t\r\n\t\t\tsetup();\r\n\t\t\tthis.checkRequiredServices();\r\n\t\t};\r\n\t\tfunction setup() {\r\n\t\t\tself.routerClient.query(\"ServiceManager.getServices\", {}, function (err, event) {\r\n\t\t\t\tself.addServices(event.data);\r\n\t\t\t});\r\n\t\t\tself.routerClient.addListener(\"ServiceManager.serviceOnline\", function (err, event) {\r\n\t\t\t\tself.addServices(event.data);\r\n\t\t\t});\r\n\t\t};\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\tmodule.exports = Client;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RouterClient = __webpack_require__(4);\r\n\tvar BaseClient = __webpack_require__(11);\r\n\tvar util = __webpack_require__(1);\r\n\tvar console = new util.Console(\"BaseClient\"); // Finsemble console\r\n\tvar Validate = __webpack_require__(3); // Finsemble args validator\r\n\t\r\n\t/**\r\n\t * Finsemble windowDescriptor. This is a superset of the Openfin Window object.\r\n\t * @typedef {Object} windowDescriptor\r\n\t * @property {string} url url to load.\r\n\t * @property {number} defaultTop Top pixel of the window. The top left of the screen is 0.\r\n\t * @property {number} defaultLeft Left edge of the window.\r\n\t * @property {number} defaultWidth Window width.\r\n\t * @property {number} defaultHeight Window height\r\n\t * @property {boolean} [showTaskbarIcon=true] Whether to show the icon in the taskbar.\r\n\t * @property {number} [minWidth=0] Minimum width that the window can be resized to.\r\n\t * @property {number} [minHeight=0] Minimum height that the window can be resized to.\r\n\t * @property {boolean} [autoShow=true] Whether the window should render in the background. If this option is set to false, you must tell the window to show itself at some point. You can use {@link WindowClient#show}.\r\n\t * @property {boolean} [frame=false] Whether the window should be rendered with a sytem frame. \r\n\t * @property {boolean} [resizable=true] Whether the window can be resized.\r\n\t * @property {boolean} [maximizable=true] Whether the window can be maximized.\r\n\t * @property {boolean} [alwaysOnTop=false] Whether the window should always sit on top of other finsemble windows.\r\n\t * @property {boolean} [fixedPosition=false] Whether the window should remain where it was spawned.\r\n\t * @property {Object} [resizeRegion] \r\n\t * @property {number} [resizeRegion.size=10]\r\n\t * @property {number} [resizeRegion.bottomCorner= 10]\r\n\t */\r\n\t\r\n\t/**\r\n\t * \"Private\" properties of the windowDescriptor\r\n\t * @private @property @todo { boolean } [hoverFocus = false]\r\n\t * @private @property {boolean} [saveWindowState=false] Openfin window state saving. Don't want to\r\n\t * have them saving the window state since we are.Turning this to true is untested.Do not change.\r\n\t */\r\n\t\r\n\t/**\r\n\t * \r\n\t * The launcher client handles spawning windows for the application.\r\n\t * @constructor\r\n\t */\r\n\tfunction LauncherClient(params) {\r\n\t\tValidate.args(params, \"object=\") && params && Validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\t\r\n\t\t/** @alias LauncherClient# */\r\n\t\tvar self = this;\r\n\t\tBaseClient.call(this, params);\r\n\t\r\n\t\t/**\r\n\t\t * Get a list of available components. This is useful if you need to list all of your components (e.g., in a toolbar).\r\n\t\t * @param {Function} cb Callback to be invoked after function is completed.\r\n\t\t * @example <caption>Something like this could be done to retrieve the list of components inside of something like a Toolbar or a launcher.</caption>\r\n\t\t * var self=this; \r\n\t\t * FSBL.LauncherClient.getComponentList(function(err, data){\r\n\t\t *\tself.setState({\r\n\t\t\tcomponentList: data\r\n\t\t });\r\n\t\t * });\r\n\t\t */\r\n\t\tthis.getComponentList = function (cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\r\n\t\t\tRouterClient.query('Launcher.componentList', {}, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response.data);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/**\r\n\t\t * Get the defaults for an individual component.\r\n\t\t * @param {String} componentType The type of the component you are looking for\r\n\t\t * @param {Function} cb Callback to be invoked after function is completed.\r\n\t\t * @example\r\n\t\t * FSBL.launcherClient.getComponentInfo('Advanced Chart', function(err, data){\r\n\t\t *\t//do something with the default values for Advanced chart.\r\n\t\t * });\r\n\t\t */\r\n\t\tthis.getComponentInfo = function (componentType, cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\t\tconsole.log(\"getComponentInfo \" + componentType);\r\n\t\t\tRouterClient.query('Launcher.componentList', {}, function (err, response) {\r\n\t\t\t\twindow.console.log(\"got the info\", err, response, cb);\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response.data[componentType]);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Asks the Launcher service to spawn a window. The examples below show the basic functionality that the launcher offers. Please see the [Window Spawning]{@tutorial spawningWindows} tutorial for advanced functionality.\r\n\t\t * @param {String} component - Type of the component to launch\r\n\t\t * @param {Object} params Properties to merge with the default windowDescriptor.\r\n\t\t * @param {Function=} cb Callback to be invoked after function is completed.'\r\n\t\t *\r\n\t\t * @example\r\n\t\t * //Spawns an advanced chart with the default positioning.\r\n\t\t * FSBL.LauncherClient.spawn(\"Advanced Chart\");\r\n\t\t * //Spawns an advanced chart in the center of the monitor from where the spawn call originated. If A component on monitor 3 invokes Spawn and passes in a <code>defaultLeft</code> of 'center', it will spawn on monitor 3.\r\n\t\t * FSBL.LauncherClient.spawn(\"Advanced Chart\", {\r\n\t\t * \tdefaultLeft: 'center',\r\n\t\t * \tdefaultTop: 'center'\r\n\t\t * });\r\n\t\t */\r\n\t\tthis.spawn = function (component, params, cb) {\r\n\t\t\tValidate.args(component, \"string\", params, \"object\", cb, \"function=\");\r\n\t\t\tparams.component = component;\r\n\t\t\tif (!params.customData) {\r\n\t\t\t\tparams.customData = {};\r\n\t\t\t}\r\n\t\t\tif (!params.customData.monitorDimensions) {\r\n\t\r\n\t\t\t\treturn util.retrieveMonitorDimensions(function(err,dims){\r\n\t\t\t\t\twindow.console.log(\"dims\",dims);\r\n\t\t\t\t\tparams.customData.monitorDimensions = dims.monitorDimensions;\r\n\t\t\t\t\twindow.console.log(\"params\",params);\r\n\t\t\t\t\tcallSpawn(params,cb);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tcallSpawn(params,cb);\r\n\t\t\t\r\n\t\t};\r\n\t\tfunction callSpawn(params, cb) {\r\n\t\t\tRouterClient.query('Launcher.spawn', params, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\tcb(err, response);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t/**\r\n\t\t* Spawns a new openfin window.\r\n\t\t* @param {string} windowName\tThe name of the window you are looking for\r\n\t\t* @param {function=} cb Callback\r\n\t\t*/\r\n\t\tthis.getWindow = function (windowName, cb) {\r\n\t\t\tValidate.args(windowName, \"string\", cb, \"function=\");\r\n\t\t\tRouterClient.query('Launcher.getWindow', windowName, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/**\r\n\t\t* Spawns a new openfin window.\r\n\t\t* @param {string} windowName\tThe name of the window you are looking for\r\n\t\t* @param {function} cb Callback\r\n\t\t*/\r\n\t\tthis.isWindowOpen = function (windowName, cb) {\r\n\t\t\tValidate.args(windowName, \"string\", cb, \"function=\");\r\n\t\t\tRouterClient.query('Launcher.isWindowOpen', windowName, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t\r\n\t\tthis.getActiveDescriptors = function (cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\t\tRouterClient.query('Launcher.getActiveDescriptors', {}, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/**\r\n\t\t* Spawns a new openfin window.\r\n\t\t* @param {object} params\tThe name of the window you are looking for\r\n\t\t* @param {object} params.monitorDimensions\r\n\t\t* @param {number} params.width\r\n\t\t* @param {number} params.height\r\n\t\t* @param {object} [params.window]\r\n\t\t*/\r\n\t\tthis.moveWindowCenter = function (params) {\r\n\t\t\tValidate.args(params, \"object\") && Validate.args2(\"params.monitorDimensions\", params.monitorDimensions, \"object\", \"params.width\", params.width, \"number\", \"params.height\", params.height, \"number\", \"params.window\", params.window, \"object\");\r\n\t\t\tif (!params.monitorDimensions) { return; }\r\n\t\t\tvar centerTop = (params.monitorDimensions.height - params.height) / 2;\r\n\t\t\tvar centerLeft = (params.monitorDimensions.width - params.width) / 2;\r\n\t\t\twindow.console.log(params,centerTop,centerLeft+ params.monitorDimensions.left);\r\n\t\t\tif (!params.window) {\r\n\t\t\t\treturn fin.desktop.Window.getCurrent().moveTo(centerLeft + params.monitorDimensions.left, centerTop);\r\n\t\t\t}\r\n\t\t\tconsole.log(\"move this window\");\r\n\t\t\treturn params.window.moveTo(centerLeft+ params.monitorDimensions.left, centerTop,function(){\r\n\t\t\t\tparams.window.bringToFront();\r\n\t\t\t});\r\n\t\t};\r\n\t\treturn this;\r\n\t};\r\n\t\r\n\t\r\n\tvar launcherClient = new LauncherClient({\r\n\t\tonReady: function (cb) {\r\n\t\t\tcb();\r\n\t\t},\r\n\t\tname: \"launchClient\"\r\n\t});\r\n\tlauncherClient.requiredServices = [];\r\n\t//launcherClient.initialize();\r\n\t\r\n\tmodule.exports = launcherClient;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Utils = __webpack_require__(1);\r\n\tvar console = new Utils.Console(\"BaseClient\"); // Finsemble console\r\n\tvar Validate = __webpack_require__(3); // Finsemble args validator\r\n\tvar BaseClient = __webpack_require__(11);\r\n\t/**\r\n\t * \r\n\t * Public API for The Linker Service\r\n\t * The linker client acts as an API between components and the Linker Service. The linker client allows for sharing of data between components.\r\n\t *  @example\r\n\t *\r\n\t * // Save a key value pair to local storage\r\n\t * FSBL.LinkerClient.openLinkerWindow(callback)\r\n\t * FSBL.LinkerClient.updateLink(msg, callback)\r\n\t * FSBL.LinkerClient.getGroups()\r\n\t * FSBL.LinkerClient.getGroup(\"group1\")\r\n\t * FSBL.LinkerClient.getLinks(callback)\r\n\t * FSBL.LinkerClient.subscribe(\"group1\",\"symbol\",callback)\r\n\t * FSBL.LinkerClient.unSubscribe(\"group1\",\"symbol\",callback)\r\n\t * FSBL.LinkerClient.publish(\"group1\",\"symbol\",\"aapl\")\r\n\t * \r\n\t * @todo catch refesh events so that we can close down the linker window if open\r\n\t * @constructor\r\n\t */\r\n\tvar LinkerClient = function (params) {\r\n\t\tValidate.args(params, \"object=\") && params && Validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\t\tBaseClient.call(this, params);\r\n\t\tvar self = this;\r\n\t\tvar links = {};\r\n\t\tthis.onLinksUpdate = [];\r\n\t\tthis.groups = {};\r\n\t\tvar linkOptions = {};\r\n\t\tvar retryCount = 0;\r\n\t\tvar linkerWindow = null;\r\n\t\tvar listenerList = {};\r\n\t\tvar loading = false;\r\n\t\r\n\t\t/** \r\n\t\t * Create a new linker group\r\n\t\t * @param {string} groupName -  The name of the new group\r\n\t\t * @param {LinkerClient~groupCB} [cb] -  callback to be called on success\r\n\t\t * \r\n\t\t * @example\r\n\t\t * LinkerClient.createGroup(\"groupname\",callback)\r\n\t\t */\r\n\t\tthis.createGroup = function (groupName, cb) {\r\n\t\t\tValidate.args(groupName, \"string\", cb, \"function\");\r\n\t\t\tthis.routerClient.query('Linker.createGroup', { groupName: groupName }, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\treturn cb(err, response);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t});\r\n\t\t};\r\n\t\t/** \r\n\t\t * Update a groups info. Currenlty, only the name is used.\r\n\t\t * \r\n\t\t * @param {LinkerClient~group} previousGroup - The old group \r\n\t\t * @param {LinkerClient~group} newGroup -  The name of the new group\r\n\t\t * @param {LinkerClient~groupCB} [cb]\r\n\t\t * @example\r\n\t\t *\r\n\t\t * LinkerClient.createGroup({name:\"group1\",receive:[],transmit:[]},{name:\"group2\",receive:[],transmit:[]},callback)\r\n\t\t *\r\n\t\t */\r\n\t\tthis.updateGroup = function (previousGroup, newGroup, cb) {\r\n\t\t\tValidate.args(previousGroup, \"object\", newGroup, \"object\", cb, \"function\");\r\n\t\t\tthis.routerClient.query('Linker.updateGroup', { previousGroup: previousGroup, newGroup: newGroup }, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\treturn cb(err, response);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t});\r\n\t\r\n\t\t};\r\n\t\t/** \r\n\t\t * Register a client to a groups. Clients will receive all transmits for a registered group.\r\n\t\t * \r\n\t\t * @param {LinkerClient~group} group - The old group \r\n\t\t * @param {string} client -  The window name of the client\r\n\t\t * @param {LinkerClient~linksCB} [cb] Returns all the links for the client\r\n\t\t * @example\r\n\t\t *\r\n\t\t * LinkerClient.registerGroup({name:\"group1\",receive:[],transmit:[]},\"windowNameHere\",callback)\r\n\t\t *\r\n\t\t */\r\n\t\tthis.registerGroup = function (group, client, cb) {\r\n\t\t\tValidate.args(group, \"string\", client, \"string\", cb, \"function\");\r\n\t\t\tvar params = {\r\n\t\t\t\tclient: client ? client : self.clientName,\r\n\t\t\t\tgroup: group\r\n\t\t\t};\r\n\t\t\tthis.routerClient.query(\"Linker.registerGroup\", params, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\treturn cb(err, response);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/** \r\n\t\t * Removes a client from a groups. \r\n\t\t * \r\n\t\t * @param {LinkerClient~group} group - The old group \r\n\t\t * @param {string} client -  The window name of the client\r\n\t\t * @param {LinkerClient~linksCB} [cb] Returns all the links for the client\r\n\t\t * @example\r\n\t\t *\r\n\t\t * LinkerClient.unRegisterGroup({name:\"group1\",receive:[],transmit:[]},\"windowNameHere\",callback)\r\n\t\t *\r\n\t\t */\r\n\t\tthis.unRegisterGroup = function (group, client, cb) {\r\n\t\t\tValidate.args(group, \"string\", client, \"string\", cb, \"function\");\r\n\t\t\tvar params = {\r\n\t\t\t\tclient: client ? client : self.clientName,\r\n\t\t\t\tgroup: group\r\n\t\t\t};\r\n\t\t\tthis.routerClient.query(\"Linker.unRegisterGroup\", params, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\treturn cb(err, response);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/** \r\n\t\t * Get a new linker group\r\n\t\t * @param {string} groupName -  The name of the new group\r\n\t\t * @param {LinkerClient~groupCB} [cb] -  callback to be called on success\r\n\t\t * \r\n\t\t * @example\r\n\t\t * LinkerClient.createGroup(\"groupname\",callback)\r\n\t\t */\r\n\t\tthis.getGroup = function (groupName, cb) {\r\n\t\t\tValidate.args(groupName, \"string\", cb, \"function\");\r\n\t\t\tthis.routerClient.query('Linker.getGroup', { groupName: groupName }, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/** \r\n\t\t * Get a new linker group\r\n\t\t * @param {LinkerClient~groupsCB} [cb] -  callback to be called on success\r\n\t\t * \r\n\t\t * @example\r\n\t\t * LinkerClient.getGroups(callback)\r\n\t\t */\r\n\t\tthis.getGroups = function (cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\t\tthis.routerClient.query('Linker.getGroups', {}, function (err, response) {\r\n\t\t\t\tconsole.log(\"got groups\", response);\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/** \r\n\t\t * Get all links for a window\r\n\t\t * @param {LinkerClient~linksCB} [cb] -  callback to be called on success\r\n\t\t * \r\n\t\t * @example\r\n\t\t * LinkerClient.getLinks(callback)\r\n\t\t */\r\n\t\tthis.getLinks = function (client, cb) {\r\n\t\t\tValidate.args(client, \"string\", cb, \"function\");\r\n\t\t\tthis.routerClient.query('Linker.getLinks', { client: client }, function (err, response) {\r\n\t\t\t\tconsole.log(\"links....\", response);\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tconsole.error(JSON.stringify(err));\r\n\t\t\t\t}\r\n\t\t\t\tif (retryCount < 4 && err) {\r\n\t\t\t\t\tretryCount++;\r\n\t\t\t\t\treturn setTimeout(function () {\r\n\t\t\t\t\t\tself.getLinks(client, cb);\r\n\t\t\t\t\t}, 100);\r\n\t\t\t\t}\r\n\t\t\t\tlinks = response.data;\r\n\t\t\t\tretryCount = 0;\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response.data);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/** \r\n\t * Get all links for a window\r\n\t * @param {Object} msg\r\n\t * @param {String} msg.client\r\n\t * @param {String} msg.dataType\r\n\t * @param {String} msg.group\r\n\t * @param {boolean} msg.value\r\n\t * @param {LinkerClient~linksCB} [cb] -  callback to be called on success\r\n\t * \r\n\t * @example\r\n\t * LinkerClient.updateLink(msg,callback)\r\n\t */\r\n\t\tthis.updateLink = function (msg, cb) {\r\n\t\t\tValidate.args(msg, \"object\", cb, \"function\");\r\n\t\t\tthis.routerClient.query('Linker.updateLink', msg, function (err, response) {\r\n\t\t\t\tif (cb) {\r\n\t\t\t\t\tcb(err, response);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/** \r\n\t* Opens the linker popup and sends the current windows information\r\n\t* @param {function} [cb] -  callback to be called on success\r\n\t* \r\n\t* @example\r\n\t* LinkerClient.openLinkerWindow(cb)\r\n\t@todo use some config to tell where the top is.\r\n\t*/\r\n\t\r\n\t\tthis.openLinkerWindow = function (cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\t\tif (loading) { return; }\r\n\t\t\tif (linkerWindow) {\r\n\t\t\t\treturn linkerWindow.isShowing(function (showing) {\r\n\t\t\t\t\tif (showing) {\r\n\t\t\t\t\t\treturn linkerWindow.hide();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconsole.log(\"show linker\", showing);\r\n\t\t\t\t\tlinkerWindow.show();\r\n\t\t\t\t\tlinkerWindow.focus();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tloading = true;\r\n\t\t\tvar linkWindowName = this.clientName + \"linkerWindow\";\r\n\t\t\tconsole.log(\"linkWindowName\", linkWindowName);\r\n\t\t\tfin.desktop.Window.getCurrent().getBounds(function (bounds) {\r\n\t\t\t\tFSBL.Clients.LauncherClient.spawn(\"linkerWindow\", {\r\n\t\t\t\t\toptions: {\r\n\t\t\t\t\t\tname: linkWindowName,\r\n\t\t\t\t\t\tcustomData: { window: self.clientName, windowBounds: bounds, linkOptions: linkOptions, uuid: fin.desktop.Application.getCurrentApplication().uuid }\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t\tfunction (err, msg) {\r\n\t\t\t\t\t\tconsole.log(\"msg\", msg);\r\n\t\t\t\t\t\tlinkerWindow = fin.desktop.Window.wrap(msg.data.uuid, msg.data.name);\r\n\t\t\t\t\t\tloading = false;\r\n\t\t\t\t\t});\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/** \r\n\t\t* Add a listener to the specified group and data type\r\n\t\t* @param {String}  groupName -  the name of the group subscribing to\r\n\t\t* @param {String}  dataType - The data type be subscribed to\r\n\t\t* @param {function} [cb] -callback to be called on success\r\n\t\t* @todo verify group and data type\r\n\t\t* @example\r\n\t\t* LinkerClient.subscribe(\"group1\",\"symbol\",cb)\r\n\t\t*/\r\n\t\tthis.subscribe = function (groupName, dataType, cb) {\r\n\t\t\tValidate.args(groupName, \"string\", dataType, \"string\", cb, \"function\");\r\n\t\t\tthis.routerClient.addListener(groupName + dataType, cb);\r\n\t\t};\r\n\t\r\n\t\t/** \r\n\t\t* remove a listener to the specified group and data type\r\n\t\t* @param {String}  groupName -  the name of the group subscribing to\r\n\t\t* @param {String}  dataType - The data type be subscribed to\r\n\t\t* @param {function} [cb] -callback to be called on success\r\n\t\t* \r\n\t\t* @example\r\n\t\t* LinkerClient.subscribe(\"group1\",\"symbol\",cb)\r\n\t\t*/\r\n\t\tthis.unSubscribe = function (groupName, dataType) {\r\n\t\t\tValidate.args(groupName, \"string\", dataType, \"string\");\r\n\t\t\tthis.routerClient.removeListener(groupName + dataType);\r\n\t\t};\r\n\t\r\n\t\t/** \r\n\t\t* Publish data to all listeners for a group and data typre\r\n\t\t* @param {String}  groupName - the name of the group subscribing to\r\n\t\t* @param {String}  dataType - The data type sending\r\n\t\t* @param {any}  data - the data being transmitted\r\n\t\t* @param {function} [cb] - callback to be called on success\r\n\t\t* @todo verify Publish\r\n\t\t* @example\r\n\t\t* LinkerClient.subscribe(\"group1\",\"symbol\",cb)\r\n\t\t*/\r\n\t\tthis.publish = function (dataType, data) {\r\n\t\t\tValidate.args(dataType, \"string\", data, \"any\");\r\n\t\t\tfor (var group in links) {\r\n\t\t\t\tif (links[group][dataType] || links[group].all) {\r\n\t\t\t\t\tconsole.log(\"send data through linker\");\r\n\t\t\t\t\tthis.routerClient.transmit(group + \".\" + dataType, { type: dataType, data: data });\r\n\t\t\t\t\tthis.routerClient.transmit(group, { type: dataType, data: data });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t//if there are any updates sent for linkers, like through the linker window, this gets the new info.\r\n\t\tfunction handleLinkerUpdates(err, msg) {\r\n\t\t\tif (err) {\r\n\t\t\t\treturn console.log(err);\r\n\t\t\t}\r\n\t\t\tself.getLinks(self.clientName, function (err, response) {\r\n\t\t\t\tupdateListeners();\r\n\t\t\t\tupdateGroups();\r\n\t\t\t\tmsg.sendQueryResponse(err, response);\r\n\t\t\t});\r\n\t\t}\r\n\t\r\n\t\t/** \r\n\t\t* registers a client for a specific data type that is sent to a group.\r\n\t\t* @param {String} dataType\r\n\t\t* @param {function} [func] -  a function to be called once the linker receives the specific data.\r\n\t\t* \r\n\t\t* @example\r\n\t\t* LinkerClient.registerListener(\"symbol\",func)\r\n\t\t*/\r\n\t\tthis.registerListener = function (dataType, func) {\r\n\t\t\tValidate.args(dataType, \"string\", func, \"function\");\r\n\t\t\tconsole.log(\"datatype--\", dataType);\r\n\t\t\tif (listenerList[dataType]) {\r\n\t\t\t\treturn listenerList[dataType].push(func);\r\n\t\t\t}\r\n\t\t\tlistenerList[dataType] = [func];\r\n\t\t};\r\n\t\t//Need to do this better. Get newest items so we don't create it every time\r\n\t\t//This looks to see if there is a listener for a specific data type\r\n\t\t//@todo\r\n\t\tfunction handleListeners(err, data) {\r\n\t\t\tvar listeners = listenerList[data.data.type];\r\n\t\t\tif (listeners && listeners.length > 0) {\r\n\t\t\t\tfor (var i = 0; i < listeners.length; i++) {\r\n\t\t\t\t\tlisteners[i](data.data.data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//add new listeners for groups when groups are updated\r\n\t\tfunction updateListeners() {\r\n\t\t\t//loop through links and see if we need to setup new listeners\r\n\t\t\tfor (var group in links) {\r\n\t\t\t\tif (links[group].all) {\r\n\t\t\t\t\tself.routerClient.addListener(group, handleListeners);\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tfor (var type in links[group]) {\r\n\t\t\t\t\tif (links[group][type].receive) {\r\n\t\t\t\t\t\tself.routerClient.addListener(type, handleListeners);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//when groups are updated, update this object with the latest data\r\n\t\tfunction updateGroups(err, response) {\r\n\t\t\tvar l = links;\r\n\t\t\tif (response) {\r\n\t\t\t\tself.groups = response.data;\r\n\t\t\t} else {\r\n\t\r\n\t\t\t}\r\n\t\t\tself.getLinks(self.clientName, function (err, l2) {\r\n\t\t\t\tfor (var i = 0; i < self.onLinksUpdate.length; i++) {\r\n\t\t\t\t\tself.onLinksUpdate[i](err, self.groups, links);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\r\n\t\t}\r\n\t\t// load all linkages and register listeners for updated data.\r\n\t\tthis.loadLinks = function () {\r\n\t\t\tthis.routerClient.addServer(this.finWindow.name + \".linker\", handleLinkerUpdates);\r\n\t\t\tthis.routerClient.addListener(\"Linker.UpdateGroups\", updateGroups);\r\n\t\t\tself.getLinks(self.clientName, function (err, response) {\r\n\t\t\t\tupdateListeners();\r\n\t\t\t});\r\n\t\r\n\t\t\tthis.getGroups(updateGroups);\r\n\t\r\n\t\t\tthis.finWindow.getOptions(function (options) {\r\n\t\t\t\tif (options.customData && options.customData.linker) {\r\n\t\t\t\t\tlinkOptions = options.customData.linker;//load defaults\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\treturn this;\r\n\t};\r\n\t\r\n\tvar linkerClient = new LinkerClient({\r\n\t\tonReady: function (cb) {\r\n\t\t\tlinkerClient.loadLinks();\r\n\t\t\tconsole.log(\"linkerClient Online\");\r\n\t\t\tcb();\r\n\t\t},\r\n\t\tname: \"linkerClient\"\r\n\t});\r\n\tlinkerClient.requiredServices = [\"linkerService\"];\r\n\t//linkerClient.initialize();\r\n\tmodule.exports = linkerClient;\r\n\t\r\n\t\r\n\t/**\r\n\t * Linker group\r\n\t* @typedef {Object} LinkerClient~group\r\n\t* @property  {string}  name\r\n\t* @property  {Array} receive\r\n\t* @property  {Array} transmit\r\n\t */\r\n\t/**\r\n\t * Linker links\r\n\t* @typedef {Object} LinkerClient~links\r\n\t* @property  {LinkerClient~linkGroup}  group\r\n\t */\r\n\t/**\r\n\t * Linker link group\r\n\t* @typedef {Object} LinkerClient~linkGroup\r\n\t* @property  {LinkerClient~dataType}  dataType\r\n\t */\r\n\t\r\n\t/**\r\n\t * Linker data Type\r\n\t* @typedef {Object} LinkerClient~dataType\r\n\t* @property  {LinkerClient~links} link\r\n\t */\r\n\t/**\r\n\t * Linker link\r\n\t* @typedef {Object} LinkerClient~links\r\n\t* @property  {boolean} receive\r\n\t* @property  {boolean} transmit\r\n\t */\r\n\t\r\n\t/**\r\n\t* @callback LinkerClient~groupCB\r\n\t* @param {Object} err\r\n\t* @param {LinkerClient~group} responseMessage\r\n\t*/\r\n\t/**\r\n\t* @callback LinkerClient~groupsCB\r\n\t* @param {Object} err\r\n\t* @param {LinkerClient~group[]} responseMessage\r\n\t*/\r\n\t/**\r\n\t* @callback LinkerClient~linksCB\r\n\t* @param {Object} err\r\n\t* @param {LinkerClient~links} responseMessage\r\n\t*/\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RouterClient = __webpack_require__(4);\r\n\tvar StorageClient = __webpack_require__(10);\r\n\t//var WindowManagerDom = require('../components/windowManager/windowManager');\r\n\tvar WorkspaceClient = __webpack_require__(15);\r\n\twindow.console.log(\"WorkspaceClient\",WorkspaceClient);\r\n\tvar util = __webpack_require__(1);\r\n\tvar BaseClient = __webpack_require__(11);\r\n\tvar console = new util.Console(\"BaseClient\"); // Finsemble console\r\n\tvar Validate = __webpack_require__(3); // Finsemble args validator\r\n\t/**\r\n\t *\r\n\t *@introduction\r\n\t  ## WindowClient\r\n\t  ----------\r\n\t * The WindowClient is primarily responsible for managing the windowState (the window's bounds) and appState (data inside of your component). It also injects the windowManager component, which contains controls for minimizing, maximizing, closing, and restoring your window. The reference below is provided in case you'd like to manually trigger events.\r\n\t *\r\n\t * This is the API reference, if you're looking for information about the windowManager or how to disable certain aspects of the finsemble header bar, please see the [WindowManager tutorial]{@tutorial windowManagerComponent} for more information.\r\n\t\r\n\t * **Note:** The documentation below extensively uses the term <code>hash</code>. This is not the same as something like <code>MD5</code>. We use it to mean  \"The camelCased concatenation of more than one string.\"\r\n\t *\r\n\t * ### Reference  \r\n\t * <pre class=\"language-js line-numbers\"><code>\r\n\t * //'Hashes' are simply the camelCased concatenation of two or more strings. By default, we use the following 'hashes' throughout the code. \r\n\t * var workspaceHash = util.camelCase('workspaceName');\r\n\t * var windowHash = util.camelCase(workspaceHash, 'windowName');\r\n\t * var containerHash = util.camelCase(windowHash, containerName);\r\n\t * \t</code></pre>\r\n\t * \r\n\t * @constructor\r\n\t * @summary You don't need to ever invoke the constructor. This is done for you when WindowClient is added to the FSBL object.\r\n\t * @returns {WindowClient}\r\n\t */\r\n\tfunction WindowClient(params) {\r\n\t\tValidate.args(params, \"object=\") && params && Validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\t\r\n\t\t/** @alias WindowClient# */\r\n\t\tBaseClient.call(this, params);\r\n\t\r\n\t\tvar self = this;\r\n\t\t//We store the options that the window is created with in this property.\r\n\t\tthis.options = {};\r\n\t\t//The hash we use to save data with.\r\n\t\tthis.windowHash = '';\r\n\t\t//Window's title.\r\n\t\tthis.title = null;\r\n\t\t//This is the bottom edge of the toolbar. The window's position will be offset by this much.\r\n\t\t//@todo move this value to a config.\r\n\t\tthis.toolbarBottom = 32;\r\n\t\t//default value. The window assigns the containers it cares about before starting.\r\n\t\tthis.containers = [];\r\n\t\t//window state for restoration purposes.\r\n\t\tthis.appState = {};\r\n\t\t//where we store appState for the window.\r\n\t\tthis.appState[fin.desktop.Window.getCurrent().name] = {};\t\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * @returns {windowHash}\r\n\t\t */\r\n\t\tthis.getWindowHash = function () {\r\n\t\t\treturn self.windowHash;\r\n\t\t};\r\n\t\t/**\r\n\t\t * This function does two things:\r\n\t\t *\r\n\t\t * 1. It sets the window's title in the windowManager component, and\r\n\t\t * 2. It sets the title in the DOM.\r\n\t\t *\r\n\t\t * This is useful if you like to keep the window's title in sync with a piece of data (e.g., a Symbol);\r\n\t\t * @param {String} title Window title.\r\n\t\t * @example <caption>The code shows how you would change your window title.</caption>\r\n\t\t *\t//something happens above, like a symbol change.\r\n\t\t *  FSBL.WindowClient.setWindowTitle(\"My component - \" + data.symbol);\r\n\t\t */\r\n\t\tthis.setWindowTitle = function (title) {\r\n\t\t\tValidate.args(title, \"string\");\r\n\t\t\tthis.title = title;\r\n\t\t\tdocument.title = title;\r\n\t\t\tvar titleUpdateChannel = finWindow.name + '.titleUpdate';\r\n\t\t\tRouterClient.transmit(titleUpdateChannel, title);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Retrieves the window's title.\r\n\t\t * @returns {String} title\r\n\t\t * @example\r\n\t\t * var windowTitle = FSBL.WindowClient.getWindowTitle();\r\n\t\t */\r\n\t\tthis.getWindowTitle = function () {\r\n\t\t\treturn this.title;\r\n\t\t};\r\n\t\t/**\r\n\t\t * This function retrieves the dimensions of the monitor that the window is on. It's currently used in the {@link launcherClient}.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.retrieveMonitorDimensions = function (callback) {\r\n\t\t\tutil.retrieveMonitorDimensions(function (err, dims) {\r\n\t\t\t\tself.options.defaultLeft = dims.defaultLeft;\r\n\t\t\t\tself.options.defaultTop = dims.defaultLeft;\r\n\t\t\t\tself.options.monitorDimensions = dims.monitorDimensions;\r\n\t\t\t\tif(callback){callback(err);}\r\n\t\t\t}); \r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Sets initial state for the window. This data is modified on subsequent saves.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.setInitialWindowState = function (callback) {\r\n\t\t\tself.windowHash = util.camelCase('activeWorkspace', finWindow.name);\r\n\t\t\tfinWindow.getOptions(function (options) {\r\n\t\t\t\tself.options = options;\r\n\t\t\t\t//self.retrieveMonitorDimensions();\r\n\t\t\t\tself.retrieveMonitorDimensions(function(){\r\n\t\t\t\t\r\n\t\t\t\t\tconsole.log(\"self.options\", self.options);\r\n\t\t\t\t\tif (!self.options.customData.persists) {\r\n\t\t\t\t\t\tconsole.log(\"dont save....\");\r\n\t\t\t\t\t\treturn callback();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconsole.log(\"save.... windowstate\" + JSON.stringify(self.options.customData));\r\n\t\t\t\t\tStorageClient.localStorage.save(self.windowHash, self.options);\r\n\t\t\t\t\tcallback();\r\n\t\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\r\n\t\t/**\r\n\t\t * \r\n\t\t * Saves the window's state. Rarely called manually, as it's called every time your window moves.\r\n\t\t * @param {Object} bounds\r\n\t\t * @example <caption>The code below is the bulk of our listener for the <code>bounds-changed</code> event from the openFin window. Every time the <code>bounds-changed</code> event is fired (when the window is resized or moved), we save the window's state. The first few lines just prevent the window from being dropped behind the toolbar.</caption>\r\n\t\t *finWindow.addEventListener('bounds-changed', function (bounds) {\r\n\t\t * \tif (bounds.top < 45) {\r\n\t\t *\t\tfinWindow.moveTo(bounds.left, 45);\r\n\t\t *\t\treturn;\r\n\t\t *\t}\r\n\t\t *\tself.saveWindowState(bounds);\r\n\t\t *});\r\n\t\t */\r\n\t\tthis.saveWindowState = function (bounds) {\r\n\t\t\tValidate.args(bounds, \"object\") && Validate.args2(\"bounds.top\", bounds.top, \"number\");\r\n\t\t\tif (!self.options.customData.persists) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t//This response has the following shape:\r\n\t\t\tself.options.defaultTop = bounds.top;\r\n\t\t\tself.options.defaultLeft = bounds.left;\r\n\t\t\tself.options.defaultWidth = bounds.width;\r\n\t\t\tself.options.defaultHeight = bounds.height;\r\n\t\t\tconsole.log('saving window state', self.options);\r\n\t\t\tStorageClient.localStorage.save(self.windowHash, self.options);\r\n\t\t\tRouterClient.transmit('WorkspaceService.setActiveWorkspaceDirty', null, null);\r\n\t\t};\r\n\t\t/**\r\n\t\t * This function is fired every time the window's bounds change. It does three things:\r\n\t\t * 1. Figures out which monitor the window is on (if it changes monitors),\r\n\t\t * 2. Prevents the window from being dropped behind the toolbar.\r\n\t\t * 3. Persists the window's state so that it can be restored later.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.boundsChangedListener = function (bounds) {\r\n\t\t\t//if the window's left edge leaves the monitor's boundary\r\n\t\t\tif (bounds.left > self.options.monitorDimensions.right || bounds.left < self.options.monitorDimensions.left) {\r\n\t\t\t\tself.retrieveMonitorDimensions();\r\n\t\t\t}\r\n\t\r\n\t\t\tif (bounds.top < self.toolbarBottom) {\r\n\t\t\t\tfinWindow.moveTo(bounds.left, self.toolbarBottom);\r\n\t\t\t}\r\n\t\t\tself.saveWindowState(bounds);\r\n\t\t};\r\n\t\t/**\r\n\t\t * This event is fired when a window is resized or moved.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.listenForBoundsChanged = function () {\r\n\t\t\tif (typeof (finWindow) === 'undefined') {\r\n\t\t\t\twindow.finWindow = fin.desktop.Window.getCurrent();\r\n\t\t\t}\r\n\t\t\tfinWindow.getOptions(function (opts) {\r\n\t\t\t\tif (opts.customData.componentType !== 'Toolbar') {\r\n\t\t\t\t\tfinWindow.addEventListener('bounds-changed', self.boundsChangedListener);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/**\r\n\t\t * Minmizes window.\r\n\t\t * @example\r\n\t\t * FSBL.WindowClient.minimize();\r\n\t\t */\r\n\t\tthis.minimize = function () {\r\n\t\t\tfinWindow.minimize(function () { }, function (err) { console.error(err); });\r\n\t\t};\r\n\t\t/**\r\n\t\t * Restores window from a maximized state.\r\n\t\t * @example\r\n\t\t * FSBL.WindowClient.restore();\r\n\t\t */\r\n\t\tthis.restore = function () {\r\n\t\t\tfinWindow.removeEventListener('bounds-changed', this.boundsChangedListener);\r\n\t\t\tfinWindow.setBounds(\r\n\t\t\t\tthis.options.cachedLeft,\r\n\t\t\t\tthis.options.cachedTop,\r\n\t\t\t\tthis.options.cachedWidth,\r\n\t\t\t\tthis.options.cachedHeight,\r\n\t\t\t\tfunction () {\r\n\t\t\t\t\tfinWindow.addEventListener('bounds-changed', self.boundsChangedListener);\r\n\t\t\t\t}, function (err) { console.error(err); });\r\n\t\t};\r\n\t\t/**\r\n\t\t * Maximizes the window. Also takes into account the application toolbar.\r\n\t\t * @todo, when fixed components are a thing, make sure that maximize doesn't sit on top of them either.\r\n\t\t * @example\r\n\t\t * FSBL.WindowClient.maximize();\r\n\t\t */\r\n\t\tthis.maximize = function () {\r\n\t\t\tfinWindow.removeEventListener('bounds-changed', this.boundsChangedListener);\r\n\t\t\tvar monitorDimensions = this.options.monitorDimensions;\r\n\t\t\tthis.options.cachedLeft = this.options.defaultLeft;\r\n\t\t\tthis.options.cachedTop = this.options.defaultTop;\r\n\t\t\tthis.options.cachedWidth = this.options.defaultWidth;\r\n\t\t\tthis.options.cachedHeight = this.options.defaultHeight;\r\n\t\t\tfinWindow.setBounds(\r\n\t\t\t\tmonitorDimensions.left,\r\n\t\t\t\tthis.toolbarBottom,\r\n\t\t\t\tmonitorDimensions.width,\r\n\t\t\t\tmonitorDimensions.height,\r\n\t\t\t\tfunction () {\r\n\t\t\t\t\tfinWindow.addEventListener('bounds-changed', self.boundsChangedListener);\r\n\t\t\t\t},\r\n\t\t\t\tfunction (err) { console.error(err); }\r\n\t\t\t);\r\n\t\t};\r\n\t\t/**\t \r\n\t\t * Closes Window.\r\n\t\t * @param {boolean} removeFromWorkspace whether to remove the window from the workspace.\r\n\t\t * Defaults are to remove the window from the workspace if the user presses the X button, but not if the window is closed via an app-level request (e.g., we need to switch workspaces, so all windows need to close).\r\n\t\t * @example\r\n\t\t *\t//Close window and remove from workspace (e.g., user closes the window).\r\n\t\t *\tFSBL.WindowClient.close(true);\r\n\t\t *\t//Close window and keep in workspace (e.g., application requests that all windows close themselves).\r\n\t\t *\tFSBL.WindowClient.close(false);\r\n\t\t */\r\n\t\tthis.close = function (removeFromWorkspace) {\r\n\t\t\tValidate.args(removeFromWorkspace, \"boolean\");\r\n\t\t\tconsole.log(\"close Called\");\r\n\t\t\tthis.deregisterWithDockingManager();\r\n\t\t\tRouterClient.disconnectAll();\r\n\t\t\tif (removeFromWorkspace) {\r\n\t\t\t\tWorkspaceClient.removeWindow({\r\n\t\t\t\t\tname: finWindow.name\r\n\t\t\t\t}, function (err, response) {\r\n\t\t\t\t\tconsole.log(\"close sending1\");\r\n\t\t\t\t\tfinWindow.close(true);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log(\"close sending2\");\r\n\t\t\t\tfinWindow.close(true);\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * This function injects the header bar into all frameless windows that request it. This should only be used if you've decided not to use the provided <code>WindowClient.start()</code> method.\r\n\t\t *\r\n\t\t * **NOTE:** If you are using the finsemble windowManager component, you do not need to call this function.\r\n\t\t */\r\n\t\tthis.injectDOM = function () {\r\n\t\t\t//for the aesthetics.\r\n\t\t\tif (document.getElementById('fsbl-header-bar')) { return; }\r\n\t\t\tvar template = document.createElement('div');\r\n\t\t\t//template.id = \"FSBLHeader\";\r\n\t\t\t//template.setAttribute(\"id\", \"FSBLHeader\");\r\n\t\t\ttemplate.innerHTML = \"<div id='FSBLHeader'></div>\";\r\n\t\t\tdocument.body.insertBefore(template.firstChild, document.body.firstChild);\r\n\t\t\tdocument.body.style.marginTop = '24px';\r\n\t\t\tinjectFSBL();\r\n\t\t};\r\n\t\t/**\r\n\t\t * Injects the windowManager into the window.\r\n\t\t * @private\r\n\t\t */\r\n\t\tfunction injectFSBL() {\r\n\t\t\tvar script = document.createElement('script');\r\n\t\t\tscript.type = 'text/javascript';\r\n\t\t\tscript.async = true;\r\n\t\t\tscript.src = '/components/windowManager/windowManager.js';\r\n\t\t\tvar head = document.getElementsByTagName('head')[0];\r\n\t\t\thead.appendChild(script);\r\n\t\r\n\t\t}\r\n\t\t/**\r\n\t\t * Given a field, this function retrieves app state.\r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.field field\r\n\t\t * @param {function} cb Callback\r\n\t\t * @example <caption>The example below shows how we retrieve data to restore the layout in our charts.</caption>\t \r\n\t\t *FSBL.WindowClient.getAppState({\r\n\t\t *\t field: 'myChartLayout',\r\n\t\t *}, function (err, state) {\r\n\t\t   *\tif (state === null) {\r\n\t\t *\t\treturn;\r\n\t\t *\t}\r\n\t\t *\tstx.importLayout(state);\r\n\t\t *});\r\n\t\t **/\r\n\t\tthis.getAppState = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function\") && Validate.args2(\"params.field\", params.field, \"string\");\r\n\t\t\tparams.windowName = fin.desktop.Window.getCurrent().name;\r\n\t\t\tvar hash = self.getContainerHash(params.windowName);\r\n\t\t\tStorageClient.localStorage.get(hash, function (err, response) {\r\n\t\t\t\tif (response.data && params.field) {\r\n\t\t\t\t\tvar data = JSON.parse(response.data);\r\n\t\t\t\t\tconsole.log('Found', hash, data);\r\n\t\t\t\t\tself.appState[params.windowName] = data;\r\n\t\t\t\t\tcb(err, data[params.field]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcb(err, response.data);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Checks to see if this save makes the workspace 'dirty'. We use this when deciding whether to prompt the user to save their workspace.\r\n\t\t * @private\r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.field field\r\n\t\t * @param {string} params.windowName windowName\r\n\t\t * @param {function} cb Callback\r\n\t\t */\r\n\t\tthis.compareSavedState = function (params) {\r\n\t\t\tif (!WorkspaceClient || WorkspaceClient.workspaceIsDirty) { return; };\r\n\t\t\tvar hash = util.camelCase(WorkspaceClient.activeWorkspace.name, finWindow.name, params.windowName);\r\n\t\t\tStorageClient.localStorage.get(hash, function (err, response) {\r\n\t\t\t\tconsole.log('comparing saved state', response.data);\r\n\t\t\t\tif (response.data !== JSON.stringify(params.value)) {\r\n\t\t\t\t\tRouterClient.transmit('WorkspaceService.setActiveWorkspaceDirty', null, null);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\t/**\r\n\t\t * Given a field, this function sets and persists app state.\r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.field field\r\n\t\t * @param {function=} cb Callback\r\n\t\t * @example <caption>The example below shows how we save our chart layout when it changes.</caption>\r\n\t\t * var s = stx.exportLayout(true);\r\n\t\t * //saving layout'\r\n\t\t * FSBL.WindowClient.setAppState({ field: 'myChartLayout', value: s });\r\n\t\t **/\r\n\t\tthis.setAppState = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && Validate.args2(\"params.field\", params.field, \"string\");\r\n\t\t\tparams.windowName = fin.desktop.Window.getCurrent().name;\r\n\t\t\tvar hash = self.getContainerHash(params.windowName);\r\n\t\t\tself.appState[params.windowName][params.field] = params.value;\r\n\t\t\tthis.compareSavedState(params);\r\n\t\t\tStorageClient.localStorage.save(hash, self.appState[params.windowName], function (err, response) {\r\n\t\t\t\tif (cb) { cb(err, response); }\r\n\t\t\t});\r\n\t\t};\r\n\t\t/**\r\n\t\t * Gets containerHash given a containerId.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.getContainerHash = function (windowName) {\r\n\t\t\treturn util.camelCase(self.windowHash, windowName);\r\n\t\t};\r\n\t\t/**\r\n\t\t * This function is critical if you want docking and snapping to work. It transmits a message to the LauncherService, which registers it as a dockable window.\r\n\t\t *\r\n\t\t * **NOTE:** If you are using the finsemble windowManager component, you do not need to call this function.\r\n\t\t * @example\r\n\t\t * FSBL.WindowClient.registerWithDockingManager();\r\n\t\t */\r\n\t\tthis.registerWithDockingManager = function () {\r\n\t\t\tvar application = fin.desktop.Application.getCurrent();\r\n\t\t\tapplication.getManifest(function (manifest) {\r\n\t\t\t\tvar uuid = manifest.startup_app.uuid;\r\n\t\t\t\tvar windowName = fin.desktop.Window.getCurrent().name;\r\n\t\t\t\tRouterClient.transmit('register-docking-window', {\r\n\t\t\t\t\tname: windowName,\r\n\t\t\t\t\tuuid: uuid\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t};\r\n\t\t/**\r\n\t\t * This function is critical if you don't want to keep references of windows in the LauncherService after they close. It simply notifies the LauncherService that the window is no longer dockable. It's invoked when the window is closed.\r\n\t\t * **NOTE:** If you are using the finsemble windowManager component, you do not need to call this function.\r\n\t\t * @example\r\n\t\t * FSBL.WindowClient.deregisterWithDockingManager();\r\n\t\t */\r\n\t\tthis.deregisterWithDockingManager = function () {\r\n\t\t\tvar windowName = fin.desktop.Window.getCurrent().name;\r\n\t\t\tRouterClient.transmit('deregister-docking-window', {\r\n\t\t\t\tname: windowName\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Helper function to display devtools if you disable context-menus on your chromium windows. You must call this function if you want the hotkey to work.\r\n\t\t * @since 3/17/2017, only the Toolbar uses this.\r\n\t\t */\r\n\t\tthis.enableDevToolsHotkey = function () {\r\n\t\t\tif (window.location.hostname === 'localhost') {\r\n\t\t\t\twindow.addEventListener('keydown', function (e) {\r\n\t\t\t\t\tif (e.keyCode === 68 && e.shiftKey && e.ctrlKey) {\r\n\t\t\t\t\t\tvar application = fin.desktop.Application.getCurrent();\r\n\t\t\t\t\t\tapplication.getManifest(function (manifest) {\r\n\t\t\t\t\t\t\tvar uuid = manifest.startup_app.uuid;\r\n\t\t\t\t\t\t\tvar windowName = fin.desktop.Window.getCurrent().name;\r\n\t\t\t\t\t\t\tfin.desktop.System.showDeveloperTools(uuid, windowName);\r\n\t\t\t\t\t\t}, function (err) {\r\n\t\t\t\t\t\t\tconsole.error(err);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\t\t/**\r\n\t\t * This function is invoked inside of {@link WindowClient#start|WindowClient.start()}. It adds listeners for 'close' (when the workspace is switched), 'bringToFront', 'restore', and 'move' (used in AutoArrange).\r\n\t\t *\r\n\t\t * **NOTE:** If you are using the finsemble windowManager component, you do not need to call this function.\r\n\t\t * @example\r\n\t\t * FSBL.WorkspaceClient.addWorkspaceListeners();\r\n\t\t */\r\n\t\tthis.addWorkspaceListeners = function () {\r\n\t\t\tRouterClient.addListener('WorkspaceService.' + finWindow.name, function (err, response) {\r\n\t\t\t\tswitch (response.data.command) {\r\n\t\t\t\t\tcase 'close':\r\n\t\t\t\t\t\tself.close(false);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'bringToFront':\r\n\t\t\t\t\t\tfinWindow.isShowing(function (isShowing) {\r\n\t\t\t\t\t\t\tif (isShowing) {\r\n\t\t\t\t\t\t\t\tfinWindow.bringToFront(\r\n\t\t\t\t\t\t\t\t\tfunction () {\r\n\t\t\t\t\t\t\t\t\t\tconsole.debug('bringToFront successfull');\r\n\t\t\t\t\t\t\t\t\t}, function (err) {\r\n\t\t\t\t\t\t\t\t\tconsole.error('bringToFront failed: ' + err);\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'restore':\r\n\t\t\t\t\t\tfin.desktop.Window.getCurrent().restore(\r\n\t\t\t\t\t\t\tfunction () {\r\n\t\t\t\t\t\t\t\tconsole.debug('restore successfull');\r\n\t\t\t\t\t\t\t}, function (err) {\r\n\t\t\t\t\t\t\tconsole.error('restore failed: ' + err);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'move':\r\n\t\t\t\t\t\tfin.desktop.Window.getCurrent().animate(\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tposition: {\r\n\t\t\t\t\t\t\t\t\tleft: response.data.left,\r\n\t\t\t\t\t\t\t\t\ttop: response.data.top,\r\n\t\t\t\t\t\t\t\t\tduration: 250\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\tsize: {\r\n\t\t\t\t\t\t\t\t\twidth: response.data.width,\r\n\t\t\t\t\t\t\t\t\theight: response.data.height,\r\n\t\t\t\t\t\t\t\t\tduration: 250\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t{},\r\n\t\t\t\t\t\t\tfunction () {\r\n\t\t\t\t\t\t\t\tconsole.debug('successfully moved.');\r\n\t\t\t\t\t\t\t}, function (err) {\r\n\t\t\t\t\t\t\t\tconsole.error('Animate failed: ' + err);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Kicks off all of the necessary methods for the app. It\r\n\t\t * 1. Injects the header bar into the window.\r\n\t\t * 2. Sets up listeners to handle close and move requests from the appplication.\r\n\t\t * 3. Adds a listener that saves the window's state every time it's moved or resized.\r\n\t\t * @param {object} params\r\n\t\t * See the [WindowManager tutorial]{@tutorial windowManagerComponent} for more information.\r\n\t\t */\r\n\t\tthis.start = function (callback) {\r\n\t\t\tValidate.args(callback, \"function\");\r\n\t\t\tself.setInitialWindowState(function () {\r\n\t\t\t\tif (self.options.customData.FSBLHeader) {\r\n\t\t\t\t\tself.injectDOM();\r\n\t\t\t\t\tself.registerWithDockingManager();\r\n\t\t\t\t}\r\n\t\t\t\tself.addWorkspaceListeners();\r\n\t\t\t\tself.listenForBoundsChanged();\r\n\t\t\t\tif (callback) {\r\n\t\t\t\t\tcallback();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\t\r\n\t\tvar finWindow = fin.desktop.Window.getCurrent();\r\n\t\treturn self;\r\n\t};\r\n\t\r\n\tvar windowClient = new WindowClient({\r\n\t\tonReady: function (cb) {\r\n\t\t\tconsole.log(\"starting Window client\");\r\n\t\t\twindowClient.start(cb);\r\n\t\t},\r\n\t\tname: \"windowClient\"\r\n\t});\r\n\twindowClient.requiredServices = [\"workspaceService\", \"storageService\"];\r\n\t//windowClient.initialize();\r\n\t\r\n\tmodule.exports = windowClient;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RouterClient = __webpack_require__(4);\r\n\tvar BaseClient = __webpack_require__(11);\r\n\tvar Utils = __webpack_require__(1);\r\n\tvar console = new Utils.Console(\"BaseClient\"); // Finsemble console\r\n\tvar Validate = __webpack_require__(3); // Finsemble args validator\r\n\tvar WindowClient = __webpack_require__(14);\r\n\t/**\r\n\t * @introduction\r\n\t * ## WorkspaceClient\r\n\t * ----------\r\n\t * The workspace client manages all calls to load, save, rename, and delete workspaces. Before reading this, please check out [Understanding Workspaces]{@tutorial workspaces}.\r\n\t *\r\n\t * @constructor\r\n\t * @summary You don't need to ever invoke the constructor. This is done for you when WindowClient is added to the FSBL object.\r\n\t */\r\n\tfunction WorkspaceClient(params) {\r\n\t\tValidate.args(params, \"object=\") && params && Validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\t\t/** @alias WorkspaceClient# */\r\n\t\tBaseClient.call(this, params);\r\n\t\r\n\t\tvar self = this;\r\n\t\t//Whether the workspace differs from its source in storage.\r\n\t\tthis.workspaceIsDirty = false;\r\n\t\t//Where we'll keep a list of all of the available workspaces.\r\n\t\tthis.workspaces = [];\r\n\t\t//Where we'll store the activeWorkspace.\r\n\t\tthis.activeWorkspace = {};\r\n\t\t/**\r\n\t\t * Adds window to active workspace.\r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.name Window name\r\n\t\t * @param {function} cb Callback\r\n\t\t * @todo This function probably shouldn't even exist. Just make <code>addToWorkspace</code> a param in the windowDescriptor.\r\n\t\t * @example <caption>This method adds a window to a workspace. By default, spawning a window does not add it to the workspace. It is often used in conjunction with the {@link LauncherClient}.</caption>\r\n\t\t FSBL.LauncherClient.spawn({ windowDescriptor: windowDescriptor }, function (err, response) {\r\n\t\t\t\tif (windowDescriptor.addToWorkspace) {\r\n\t\t\t\t\tFSBL.WorkspaceClient.addWindow('AdvancedChart', response.data.name);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t */\r\n\t\tthis.addWindow = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && params && Validate.args2(\"params.name\", params.name, \"string\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tRouterClient.query('WorkspaceService.addWindow', params, cb);\r\n\t\t};\r\n\t\t/**\r\n\t\t * AutoArranges windows.\r\n\t\t * @param {function=} cb Callback\r\n\t\t * @example\r\n\t\t * FSBL.WorkspaceClient.autoArrange(null, function(err, response){\r\n\t\t * \t\t//do something after the autoarrange, maybe make all of the windows flash or notify the user that their monitor is now tidy.\r\n\t\t * });\r\n\t\t */\r\n\t\tthis.autoArrange = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && Validate.args2(\"params.monitorDimensions\", params.monitorDimensions, \"object\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tRouterClient.query('WorkspaceService.autoArrange', params, cb);\r\n\t\t};\r\n\t\t/**\r\n\t\t * Brings all windows to the front.\r\n\t\t * @param {object} params\r\n\t\t * @param {object} params.monitorDimensions The dimensions of the monitor where windows should be brought forward.\r\n\t\t * @param {function} [cb] Callback.\r\n\t\t * @todo rename to something like <code>bringToFront</code> and put the 'Only affects visible windows' bit in the documentation.\r\n\t\t * @example\r\n\t\t * FSBL.WorkspaceClient.bringWindowsToFront();\r\n\t\t */\r\n\t\tthis.bringWindowsToFront = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && Validate.args2(\"params.monitorDimensions\", params.monitorDimensions, \"object\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tif (!params) {\r\n\t\t\t\tparams = {\r\n\t\t\t\t\tmonitorDimensions: WindowClient.options.customData.monitorDimensions\r\n\t\t\t\t};\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tRouterClient.query('WorkspaceService.bringWindowsToFront', params, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Gets the currently active workspace.\r\n\t\t * @param {function} cb Callback\r\n\t\t * @example <caption>This function is useful for setting the initial state of a menu or dialog. It is used in the toolbar component to set the initial state.</caption>\r\n\t\t *\r\n\t\tFSBL.WorkspaceClient.getActiveWorkspace(function (err, response) {\r\n\t\t\t//setState is a React component method.\r\n\t\t\tself.setState({\r\n\t\t\t\tworkspaces: response.data\r\n\t\t\t});\r\n\t\t});\r\n\t\t */\r\n\t\tthis.getActiveWorkspace = function (cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\t\tRouterClient.query('WorkspaceService.getActiveWorkspace', null, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Returns the list of saved workspaces.\r\n\t\t * @param {function} cb Callback\r\n\t\t * @example <caption>This function is useful for setting the initial state of a menu or dialog.</caption>\r\n\t\t *\r\n\t\tFSBL.WorkspaceClient.getWorkspaces(function (err, response) {\r\n\t\t\t//setState is a React component method.\r\n\t\t\tself.setState({\r\n\t\t\t\tworkspaces: response.data\r\n\t\t\t});\r\n\t\t});\r\n\t\t */\r\n\t\tthis.getWorkspaces = function (cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\t\tRouterClient.query('WorkspaceService.getWorkspaces', null, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Removes a workspace. Either the workspace object or its name must be provided.\r\n\t\t * @param {object} params\r\n\t\t * @param {Boolean}\t[params.persist=false] Whether to persist the change.\r\n\t\t * @param {Object} \t[params.workspace] Workspace\r\n\t\t * @param {string} \t[params.name] Workspace Name\r\n\t\t * @param {function=} cb Callback to fire after 'WorkspaceService.update' is transmitted.\t \r\n\t\t * @example <caption>This function removes 'My Workspace' from the main menu and the default storage tied to the applicaton.</caption>\r\n\t\t * FSBL.WorkspaceClient.remove({\t \r\n\t\t\tname: 'My Workspace',\r\n\t\t\tpersist: true\r\n\t\t  }, function(err, response){\r\n\t\t \t\t//You typically won't do anything here. If you'd like to do something when a workspace change happens, we suggest listening on the `WorkspaceService.update` channel.\r\n\t\t  });\r\n\t\t */\r\n\t\r\n\t\tthis.remove = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && !(params.name || params.workspace) && Validate.args2(\"params.name\", params.name, \"string\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tvar defaultParams = {\r\n\t\t\t\tpersist: false,\r\n\t\t\t\tworkspace: null,\r\n\t\t\t\tname: null\r\n\t\t\t};\r\n\t\t\t//sets defaults for undefined params.\r\n\t\t\tparams.prototype = Object.create(defaultParams);\r\n\t\t\tRouterClient.query('WorkspaceService.remove', params, cb);\r\n\t\t};\r\n\t\t/**\r\n\t\t * Removes window from active workspace.\r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.name Window name\r\n\t\t * @param {function=} [cb] Callback\r\n\t\t * @example <caption>This method removes a window from a workspace. It is rarely called by the developer. It is called when a window that is using the window manager is closed. That way, the next time the app is loaded, that window is not spawned.</caption>\r\n\t\t *FSBL.WorkspaceClient.removeWindow({name:windowName}, function(err, response){\r\n\t\t\t //do something after removing the window.\r\n\t\t });\r\n\t\t */\r\n\t\tthis.removeWindow = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && Validate.args2(\"params.name\", params.name, \"string\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tRouterClient.query('WorkspaceService.removeWindow', params, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Renames the workspace with the provided name. Also removes all references in storage to the old workspace's name.\r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.oldName Name of workspace to rename.\r\n\t\t * @param {string} params.newName What to rename the workspace to.\r\n\t\t * @param {boolean=} [params.removeOldWorkspace=true] Whether to remove references to old workspace after renaming.\r\n\t\t * @param {boolean=} [params.overwriteExisting=false] Whether to overwrite an existing workspace.\r\n\t\t * @param {function=} cb Callback\t \r\n\t\t * @example <caption>This method is used to rename workspaces. It is used in the main Menu component.</caption>\r\n\t\t * FSBL.WorkspaceClient.rename({\t \r\n\t\t\toldName: 'My Workspace',\r\n\t\t\tnewName: 'The best workspace',\r\n\t\t\tremoveOldWorkspace: true,\r\n\t\t  }, function(err, response){\r\n\t\t \t\t//Do something.\r\n\t\t  });\r\n\t\t */\r\n\t\tthis.rename = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && Validate.args2(\"params.oldName\", params.oldName, \"string\", \"params.newName\", params.newName, \"string\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tif (!params.overwriteExisting && this.workspaceIsAlreadySaved(params.newName)) { \r\n\t\t\t\tcb(new Error('WorkspaceAlreadySaved'), params);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tRouterClient.query('WorkspaceService.rename', params, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Makes a clone of the workspace.\r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.name Name of workspace to clone.\t \r\n\t\t * @param {function} cb Callback\t \r\n\t\t * @example <caption>This method is used to clone workspaces. </caption>\r\n\t\t * FSBL.WorkspaceClient.clone({\t \t\t\r\n\t\t\tname: 'The best workspace'\r\n\t\t  }, function(err, response){\r\n\t\t \t\t//Do something.\r\n\t\t  });\r\n\t\t */\r\n\t\tthis.clone = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && Validate.args2(\"params.name\", params.name, \"string\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tRouterClient.query('WorkspaceService.clone', params, cb);\r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t * Saves the currently active workspace. It does not overwrite the saved instance of the workspace. It simply overwrites the <code>activeWorkspace</code> key in storage.\r\n\t\t * @param {function} cb Callback\r\n\t\t * @example\r\n\t\t * <caption>This function persists the currently active workspace.</caption>\r\n\t\t * FSBL.WorkspaceClient.save(function(err, response){\r\n\t\t \t\t//Do something.\r\n\t\t  });\r\n\t\t */\r\n\t\tthis.save = function (cb) {\r\n\t\t\tValidate.args(cb, \"function=\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\tRouterClient.query('WorkspaceService.save', null, cb);\r\n\t\t};\r\n\t\t/**\r\n\t\t * Helper that tells us whether a workspace is saved.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.workspaceIsAlreadySaved = function (workspaceName) {\r\n\t\t\tValidate.args(workspaceName, \"string\");\r\n\t\t\tvar savedWorkspaceIndex = -1;\r\n\t\t\tfor (var i = 0; i < self.workspaces.length; i++) {\r\n\t\t\t\tif (workspaceName === self.workspaces[i].name) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\t/**\r\n\t\t * \r\n\t\t * Saves the currently active workspace with the provided name. \r\n\t\t * @param {object} params\r\n\t\t * @param {string} params.name new name to save workspace under.\r\n\t\t * @param {string} [params.force=false] Whether to overwrite a workspace already saved with the provided name.\t \r\n\t\t * @param {function} cb Callback\r\n\t\t * @example <caption>This function persists the currently active workspace with the provided name.</caption>\r\n\t\t * FSBL.WorkspaceClient.saveAs({\t \r\n\t\t\tname: 'My Workspace',\t\t\r\n\t\t  }, function(err, response){\r\n\t\t \t\t//Do something.\r\n\t\t  });\r\n\t\t */\r\n\t\tthis.saveAs = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function=\") && Validate.args2(\"params.name\", params.name, \"string\");\r\n\t\t\tcb = cb || function noop() { }; // cb is optional but not for underlying query\r\n\t\t\t\r\n\t\t\tif (!params.force && this.workspaceIsAlreadySaved(params.name)) { \r\n\t\t\t\tcb(new Error('WorkspaceAlreadySaved'), null);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tRouterClient.query('WorkspaceService.saveAs', params, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Switches to a workspace. \r\n\t\t * @param {object} params\t \r\n\t\t * @param {string} \tparams.name Workspace Name\r\n\t\t * @param {function} cb Callback\r\n\t\t * @example <caption>This function loads the workspace 'My Workspace' from the storage tied to the application.</caption>\r\n\t\t * FSBL.WorkspaceClient.switchTo({\t \r\n\t\t\tname: 'My Workspace',\t\t\r\n\t\t  }, function(err, response){\r\n\t\t \t\t//Do something.\r\n\t\t  });\r\n\t\t */\r\n\t\tthis.switchTo = function (params, cb) {\r\n\t\t\tValidate.args(params, \"object\", cb, \"function\") && Validate.args2(\"params.name\", params.name, \"string\");\r\n\t\t\tRouterClient.query('WorkspaceService.switchTo', params, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Checks to see if the workspace is dirty. If it's already dirty, the window doesn't need to compare its state to the saved state.\r\n\t\t * @param {Function} cb Callback\r\n\t\t */\r\n\t\tthis.isWorkspaceDirty = function (cb) {\r\n\t\t\tValidate.args(cb, \"function\");\r\n\t\t\tRouterClient.query('WorkspaceService.isActiveWorkspaceDirty', null, cb);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Initializes listeners and sets default data on the WorkspaceClient object.\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.start = function(cb){\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Initializes the workspace's state.\r\n\t\t\t */\r\n\t\t\tRouterClient.addListener('WorkspaceService.update', function(err, response){\r\n\t\t\t\tself.workspaceIsDirty = response.data.activeWorkspace.isDirty;\r\n\t\t\t\tself.workspaces = response.data.workspaces;\r\n\t\t\t\tself.activeWorkspace = response.data.activeWorkspace;\r\n\t\t\t});\r\n\t\r\n\t\t\tself.getActiveWorkspace(function (err, response) {\r\n\t\t\t\tself.activeWorkspace = response.data;\r\n\t\t\t\tself.workspaceIsDirty = response.data.isDirty;\r\n\t\t\t\tself.getWorkspaces(function (err, response) {\r\n\t\t\t\t\tself.workspaces = response.data;\r\n\t\t\t\t\tcb();\r\n\t\t\t\t});\t\t\t\t\t\t\t\r\n\t\t\t});\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t};\r\n\t\treturn this;\r\n\t};\r\n\t\r\n\tvar workspaceClient = new WorkspaceClient({\r\n\t\tonReady: function (cb) {\r\n\t\t\tconsole.log(\"starting workspace client\");\r\n\t\t\tworkspaceClient.start(cb);\r\n\t\t},\r\n\t\tname: \"workspaceClient\"\r\n\t});\r\n\tworkspaceClient.requiredServices = [\"workspaceService\", \"storageService\"];\r\n\t//workspaceClient.initialize();\r\n\t\r\n\tmodule.exports = workspaceClient;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\r\n\t// Copyright 2012-2017 by ChartIQ, Inc\r\n\t// -------------------------------------------------------------------------------------------\r\n\t\r\n\t\"use strict\";\r\n\tvar RouterClient = __webpack_require__(4);\r\n\tvar LauncherClient = __webpack_require__(12);\r\n\tvar WindowClient = __webpack_require__(14);\r\n\tvar Utils = __webpack_require__(1);\r\n\tvar Validate =  __webpack_require__(3);\r\n\tvar console = new Utils.Console(\"DialogManager\"); // Finsemble console\r\n\tvar BaseClient = __webpack_require__(11);\r\n\t\r\n\t/**\r\n\t *\r\n\t * @introduction\r\n\t * <h2>Dialog Manager Client</h2>\r\n\t * This client interfaces to the Finsemble Diaglog Manager Service.\r\n\t *\r\n\t * Returns an instance of the DialogManagerClient, which spawns new user-dialog windows and receiving back a response.\r\n\t *\r\n\t * @param {object=} params optional parameters\r\n\t * @param {function=} params.onReady callback function indicating when client is ready\r\n\t * @param {string=} params.name client name for diagnostics/logging\r\n\t * @constructor\r\n\t *\r\n\t */\r\n\tvar DialogManagerClient = function (params) {\r\n\t\tValidate.args(params, \"object=\") && params && Validate.args2(\"params.onReady\", params.onReady, \"function=\");\r\n\t\r\n\t\tBaseClient.call(this, params);\r\n\t\t/////////////////////////////////////////////\r\n\t\t// Public Functions -- Dialog Parent Side\r\n\t\t/////////////////////////////////////////////\r\n\t\r\n\t\t/**\r\n\t\t * Spawns a Dialog window. \r\n\t\t * \r\n\t\t * @param {params} params the window descriptor representing a component or URL for the dialog\r\n\t\t * @param {object} inputParams parameters pass to dialog (using the event router) -- generally what is supported depends on dialog URL\r\n\t\t * @param {function} responseCallback called when response received back from dialog window (typically on dialog completion)\r\n\t\t *\r\n\t\t * @return dialogID can be used to kill a spawned dialog prematurely\r\n\t\t *\r\n\t\t * @todo support paramter to make the dialog modal\r\n\t\t */\r\n\t\tthis.spawnDialog = function (params, inputParams, dialogResponseCallback) {\r\n\t\t\tconsole.debug(\"spawning dialog\");\r\n\t\t\tValidate.args(params, \"object\", inputParams, \"object\", dialogResponseCallback, \"function\");\r\n\t\t\tvar componentName;\r\n\t\t\tvar responseChannel = Utils.getUniqueName(\"DialogChannel\");\r\n\t\t\tparams.customData = { inputParams, responseChannel: responseChannel };\r\n\t\t\tif (typeof params.name === \"undefined\") {\r\n\t\t\t\tparams.name = \"dialogTemplate\";\r\n\t\t\t}\t\t\t\t\r\n\t\t\tparams.customData.monitorDimensions = WindowClient.options.monitorDimensions;\r\n\t\t\tLauncherClient.spawn(params.name, { options: params }, function (err, response) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tdialogResponseCallback(err, response.data);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tRouterClient.addListener(responseChannel, function cb(err, response) {\r\n\t\t\t\t\t\tconsole.debug(\"dialogResponse: \" + JSON.stringify(response.data));\r\n\t\t\t\t\t\tdialogResponseCallback(err, response.data);\r\n\t\t\t\t\t\tRouterClient.removeListener(responseChannel, cb);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn 0;\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Cancels an active dialog prematurely (normally a dialog will terminal on completion, returning a response).\r\n\t\t * \r\n\t\t * @param {any} dialogID identifies dialog to be terminated\r\n\t\t *\r\n\t\t * @todo implement when launcher supports kill function\r\n\t\t */\r\n\t\tthis.killSpawnedDialog = function (dialogID) { };\r\n\t\r\n\t\t/////////////////////////////////////////////\r\n\t\t// Public Functions -- Dialog Client Side\r\n\t\t/////////////////////////////////////////////\r\n\t\r\n\t\t/**\r\n\t\t * Called within dialog to get the paramters passed in spawnDialog's \"inputParams\" \r\n\t\t * \r\n\t\t * @param {any} dialogID identifies dialog to be terminated\r\n\t\t *\r\n\t\t * @return {object} inputParams parameters pass to dialog \r\n\t\t */\t\r\n\t\tthis.getParamtersFromInDialog = function () {\r\n\t\t\tvar inputParams = WindowClient.options.customData.inputParams;\r\n\t\t\tconsole.debug(\"getParamtersFromInDialog: \" + JSON.stringify(inputParams));\r\n\t\t\treturn inputParams;\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Called within dialog to pass back dialog response and terminal window \r\n\t\t * \r\n\t\t * @param {any} responseParameters parameters returned to parent (i.e. window that spawned the dialog) \r\n\t\t *\r\n\t\t */\t\r\n\t\tthis.respondAndExitFromInDialog = function (responseParameters) {\r\n\t\t\tValidate.args(responseParameters, \"any\");\r\n\t\t\tconsole.debug(\"sendResponseFromInDialog: \" + JSON.stringify(responseParameters));\r\n\t\t\tvar responseChannel = WindowClient.options.customData.responseChannel;\r\n\t\t\tRouterClient.transmit(responseChannel, responseParameters);\r\n\t\t\tfin.desktop.Window.getCurrent().close(true);\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// instance of dialogManagerClient that is exported by this module\r\n\tvar dialogManagerClient = new DialogManagerClient({\r\n\t\tonReady: function (cb) {\r\n\t\t\tconsole.log(\"dialogClient online\");\r\n\t\t\tcb();\r\n\t\t},\r\n\t\tname: \"dialogManagerClient\"\r\n\t});\r\n\tdialogManagerClient.requiredServices = [\"launcherService\"]; // service required by this client\r\n\t//dialogManagerClient.initialize(); // intialize this client's base service\r\n\t\r\n\tmodule.exports = dialogManagerClient;\r\n\t\r\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=FSBL.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// C:/Users/BradC/git/finsemble/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}