{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 2fb38ae0695027d4c0a7","webpack:///./test/testService.js","webpack:///e:/nodeProjects/finsemble/libs/FrontEnd.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA,eAAc,O;AACd,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,GAAE;AACF,EAAC;;AAED;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA,wBAAuB;AACvB;AACA,wBAAuB;AACvB,uBAAsB;AACtB,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA,mBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB,mBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA,sGAAqG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,qBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,IAAI;AAClB,eAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,mBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ,IAAG;;AAEH;AACA;AACA,eAAc,IAAI;AAClB,cAAa,IAAI;AACjB,eAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAiE,8BAA8B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kDAAiD;;AAEjD,wCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA,sCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,mBAAmB,GAAG,gHAAgH;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,uDAAsD;AACtD,uCAAsC;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,6CAA4C;AAC5C,oBAAmB,gCAAgC;AACnD;AACA;AACA,4CAA2C,wBAAwB;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,mDAAkD;AAClD,yDAAwD;AACxD;AACA,yCAAwC;AACxC,MAAK;AACL;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,4CAA2C;AAC3C,MAAK;AACL;AACA,oEAAmE;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8EAA6E;AAC7E;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL,uEAAsE;AACtE;AACA,2DAA0D;AAC1D,OAAM;AACN;AACA,0GAAyG;AACzG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ,4DAA2D;AAC3D;AACA,8DAA6D;AAC7D,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA,qBAAoB,8BAA8B;AAClD;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ,4EAA2E;AAC3E;AACA,sDAAqD;AACrD,MAAK;AACL;AACA,2EAA0E;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,oDAAmD;AACnD,0CAAyC;AACzC,MAAK;AACL,gEAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK,QAAQ;AACb;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,8BAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA,gE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,mBAAmB,GAAG,gHAAgH;AACrL;AACA;AACA;AACA,gDAA+C,mBAAmB;AAClE;AACA;AACA;AACA,iDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK,QAAQ;AACb;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD,mDAAkD;AAClD;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C;AAC9C,mDAAkD;AAClD,mDAAkD;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA6C;AAC7C;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qDAAoD;;AAEpD,uBAAsB;AACtB;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB;;AAEtB;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAAyC;AACzC;AACA,qCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA,sEAAqE;;AAErE;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,2CAA2C;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA,iEAAgE;;AAEhE;AACA;AACA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA,sGAAqG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE3Q;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,KAAK;AAClB,cAAa,QAAQ;AACrB,eAAc,QAAQ,yCAAyC;AAC/D;AACA;AACA;AACA,2C;AACA;AACA;AACA,8DAA6D;AAC7D;AACA,0DAAyD;AACzD;AACA,2GAA0G;AAC1G;AACA,0FAAyF;AACzF;AACA,8EAA6E;AAC7E,4B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC,qBAAoB,eAAe;AACnC;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA,8CAA6C;AAC7C,+DAA8D;AAC9D,yEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,eAAc,QAAQ,yCAAyC;AAC/D;AACA;AACA;AACA,iD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC;AACpC,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA,8CAA6C;AAC7C,+DAA8D;AAC9D,yEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ,sBAAqB;AACrB;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA,mDAAkD;AAClD,wCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,sDAAsD;AAClG;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,uCAAuC;AAClF;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,yCAAyC;AAC5F;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,uCAAuC;AACrF;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA,gDAA+C;AAC/C,wCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,kCAAkC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+CAA8C;AAC9C,wCAAuC;AACvC;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ,yKAAyK,wBAAwB;AACxN,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA,+BAA8B,UAAU;AACxC,yBAAwB,QAAQ;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA,oB;AACA;AACA;AACA;AACA,KAAI;AACJ,OAAM;AACN;AACA;AACA;;AAEA,mDAAkD;AAClD;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,8JAA6J,0BAA0B;AACvL,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;AACJ;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,0DAAyD;AACzD;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,EAAC;AACD;AACA,qC","file":"test/testService.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2fb38ae0695027d4c0a7","var Finsemble = require('finsemble/libs/FrontEnd.js');\r\nvar baseService = Finsemble.baseService;\r\n\r\n/**\r\n * @namespace\r\n * @property {Object} \r\n * @property {string}\r\n */\r\nfunction TestService() {\r\n\tvar self = this;\r\n\r\n\tthis.initialize = function (cb) {\r\n\t\tcb();\r\n\t};\r\n\r\n};\r\n\r\nTestService.prototype = new baseService();\r\nvar testService = new TestService(\"TestService\");\r\n\r\n\r\ntestService.setOnConnectionComplete(function (callback) {\r\n\ttestService.initialize(function () {\r\n\t\tcallback();\r\n\t});\r\n});\r\n\r\ntestService.start();\r\nwindow.testService = testService;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./test/testService.js\n// module id = 0\n// module chunks = 0","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FrontEnd\"] = factory();\n\telse\n\t\troot[\"FrontEnd\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = {\n\t\tbaseService: __webpack_require__(1),\n\t\tClients: {\n\t\t\tRouterClient: __webpack_require__(3),\n\t\t\tStorageClient: __webpack_require__(9),\n\t\t\tlauncherClient: __webpack_require__(11)\n\t\t}\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t// -------------------------------------------------------------------------------------------\n\t// Copyright 2012-2017 by ChartIQ, Inc\n\t// -------------------------------------------------------------------------------------------\n\t\n\t// This file contains the Fensemble router service, which routes event messages between \n\t// other services and components.  All event messages flow though here (never peer to peer).\n\t\n\tvar FSBLUtils = __webpack_require__(2);\n\tvar serviceObj = function serviceObj(params) {\n\t\tif (params) {\n\t\t\tthis.name = params[0];\n\t\t}\n\t\tvar self = this;\n\t\tthis.name = name;\n\t\tthis.servicesNeeded = [\"routerService\"]; // All the services that are required before the connection to the service manager is complete.\n\t\tthis.onlineServices = [];\n\t\tthis.__parent = null; //Should be service manager\n\t\tthis.clients = [];\n\t\tthis.beforeEach = []; //A list of fucntions that are called before every message\n\t\tthis.afterEach = []; //A list of fucntions that are called after every message\n\t\tthis.status = \"offline\"; //The services status\n\t\tthis.onConnectionComplete = null;\n\t\t//Turn the the service online. This only happens when all servicesNeeded are online.\n\t\t//Also, the online is only sent to the parent once all of the 'onConnectionComplete' functions are complete\n\t\tthis.setOnline = function () {\n\t\t\tif (self.servicesNeeded.length === 0 && self.status !== \"online\") {\n\t\t\t\tif (self.onConnectionComplete) {\n\t\t\t\t\treturn self.onConnectionComplete(function () {\n\t\t\t\t\t\tself.status = \"online\";\n\t\t\t\t\t\tself.sendOnlineToParent();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tself.status = \"online\";\n\t\t\t\tself.sendOnlineToParent();\n\t\t\t}\n\t\t};\n\t\tthis.setOnConnectionComplete = function (func) {\n\t\t\tself.onConnectionComplete = func;\n\t\t};\n\t\t//Add a function to be processed before every message\n\t\tthis.addBefore = function (func) {\n\t\t\tif (typeof func === \"function\") {\n\t\t\t\tthis.beforeEach.push(func);\n\t\t\t}\n\t\t};\n\t\t//Add a function to be processed after every message\n\t\tthis.addAfter = function (func) {\n\t\t\tif (typeof func === \"function\") {\n\t\t\t\tthis.afterEach.push(func);\n\t\t\t}\n\t\t};\n\t\t//Add a service to services needed list. This service will wait for all services in this list to be complete.\n\t\tthis.addNeededServices = function (services) {\n\t\t\tif (!Array.isArray(services)) {\n\t\t\t\tservices = [services];\n\t\t\t}\n\t\t\tfor (var i = 0; i < services.length; i++) {\n\t\t\t\tif (this.servicesNeeded.indexOf(services[i]) === -1) {\n\t\t\t\t\tthis.servicesNeeded.push(services[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t//Clear the services needed list\n\t\tthis.clearServicesNeeded = function () {\n\t\t\tthis.servicesNeeded = [];\n\t\t};\n\t\t//Check to see if services are online and remove them from the services needed if they are \n\t\tthis.checkServicesNeeded = function () {\n\t\t\tfor (var i = 0; i < self.servicesNeeded.length; i++) {\n\t\t\t\tif (self.onlineServices.indexOf(self.servicesNeeded[i]) > -1) {\n\t\t\t\t\tself.servicesNeeded.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.setOnline();\n\t\t};\n\t\t//Base listeners\n\t\tthis.listeners = {\n\t\t\tserviceOnline: [function (msg) {\n\t\t\t\tself.onlineServices.push(msg.payload);\n\t\t\t\tif (self.servicesNeeded.length > 0) {\n\t\t\t\t\tself.checkServicesNeeded();\n\t\t\t\t};\n\t\t\t}],\n\t\t\tserviceList: [function (msg) {\n\t\t\t\tself.onlineServices = msg.payload;\n\t\t\t\tif (self.servicesNeeded.length > 0) {\n\t\t\t\t\tself.checkServicesNeeded();\n\t\t\t\t};\n\t\t\t}],\n\t\t\twindowConnect: [function (msg) {\n\t\t\t\tself.sendHandShake();\n\t\t\t}],\n\t\t\tonConnectionComplete: []\n\t\t};\n\t};\n\t//Processes all messages\n\tserviceObj.prototype.receiveMessage = function (msg) {\n\t\tfor (var i = 0; i < this.beforeEach.length; i++) {\n\t\t\tthis.beforeEach[i](msg);\n\t\t}\n\t\tvar eventName = msg.name;\n\t\tif (eventName && this.listeners[eventName].length > 0) {\n\t\t\tfor (var i = 0; i < this.listeners[eventName].length; i++) {\n\t\t\t\tif (typeof this.listeners[eventName][i] === \"function\") {\n\t\t\t\t\tthis.listeners[eventName][i](msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < this.afterEach.length; i++) {\n\t\t\tthis.afterEach[i](msg);\n\t\t}\n\t};\n\t//Listen for a new message type\n\tserviceObj.prototype.addListener = function (eventName, cb) {\n\t\tif (!this.listeners[eventName]) {\n\t\t\tthis.listeners[eventName] = [];\n\t\t}\n\t\tthis.listeners[eventName].push(cb);\n\t};\n\t//remove a listener\n\tserviceObj.prototype.removeListener = function (eventName, func) {\n\t\tif (this.listeners[eventName] && this.listeners[eventName].length > 0) {\n\t\t\tfor (var i = 0; i < this.listeners[eventName].length; i++) {\n\t\t\t\tif (this.listeners[eventName][i] === func) {\n\t\t\t\t\tthis.listeners[eventName].splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t//log a message to the parent.\n\tserviceObj.prototype.log = function (message) {\n\t\tvar msg = new FSBLUtils.msgWrapper('debug', JSON.stringify(message));\n\t\tthis.sendToParent(msg);\n\t};\n\t//Broadcast a message to all connected clients.\n\tserviceObj.prototype.broadcast = function (message) {\n\t\n\t\tif (this.route) {} else {\n\t\t\tfor (var i = 0; i < this.clients.length; i++) {\n\t\t\t\tport = this.clients[i];\n\t\t\t\tport.postMessage(message);\n\t\t\t}\n\t\t}\n\t};\n\t//Send a message to the parent\n\tserviceObj.prototype.sendToParent = function (message) {\n\t\tmessage.location = this.name;\n\t\tif (typeof window !== 'undefined') {\n\t\t\tif (!this.__parent) {\n\t\t\t\tthis.__parent = window.opener;\n\t\t\t}\n\t\t\treturn this.__parent.postMessage(message, \"*\");\n\t\t}\n\t\tthis.__parent.postMessage(message);\n\t};\n\t//Set this service online\n\tserviceObj.prototype.sendOnlineToParent = function () {\n\t\tvar msg = new FSBLUtils.msgWrapper(\"online\", {\n\t\t\tstatus: true\n\t\t});\n\t\tthis.sendToParent(msg);\n\t};\n\t//Tell the parent that this service received the connection\n\tserviceObj.prototype.sendHandShake = function () {\n\t\tvar msg = new FSBLUtils.msgWrapper(\"handshake\", {\n\t\t\tstatus: true\n\t\t});\n\t\tvar self = this;\n\t\tthis.sendToParent(msg);\n\t\tif (this.servicesNeeded.length > 0) {\n\t\t\tthis.getActiveServiceList();\n\t\t} else {\n\t\t\tthis.setOnline();\n\t\t}\n\t};\n\t//Get a list of all active services\n\tserviceObj.prototype.getActiveServiceList = function () {\n\t\tvar msg = new FSBLUtils.msgWrapper(\"getActiveServices\");\n\t\tthis.sendToParent(msg);\n\t};\n\t//Start this service.\n\tserviceObj.prototype.start = function () {\n\t\tvar service = this;\n\t\tif (typeof window !== 'undefined') {\n\t\t\twindow.addEventListener(\"message\", function (msg) {\n\t\t\t\tservice.receiveMessage(msg.data);\n\t\t\t});\n\t\n\t\t\tthis.__parent = window.opener;\n\t\t} else {\n\t\t\tself.onerror = function (e) {\n\t\t\t\tvar msg = new FSBLUtils.msgWrapper(\"debug\", e);\n\t\t\t\tservice.sendToParent(msg);\n\t\t\t};\n\t\n\t\t\tself.onconnect = function (e) {\n\t\t\t\tvar port = e.ports[0];\n\t\t\t\tservice.clients.push(port);\n\t\n\t\t\t\tport.onmessage = function (msg) {\n\t\t\t\t\tservice.receiveMessage(msg.data);\n\t\t\t\t};\n\t\t\t\tif (service.clients.length === 1) {\n\t\t\t\t\tservice.__parent = port;\n\t\t\t\t\tservice.sendHandShake();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\t\n\tmodule.exports = serviceObj;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tmodule.exports = {\n\t\t/**\r\n\t  * @introduction\r\n\t  * <h2>Finsemble Utility Functions</h2>\r\n\t  * \r\n\t  * @class Utils\r\n\t  */\n\t\n\t\tretrieveMonitorDimensions: function retrieveMonitorDimensions(callback) {\n\t\t\tvar dims = {};\n\t\t\tthis.getMonitorInfo().then(function (monitorInfo) {\n\t\t\t\tvar availableMonitors = [monitorInfo.primaryMonitor].concat(monitorInfo.nonPrimaryMonitors);\n\t\t\t\tfin.desktop.Window.getCurrent().getBounds(function (bounds) {\n\t\t\t\t\tdims.defaultLeft = bounds.left;\n\t\t\t\t\tdims.defaultTop = bounds.top;\n\t\t\t\t\tfindMonitor();\n\t\t\t\t});\n\t\t\t\tfunction findMonitor() {\n\t\t\t\t\tfor (var i = 0; i < availableMonitors.length; i++) {\n\t\t\t\t\t\tvar monitor = availableMonitors[i].availableRect;\n\t\t\t\t\t\tmonitor.width = monitor.right - monitor.left;\n\t\t\t\t\t\tmonitor.height = monitor.bottom - monitor.top;\n\t\t\t\t\t\tif (dims.defaultLeft >= monitor.left && dims.defaultLeft <= monitor.right) {\n\t\t\t\t\t\t\tdims.monitorDimensions = monitor;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback(null, dims);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/**\r\n\t * finsemble console for displaying diagnostic messages (a transparent replacement for window.console)\r\n\t * @param {string} name prefix for all console output\r\n\t * @memberof Utils\r\n\t * @constructor\r\n\t */\n\t\tConsole: function Console(name) {\n\t\t\tvar schema = \"FSBL-Console\";\n\t\t\tvar consoleName;\n\t\t\tvar currentLevel = 2;\n\t\n\t\t\t/**\r\n\t   * gets console display level -- the higher the number the more is displayed \r\n\t   * @returns level\r\n\t   */\n\t\t\tthis.getLevel = function () {\n\t\t\t\treturn currentLevel;\n\t\t\t};\n\t\n\t\t\t/**\r\n\t   * sets console display level -- the higher the number the more is displayed \r\n\t   * @default \"4\"\r\n\t   * @param {number} newLevel: the new display level\r\n\t   */\n\t\t\tthis.setLevel = function (newLevel) {\n\t\t\t\tcurrentLevel = newLevel;\n\t\t\t};\n\t\n\t\t\t/**\r\n\t   * outputs to console an error message (level == 1)\r\n\t   * \r\n\t   * @param {any} message: error message to display\r\n\t   */\n\t\t\tthis.error = function (message) {\n\t\t\t\tvar myLevel = 1;\n\t\t\t\tif (myLevel <= currentLevel) {\n\t\t\t\t\tvar theMessage = consoleName + \" Error \" + new Date().toTimeString() + ': ' + message;\n\t\t\t\t\twindow.console.error(theMessage);\n\t\t\t\t\tfin.desktop.System.log('error', theMessage);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t/**\r\n\t   * outputs to console a warning message (level == 2)\r\n\t   * \r\n\t   * @param {any} message\r\n\t   */\n\t\t\tthis.warn = function (message) {\n\t\t\t\tvar myLevel = 2;\n\t\t\t\tif (myLevel <= currentLevel) {\n\t\t\t\t\tvar theMessage = consoleName + \" Warning \" + new Date().toTimeString() + ': ' + message;\n\t\t\t\t\twindow.console.warn(theMessage);\n\t\t\t\t\tfin.desktop.System.log('warning', theMessage);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t/**\r\n\t   * outputs to console a info message (level == 3)\r\n\t   * \r\n\t   * @param {any} message\r\n\t   */\n\t\t\tthis.info = function (message) {\n\t\t\t\tvar myLevel = 3;\n\t\t\t\tif (myLevel <= currentLevel) {\n\t\t\t\t\tvar theMessage = consoleName + \" Info \" + new Date().toTimeString() + ': ' + message;\n\t\t\t\t\twindow.console.info(theMessage);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t/**\r\n\t   * outputs to console a info message (level == 3)\r\n\t   * \r\n\t   * @param {any} message\r\n\t   */\n\t\t\tthis.log = function (message) {\n\t\t\t\tvar myLevel = 3;\n\t\t\t\tif (myLevel <= currentLevel) {\n\t\t\t\t\tvar theMessage = consoleName + \" Log \" + new Date().toTimeString() + ': ' + message;\n\t\t\t\t\twindow.console.info(theMessage);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t/**\r\n\t   * outputs to console a debug message (level == 4+)\r\n\t   * \r\n\t   * @param {any} message\r\n\t   * @param {any} level\r\n\t   */\n\t\t\tthis.debug = function (message, level) {\n\t\t\t\tvar myLevel = parseInt(level, 10) || 4;\n\t\t\t\tif (myLevel <= currentLevel) {\n\t\t\t\t\tvar theMessage = consoleName + \" Debug: \" + message + \" (timestamp \" + Math.round(window.performance.now() * 1000) / 1000 + ')';\n\t\t\t\t\twindow.console.debug(theMessage);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tconsoleName = name;\n\t\t},\n\t\n\t\t/**\r\n\t  * @param {any} name\r\n\t  * @param {any} payload\r\n\t  * @memberof Utils\r\n\t  */\n\t\tmsgWrapper: function msgWrapper(name, payload) {\n\t\t\tthis.name = name;\n\t\t\tthis.payload = payload;\n\t\t},\n\t\n\t\tmonitorInfo: null,\n\t\t/**\r\n\t  * returns monitor infor\r\n\t  * \r\n\t  * @param {any} force\r\n\t  * @returns object\r\n\t  */\n\t\tgetMonitorInfo: function getMonitorInfo(force) {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\t\tmodule.exports.monitorInfo = monitorInfo;\n\t\t\t\t\tresolve(monitorInfo);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\n\t\t/**\r\n\t  * get the dimensions of a monitor \r\n\t  * \r\n\t  * @returns height and weight\r\n\t  * @memberof Utils\r\n\t  */\n\t\tgetMonitorDimensions: function getMonitorDimensions() {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tvar monitorDimensions = {\n\t\t\t\t\theight: null,\n\t\t\t\t\twidth: null\n\t\n\t\t\t\t};\n\t\t\t\tconsole.log('getting data');\n\t\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\t\tconsole.log('got monitorInfo');\n\t\t\t\t\t//top bar is 45..\n\t\t\t\t\tmonitorDimensions.height = monitorInfo.primaryMonitor.availableRect.bottom - monitorInfo.primaryMonitor.availableRect.top - 32;\n\t\t\t\t\tmonitorDimensions.width = monitorInfo.primaryMonitor.availableRect.right;\n\t\t\t\t\tmonitorDimensions.left = monitorInfo.primaryMonitor.availableRect.left;\n\t\t\t\t\tmonitorDimensions.top = monitorInfo.primaryMonitor.availableRect.top;\n\t\t\t\t\tresolve(monitorDimensions);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\n\t\tgetMyMonitorDimensions: function getMyMonitorDimensions(windowBounds) {\n\t\t\t//returns the dimensions of the monitor that the window is on.\n\t\t\t//@todo: this.\n\t\t},\n\t\n\t\t/**\t \r\n\t  *\t@returns {string} Transforms an array of strings into a camelcased string.\r\n\t  * @memberof Utils\r\n\t  */\n\t\tcamelCase: function camelCase() {\n\t\t\tvar str = '';\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tstr += ' ' + arguments[i];\n\t\t\t}\n\t\t\treturn str.replace(/\\s(.)/g, function ($1) {\n\t\t\t\treturn $1.toUpperCase();\n\t\t\t}).replace(/\\s/g, '').replace(/^(.)/, function ($1) {\n\t\t\t\treturn $1.toLowerCase();\n\t\t\t});\n\t\t},\n\t\n\t\t/**\r\n\t  * Convenience method for cloning an object.\r\n\t  * @param  {any} from The thing you want to copy\r\n\t  * @param {any} to Where you want your copy to end up.\r\n\t  * @return {any} to Where you want your copy to end up.\r\n\t  */\n\t\tclone: function clone(from, to) {\n\t\t\tif (from === null || (typeof from === \"undefined\" ? \"undefined\" : _typeof(from)) !== \"object\") {\n\t\t\t\treturn from;\n\t\t\t}\n\t\t\t// if (from.constructor != Object && from.constructor != Array) return from;\n\t\t\tif (from.constructor == Date || from.constructor == RegExp || from.constructor == Function || from.constructor == String || from.constructor == Number || from.constructor == Boolean) {\n\t\t\t\treturn new from.constructor(from);\n\t\t\t}\n\t\n\t\t\tto = to || new from.constructor();\n\t\n\t\t\tfor (var n in from) {\n\t\t\t\tto[n] = typeof to[n] === \"undefined\" ? module.exports.clone(from[n], null) : to[n];\n\t\t\t}\n\t\n\t\t\treturn to;\n\t\t},\n\t\n\t\tgetUniqueName: function getUniqueName(baseName) {\n\t\t\tif (!baseName) {\n\t\t\t\tbaseName = \"RouterClient\";\n\t\t\t}\n\t\t\tvar uuid = baseName + \".\" + Math.floor(Math.random() * 10000) + Math.floor(Math.random() * 10000);\n\t\t\treturn uuid;\n\t\t}\n\t\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\n\t// Copyright 2012-2017 by ChartIQ, Inc\n\t// -------------------------------------------------------------------------------------------\n\t\n\t/**\r\n\t * @introduction\r\n\t * <h2>Router Client Instance</h2>\r\n\t * Exports a single shared instance of the router client.  See {@link RouterClientConstructor} for the complete API definition with examples.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *\t// get a shared instance of RouterClient (shared within the containing component or service)\r\n\t *\tvar RouterClient = require('./routerClientInstance');\r\n\t *\r\n\t * @namespace RouterClientInstance\r\n\t * @shouldBePublished false\r\n\t */\n\t\n\t\"use strict\";\n\t\n\tvar RouterClientConstructor = __webpack_require__(4);\n\t\n\tmodule.exports = new RouterClientConstructor(\"RouterSingleton\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\n\t// Copyright 2012-2017 by ChartIQ, Inc\n\t// -------------------------------------------------------------------------------------------\n\t\n\t\"use strict\";\n\t\n\tvar RouterTransport = __webpack_require__(5);\n\tvar Utils = __webpack_require__(2);\n\tvar console = new Utils.Console(\"RouterClient\"); // Finsemble console\n\t\n\tvar Validate = __webpack_require__(8); // Finsemble args validator\n\tvar validate = new Validate(console);\n\t\n\t/**\r\n\t * @introduction\r\n\t * <h2>Router Client Constructor</h2>\r\n\t * This modules contains the RouterClient for sending and receiving events between Finsembe components and services. The constructor returns one instance\r\n\t * of a router client. The related {@link RouterClientInstance} Module behaves like a RouteClient singleton, always returning the same instance\r\n\t * of the router client (within the same component/service window).\r\n\t *\r\n\t * The router client interfaces to the Finsemble router service, which routes event messages between all clients. Although it's transparent, the router uses the <a href=\"http://cdn.openfin.co/jsdocs/stable/fin.desktop.module_InterApplicationBus.html\">OpenFin Bus</a> and SharedWorker threads for transporting events between clients. \r\n\t *\r\n\t * More examples are shown in the <a href=tutorial-eventRouter.html>Event Router Tutorial</a>.\r\n\t *\r\n\t * @example\r\n\t *\r\n\t * // create an instance of Router Client\r\n\t * RouterClientConstructor = require('./routerClientConstructor');\r\n\t * RouterClient = new RouterClientConstructor(\"clientname\");\r\n\t *\r\n\t * // add a listener for incoming event on the specified channel\r\n\t * RouterClient.addListener(\"myListenChannel\",eventHandler);\r\n\t * //\r\n\t * // transmit event to all listeners on specified channel\r\n\t * RouterClient.transmit(\"myListenChannel\", transmitEvent);\r\n\t * \r\n\t * // add server for incoming events on the specified channel\r\n\t * RouterClient.addServer(\"myServerChannel\",eventHandler);\r\n\t *\r\n\t * // query the server on the specified channel\r\n\t * RouterClient.query(\"myServerChannel\",queryEvent, responseEventHandler);\r\n\t *\r\n\t * // create Subscribe-Publish server for specified topic\r\n\t * RouterClient.addPubSubServer(\"myTopic\");\r\n\t *\r\n\t * // create Subscribe-Publish server for specified wildcard topic (i.g. using RegEx), specifiying all the optional callback\r\n\t * RouterClient.addPubSubServer(\\/topicA*\\/, { \"State\": \"start\" }, { subscribeCallback:subscribeCallback, publishCallback:publishCallback, unsubscribeCallback:unsubscribeCallback } );\r\n\t *\r\n\t * // subscribe to the specified PubSub server for specified topic\r\n\t * RouterClient.subscribe(\"myTopic\",notifyEventHandler);\r\n\t *\r\n\t * // publish to the specified PubSub server for specified topic\r\n\t * RouterClient.publish(\"myTopic\",publishEvent);\r\n\t *\r\n\t * @constructor\r\n\t * @publishedName RouterClient\r\n\t * @param {string} thisClientName router client name for human readable messages\r\n\t * @param {string} transportName router transport name (usually this is autoconfigured internally but can be selected for testing or special configurations)\r\n\t */\n\tvar RouterClientConstructor = function RouterClientConstructor(thisClientName, transportName) {\n\t\tvalidate.args(thisClientName, \"string\", transportName, \"string=\");\n\t\n\t\t///////////////////////////\n\t\t// Private Data\n\t\t///////////////////////////\t\n\t\tvar mapListeners = {};\n\t\tvar mapServers = {};\n\t\tvar mapPubSubServers = {};\n\t\tvar mapPubSubServerState = {};\n\t\tvar mapPubSubServerRegEx = {};\n\t\tvar pubsubListOfSubscribers = {};\n\t\tvar mapSubscribersID = {};\n\t\tvar mapSubscribersTopic = {};\n\t\tvar mapQueryResponses = {};\n\t\tvar clientIDCounter = 1000;\n\t\tvar clientName;\n\t\tvar transport;\n\t\tvar self = this;\n\t\n\t\t/////////////////////////////////////////////////////////////////////\n\t\t// Private Message Contructors for Communicating with RouterService\n\t\t/////////////////////////////////////////////////////////////////////\n\t\tfunction AddListenerMessage(channel) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"addListener\",\n\t\t\t\t\"channel\": channel\n\t\t\t};\n\t\t}\n\t\tfunction TransmitMessage(toChannel, data) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"transmit\",\n\t\t\t\t\"channel\": toChannel\n\t\t\t};\n\t\t\tthis.data = data;\n\t\t}\n\t\tfunction RemoveListenerMessage(channel) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"removeListener\",\n\t\t\t\t\"channel\": channel\n\t\t\t};\n\t\t}\n\t\tfunction AddServerMessage(channel) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"addServer\",\n\t\t\t\t\"channel\": channel\n\t\t\t};\n\t\t}\n\t\tfunction QueryMessage(queryID, channel, data) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"query\",\n\t\t\t\t\"queryID\": queryID,\n\t\t\t\t\"channel\": channel\n\t\t\t};\n\t\t\tthis.data = data;\n\t\t}\n\t\tfunction QueryResponseMessage(queryID, error, data) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"queryResponse\",\n\t\t\t\t\"queryID\": queryID,\n\t\t\t\t\"error\": error\n\t\t\t};\n\t\t\tthis.data = data;\n\t\t}\n\t\tfunction RemoveServerMessage(channel) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"removeServer\",\n\t\t\t\t\"channel\": channel\n\t\t\t};\n\t\t}\n\t\tfunction SubscribeMessage(subscribeID, topic) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"subscribe\",\n\t\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\t\"topic\": topic\n\t\t\t};\n\t\t}\n\t\tfunction UnsubscribeMessage(subscribeID, topic) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"unsubscribe\",\n\t\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\t\"topic\": topic\n\t\t\t};\n\t\t}\n\t\tfunction PublishMessage(topic, data) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"publish\",\n\t\t\t\t\"topic\": topic\n\t\t\t};\n\t\t\tthis.data = data;\n\t\t}\n\t\tfunction NotifyMessage(subscribeID, topic, error, data) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"notify\",\n\t\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\t\"topic\": topic,\n\t\t\t\t\"error\": error\n\t\t\t};\n\t\t\tthis.data = data;\n\t\t}\n\t\tfunction AddPubSubServerMessage(topic) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"addPubSubServer\",\n\t\t\t\t\"topic\": topic\n\t\t\t};\n\t\t}\n\t\tfunction RemovePubSubServerMessage(topic) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"removePubSubServer\",\n\t\t\t\t\"topic\": topic\n\t\t\t};\n\t\t}\n\t\tfunction JoinGroupMessage(group) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"joinGroup\",\n\t\t\t\t\"group\": group\n\t\t\t};\n\t\t}\n\t\tfunction LeaveGroupMessage(group) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"leaveGroup\",\n\t\t\t\t\"group\": group\n\t\t\t};\n\t\t}\n\t\tfunction GroupTransmitMessage(group, toChannel, message, data) {\n\t\t\tthis.header = {\n\t\t\t\t\"origin\": clientName,\n\t\t\t\t\"type\": \"groupTransmit\",\n\t\t\t\t\"group\": group,\n\t\t\t\t\"channel\": toChannel\n\t\t\t};\n\t\t\tthis.data = data;\n\t\t}\n\t\n\t\t//////////////////////\n\t\t// Private Functions\n\t\t//////////////////////\n\t\n\t\t// router client is being terminated so cleanup\t\n\t\tfunction destructor(event) {\n\t\t\tconsole.info(\"shutting down on event: \" + JSON.stringify(event));\n\t\t\tself.disconnectAll(); // this will let the router know the client is terminating\n\t\t\tconsole.debug(\"shutting down complete\");\n\t\t}\n\t\n\t\t// called once on router-client creation\n\t\tfunction constructor(thisClientName, transportName) {\n\t\t\tclientName = Utils.getUniqueName(thisClientName);\n\t\n\t\t\tif (typeof transportName === 'undefined') {\n\t\t\t\ttransport = RouterTransport.getRecommendedTransport(incomingMessageHandler, clientName, \"RouterService\");\n\t\t\t} else {\n\t\t\t\ttransport = RouterTransport.getTransport(transportName, incomingMessageHandler, clientName, \"RouterService\");\n\t\t\t}\n\t\n\t\t\t// catch \"window closing\" event so can cleanup\t\n\t\t\tvar finWindow = fin.desktop.Window.getCurrent();\n\t\t\t//finWindow.addEventListener(\"closed\", destructor); // this is the correct event to catch but currently doesn't work on mac\n\t\t\twindow.onbeforeunload = destructor; // this works for mac\n\t\n\t\t\tconsole.info(\"starting \" + clientName + \" with transport \" + transport.identifier());\n\t\t}\n\t\n\t\t// provides unique id within one router client for queries\n\t\tfunction clientID() {\n\t\t\treturn clientName + \".\" + ++clientIDCounter;\n\t\t}\n\t\n\t\t// returns true if this routerClient originated the message\n\t\tfunction originatedHere() {\n\t\t\treturn this.header.origin === this.header.lastClient;\n\t\t}\n\t\n\t\t// invoke client callbacks in the input array (that are attached to a specific channel and listener type) \n\t\tfunction invokeListenerCallbacks(map, message) {\n\t\t\tvar clientCallbackArray = map[message.header.channel];\n\t\t\tif (clientCallbackArray === undefined) {\n\t\t\t\tconsole.warn(\"no handler defined for incoming message\" + JSON.stringify(message));\n\t\t\t} else {\n\t\t\t\tmessage.originatedHere = originatedHere; // add local function to test origin\n\t\t\t\tfor (var i = 0; i < clientCallbackArray.length; i++) {\n\t\t\t\t\t// for each callback defined for the channel\n\t\t\t\t\tconsole.debug(\"invoke listener callback for incoming transmit: \" + JSON.stringify(message));\n\t\t\t\t\tclientCallbackArray[i](null, message); // invoke the callback; the error parameter is always null for this case\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction sendQueryResponse(err, responseData) {\n\t\t\tconsole.debug(\"send query response: \" + JSON.stringify(responseData));\n\t\t\tsendToRouterService(new QueryResponseMessage(this.header.queryID, err, responseData));\n\t\t}\n\t\n\t\t// invoke server-listener callback (attached to a specific channel) \n\t\tfunction invokeServerCallback(map, queryMessage) {\n\t\t\tvar serverCallback = map[queryMessage.header.channel];\n\t\t\tif (serverCallback === undefined) {\n\t\t\t\tconsole.warn(2, \"no server defined for incoming query message: \" + JSON.stringify(queryMessage));\n\t\t\t} else {\n\t\t\t\tif (!queryMessage.header.error) {\n\t\t\t\t\tqueryMessage.originatedHere = originatedHere; // add local function to test origin\n\t\t\t\t\tqueryMessage.sendQueryResponse = sendQueryResponse; // add callback function to message so server can respond to query\n\t\t\t\t\tconsole.debug(\"invoke server callback for incoming query: \" + JSON.stringify(queryMessage));\n\t\t\t\t\tserverCallback(null, queryMessage); // invoke the callback (no error)\n\t\t\t\t} else {\n\t\t\t\t\t// invoke the callback with error since  flag in message (from router service)\n\t\t\t\t\tserverCallback(queryMessage.header.error, null);\n\t\t\t\t\tconsole.debug(\"server callback with RouterService error: \" + JSON.stringify(queryMessage.header));\n\t\t\t\t\tdelete map[queryMessage.header.channel]; // this is a bad server (e.g. duplicate) so remove it\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// add a callbackHandler into the query-response map for the given queryID\n\t\tfunction addQueryResponseCallBack(map, queryID, responseCallback) {\n\t\t\tmap[queryID] = responseCallback;\n\t\t}\n\t\n\t\t// invoke query-response callback (that is attached to a specific channel and listener type) \n\t\tfunction invokeQueryResponseCallback(map, responseMessage) {\n\t\t\tvar clientCallback = map[responseMessage.header.queryID];\n\t\t\tif (clientCallback === undefined) {\n\t\t\t\tconsole.warn(\"no handler defined for query response: \" + JSON.stringify(responseMessage));\n\t\t\t} else {\n\t\t\t\tif (!responseMessage.header.error) {\n\t\t\t\t\tconsole.debug(\"invoke queryResponse callback for query: \" + JSON.stringify(responseMessage));\n\t\t\t\t\tclientCallback(null, responseMessage); // invoke the callback passing the response message\n\t\t\t\t} else {\n\t\t\t\t\tconsole.debug(\"queryResponse callback with RouterService error: \" + JSON.stringify(responseMessage.header));\n\t\t\t\t\tclientCallback(responseMessage.header.error, responseMessage); // error from router service so pass it back instead of a message\n\t\t\t\t}\n\t\t\t\tdelete map[responseMessage.header.queryID];\n\t\t\t}\n\t\t}\n\t\n\t\t// add server callbackHandler for the given channel\n\t\tfunction addServerCallBack(map, channel, callback) {\n\t\t\tvar status = false;\n\t\t\tvar clientCallback = map[channel];\n\t\t\tif (clientCallback === undefined) {\n\t\t\t\tmap[channel] = callback;\n\t\t\t\tstatus = true;\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t\n\t\t// support function for sendNotifyToSubscriber -- maintains local list of subscribers for pubsub server\n\t\tfunction addToSubpubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n\t\t\tif (!(topic in pubsubListOfSubscribers)) {\n\t\t\t\tpubsubListOfSubscribers[topic] = [subscribeID];\n\t\t\t} else {\n\t\t\t\tpubsubListOfSubscribers[topic].push(subscribeID);\n\t\t\t}\n\t\t}\n\t\n\t\t// support function for addPubSubServer -- add pubsub server callbackHandler for the given channel\n\t\tfunction addPubSubServerCallBack(topic, subscribeCallback, publishCallback, unsubscribeCallback) {\n\t\t\tvar status = false;\n\t\t\tvar callbacks = mapPubSubServers[topic.toString()];\n\t\t\tif (callbacks === undefined) {\n\t\t\t\tif (topic instanceof RegExp) {\n\t\t\t\t\tmapPubSubServerRegEx[topic.toString()] = topic;\n\t\t\t\t\tconsole.debug(\"RegEx added for topic \" + topic.toString()); // Note: topic may be a RegEx, so use toString() where applicable\n\t\t\t\t}\n\t\t\t\tmapPubSubServers[topic.toString()] = { \"subscribeCallback\": subscribeCallback, \"publishCallback\": publishCallback, \"unsubscribeCallback\": unsubscribeCallback };\n\t\t\t\tstatus = true;\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t\n\t\t// callback function for invokeSubscribePubSubCallback to notify new subscriber\n\t\tfunction sendNotifyToSubscriber(err, notifyData) {\n\t\t\tsendToRouterService(new NotifyMessage(this.header.subscribeID, this.header.topic, err, notifyData));\n\t\t\tif (!err) {\n\t\t\t\t// add new subscriber to list\n\t\t\t\taddToSubpubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n\t\t\t\tconsole.debug(\"subscription added pubsub server: \" + JSON.stringify(this));\n\t\t\t} else {\n\t\t\t\tconsole.debug(\"subscribe rejected by pubsub server: \" + JSON.stringify(this));\n\t\t\t}\n\t\t}\n\t\n\t\t// for incoming subscribe: invoke notify callback for pubsub server\n\t\tfunction invokeSubscribePubSubCallback(subscribeMessage) {\n\t\t\tvar callbacks = mapPubSubServers[subscribeMessage.header.topic];\n\t\n\t\t\tif (callbacks === undefined) {\n\t\t\t\t// if undefined then may be a matching RegEx topic\n\t\t\t\tfor (var key in mapPubSubServerRegEx) {\n\t\t\t\t\tif (mapPubSubServerRegEx[key].test(subscribeMessage.header.topic)) {\n\t\t\t\t\t\tcallbacks = mapPubSubServers[key];\n\t\t\t\t\t\tvar initialState = mapPubSubServerState[subscribeMessage.header.topic]; // may already be initial state defined from publish\n\t\t\t\t\t\tif (initialState === undefined) {\n\t\t\t\t\t\t\t// if there isn't already state defined then use default from regEx\n\t\t\t\t\t\t\tinitialState = mapPubSubServerState[key]; // initialize the state from RegEx topic\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapPubSubServerState[subscribeMessage.header.topic] = initialState;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (callbacks === undefined) {\n\t\t\t\t// if still undefined\n\t\t\t\tconsole.warn(\"no pubsub server defined for incoming subscribe message: \" + JSON.stringify(subscribeMessage));\n\t\t\t} else {\n\t\t\t\tif (subscribeMessage.header.error) {\n\t\t\t\t\t// the router service uses the subscribe message in this case to return a pubsub error (ToDO: consider a generic error message)\n\t\t\t\t\tconsole.warn(\"pubsub error received from router service: \" + JSON.stringify(subscribeMessage.header.error));\n\t\t\t\t} else {\n\t\t\t\t\tsubscribeMessage.sendNotifyToSubscriber = sendNotifyToSubscriber; // add callback function to message so pubsub server can respond with Notify message\n\t\t\t\t\tif (callbacks.subscribeCallback) {\n\t\t\t\t\t\tcallbacks.subscribeCallback(null, subscribeMessage); // invoke the callback (no error)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// since no subscribe callback defined, use default functionality\n\t\t\t\t\t\tsubscribeMessage.sendNotifyToSubscriber(null, mapPubSubServerState[subscribeMessage.header.topic]); // must invoke from message to set this properly \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// support function for removeSubscriber callback --  remove one subscribeID from array for the given subscription topic\n\t\tfunction removeFromSubpubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n\t\t\tvar removed = false;\n\t\t\tif (topic in pubsubListOfSubscribers) {\n\t\t\t\tvar list = pubsubListOfSubscribers[topic];\n\t\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\t\tif (subscribeID === list[i]) {\n\t\t\t\t\t\tlist.splice(i, 1);\n\t\t\t\t\t\tif (list.length === 0) {\n\t\t\t\t\t\t\tdelete pubsubListOfSubscribers[topic];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\tconsole.debug(\"removeListener to \" + topic + \" from \" + JSON.stringify(subscribeID));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!removed) {\n\t\t\t\tconsole.warn(\"tried to remove non-existance listener on \" + topic + \" from \" + JSON.stringify(subscribeID));\n\t\t\t}\n\t\t}\n\t\n\t\t// callback function for invokeUnsubscribePubSubCallback to remove the subscriber from the subscription\t\n\t\tfunction removeSubscriber() {\n\t\t\tremoveFromSubpubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n\t\t}\n\t\n\t\t// for incoming unsubscribe: invoke unsubscribe callback for pubsub servier\n\t\tfunction invokeUnsubscribePubSubCallback(unsubscribeMessage) {\n\t\t\tvar callbacks = mapPubSubServers[unsubscribeMessage.header.topic];\n\t\n\t\t\tif (callbacks === undefined) {\n\t\t\t\t// if undefined then may be a matching RegEx topic\n\t\t\t\tfor (var key in mapPubSubServerRegEx) {\n\t\t\t\t\tif (mapPubSubServerRegEx[key].test(unsubscribeMessage.header.topic)) {\n\t\t\t\t\t\tcallbacks = mapPubSubServers[key];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (callbacks === undefined) {\n\t\t\t\t// if still undefined\n\t\t\t\tconsole.warn(\"no pubsub server defined for incoming unsubscribe message: \" + JSON.stringify(unsubscribeMessage));\n\t\t\t} else {\n\t\t\t\tunsubscribeMessage.removeSubscriber = removeSubscriber; // add callback function to message for pubsub server (but must always remove)\n\t\t\t\tif (callbacks.unsubscribeCallback) {\n\t\t\t\t\tcallbacks.unsubscribeCallback(null, unsubscribeMessage); // invoke the callback (no error)\n\t\t\t\t} else {\n\t\t\t\t\t// since no unsubscribe callback defined, use default functionality\n\t\t\t\t\tunsubscribeMessage.removeSubscriber();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// callback function for invokePublishPubSubCallback to send Notify \t\n\t\tfunction sendNotifyToAllSubscribers(err, notifyData) {\n\t\t\tif (!err) {\n\t\t\t\tmapPubSubServerState[this.header.topic] = notifyData; // store new state\n\t\t\t\tvar listOfSubscribers = pubsubListOfSubscribers[this.header.topic];\n\t\t\t\tif (typeof listOfSubscribers !== 'undefined') {\n\t\t\t\t\t// confirm subscribers to send to, if none then nothing to do\n\t\t\t\t\tfor (var i = 0; i < listOfSubscribers.length; i++) {\n\t\t\t\t\t\tsendToRouterService(new NotifyMessage(listOfSubscribers[i], this.header.topic, err, notifyData));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.debug(\"income publish rejected by pubsub server: \" + JSON.stringify(err));\n\t\t\t}\n\t\t}\n\t\n\t\t// for incoming Publish: invoke publish callback for pubsub servier\n\t\tfunction invokePublishPubSubCallback(publishMessage) {\n\t\t\tvar callbacks = mapPubSubServers[publishMessage.header.topic];\n\t\n\t\t\tif (callbacks === undefined) {\n\t\t\t\t// if undefined then may be a matching RegEx topic\n\t\t\t\tfor (var key in mapPubSubServerRegEx) {\n\t\t\t\t\tif (mapPubSubServerRegEx[key].test(publishMessage.header.topic)) {\n\t\t\t\t\t\tcallbacks = mapPubSubServers[key];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (callbacks === undefined) {\n\t\t\t\t// if still undefined\n\t\t\t\tconsole.warn(\"no pubsub server defined for incoming publish message: \" + JSON.stringify(publishMessage));\n\t\t\t} else {\n\t\t\t\tpublishMessage.sendNotifyToAllSubscribers = sendNotifyToAllSubscribers; // add callback function to message so pubsub server can respond to publish\n\t\t\t\tif (callbacks.publishCallback) {\n\t\t\t\t\tcallbacks.publishCallback(null, publishMessage); // invoke the callback (no error)\n\t\t\t\t} else {\n\t\t\t\t\t// since no pubish callback defined, use default functionality\n\t\t\t\t\tpublishMessage.sendNotifyToAllSubscribers(null, publishMessage.data); // must call from publish message (like a callback) so 'this' is properly set\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// for incoming Notify: invoke notify callback (that are attached to a specific channel and listener type) \n\t\tfunction invokeNotifyCallback(mapSubscribersID, notifyMessage) {\n\t\t\tvar notifyCallback = mapSubscribersID[notifyMessage.header.subscribeID];\n\t\t\tif (notifyCallback === undefined) {\n\t\t\t\tconsole.warn(\"no subscription handler defined for incoming notify: \" + JSON.stringify(notifyMessage));\n\t\t\t} else {\n\t\t\t\tif (!notifyMessage.header.error) {\n\t\t\t\t\tnotifyMessage.originatedHere = originatedHere; // add local function to test origin\n\t\t\t\t\tnotifyCallback(null, notifyMessage); // invoke the callback passing the response message\n\t\t\t\t} else {\n\t\t\t\t\tnotifyCallback(notifyMessage.header.error, notifyMessage); // error from router service so pass it back instead of a message\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// outgoing Unsubscribe: remove subscriber callbackHandler for the given channel\n\t\tfunction removeSubscriberCallBack(mapSubscribersID, subscribeID) {\n\t\t\tvar status = false;\n\t\t\tvar notifyCallback = mapSubscribersID[subscribeID];\n\t\t\tif (notifyCallback !== undefined) {\n\t\t\t\tdelete mapSubscribersID[subscribeID];\n\t\t\t\tstatus = true;\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t\n\t\t// for outgoing addSubscriber -- add a callback Handler for the subscribe\n\t\tfunction addSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic) {\n\t\t\tmapSubscribersID[subscribeID] = notifyCallback;\n\t\t\tmapSubscribersTopic[subscribeID] = topic;\n\t\t}\n\t\n\t\t// for removePubSubServer: remove server callbackHandler for the given channel\n\t\tfunction removeServerCallBack(map, channel) {\n\t\t\tvar status = false;\n\t\t\tvar clientCallback = map[channel];\n\t\t\tif (clientCallback !== undefined) {\n\t\t\t\tdelete map[channel];\n\t\t\t\tstatus = true;\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t\n\t\t// for addListener: add a callbackHandler into the specified map (which depends on listener type) for the given channel\n\t\tfunction addListenerCallBack(map, channel, callback) {\n\t\t\tvar firstChannelClient = false;\n\t\t\tvar clientCallbackArray = map[channel];\n\t\t\tif (clientCallbackArray === undefined) {\n\t\t\t\tmap[channel] = [callback];\n\t\t\t\tfirstChannelClient = true;\n\t\t\t} else {\n\t\t\t\tclientCallbackArray.push(callback);\n\t\t\t}\n\t\t\treturn firstChannelClient;\n\t\t}\n\t\n\t\t// for removeListener: remove a callbackHandler from the specified map (which depends on listener type) for the given channel\n\t\tfunction removeListenerCallBack(map, channel, callback) {\n\t\t\tvar lastChannelClient = false;\n\t\t\tvar clientCallbackArray = map[channel];\n\t\t\tif (clientCallbackArray !== undefined) {\n\t\t\t\tvar index = clientCallbackArray.indexOf(callback);\n\t\t\t\tif (index > -1) {\n\t\t\t\t\tclientCallbackArray.splice(index, 1);\n\t\t\t\t\tif (clientCallbackArray.length === 0) {\n\t\t\t\t\t\tlastChannelClient = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"no listener defined for channel: \" + channel);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lastChannelClient;\n\t\t}\n\t\n\t\t// route incoming message to appropriate callback, which depends on the message type and channel\n\t\tfunction routeIncomingMessage(incomingMessage) {\n\t\t\tconsole.debug(\"Incoming Message: \" + incomingMessage.header.type, 5);\n\t\t\tswitch (incomingMessage.header.type) {\n\t\t\t\tcase \"transmit\":\n\t\t\t\t\tinvokeListenerCallbacks(mapListeners, incomingMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"query\":\n\t\t\t\t\tinvokeServerCallback(mapServers, incomingMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"queryResponse\":\n\t\t\t\t\tinvokeQueryResponseCallback(mapQueryResponses, incomingMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"notify\":\n\t\t\t\t\tinvokeNotifyCallback(mapSubscribersID, incomingMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"publish\":\n\t\t\t\t\tinvokePublishPubSubCallback(incomingMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"subscribe\":\n\t\t\t\t\tinvokeSubscribePubSubCallback(incomingMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"unsubscribe\":\n\t\t\t\t\tinvokeUnsubscribePubSubCallback(incomingMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\n\t\t// *** all incoming messages from underlying transport arrive here ***\n\t\t// although incoming transport information is available, it is not passed on because not needed \n\t\tfunction incomingMessageHandler(incomingTransportInfo, message) {\n\t\t\t// ToDo: good place to put a function to validate incoming message/data\n\t\t\tmessage.header.lastClient = clientName; // add last client for diagnostics\n\t\t\trouteIncomingMessage(message);\n\t\t}\n\t\n\t\t// *** all outbound messages exit here though the appropriate transport ***\n\t\tfunction sendToRouterService(message) {\n\t\t\tconsole.debug(\"Outgoing Message: \" + JSON.stringify(message.header.type), 5);\n\t\t\ttransport.send(message);\n\t\t}\n\t\n\t\t/////////////////////////////////////////////\n\t\t// Public Functions -- The Router Client API\n\t\t/////////////////////////////////////////////\n\t\n\t\t/**\r\n\t  * Set route client name to human readable form for better diagnotics.  An random id is concatenated on the end to ensure uniqueness.\r\n\t  * \r\n\t  * @param {string} newClientName\r\n\t  * @example\r\n\t  *\r\n\t  * RouterClient.setClientName(\"MyComponent\");\r\n\t  */\n\t\tthis.setClientName = function (newClientName) {\n\t\t\tvalidate.args(thisClientName, \"string\");\n\t\t\tclientName = Utils.getUniqueName(newClientName);\n\t\t\tconsole.info(\"Route Client name set to \" + clientName);\n\t\t};\n\t\n\t\t/**\r\n\t  * Add listener for incoming event on specified channel.\r\n\t  * \r\n\t  * @param {string} channel\r\n\t  * @param {function} eventHandler\r\n\t  * @example\r\n\t  *\r\n\t  * RouterClient.addListener(\"SomeChannelName\", function (error, message) {\r\n\t  * \t\t// process incoming channel message\t\t\r\n\t  * });\r\n\t  *\r\n\t  */\n\t\tthis.addListener = function (channel, eventHandler) {\n\t\t\tconsole.debug(\"addListener to channel \" + channel);\n\t\t\tvalidate.args(channel, \"string\", eventHandler, \"function\");\n\t\t\tvar firstChannelClient = addListenerCallBack(mapListeners, channel, eventHandler);\n\t\t\tif (firstChannelClient) {\n\t\t\t\tsendToRouterService(new AddListenerMessage(channel));\n\t\t\t}\n\t\t};\n\t\n\t\t/**\r\n\t  * Transmit event to specified channel.\r\n\t  * \r\n\t  * @param {string} toChannel\r\n\t  * @param {any} event -- object or primitive type to be transmitted\r\n\t  * @example\r\n\t  *\r\n\t  * RouterClient.transmit(\"SomeChannelName\", channelMessage);\r\n\t  *\r\n\t  */\n\t\tthis.transmit = function (toChannel, event) {\n\t\t\tconsole.debug(\"transmit to channel \" + toChannel + \" event: \" + JSON.stringify(event));\n\t\t\tvalidate.args(toChannel, \"string\", event, \"any\");\n\t\t\tsendToRouterService(new TransmitMessage(toChannel, event));\n\t\t};\n\t\n\t\t/**\r\n\t  * Remove event listener from specified channel.\r\n\t  * \r\n\t  * @param {string} channel\r\n\t  * @param {function} eventHandler for the listener\r\n\t  */\n\t\tthis.removeListener = function (channel, eventHandler) {\n\t\t\tconsole.debug(\"removelistener to channel \" + channel);\n\t\t\tvalidate.args(channel, \"string\", eventHandler, \"function\");\n\t\t\tvar lastChannelListener = removeListenerCallBack(mapListeners, channel, eventHandler);\n\t\t\tif (lastChannelListener) {\n\t\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\n\t\t\t}\n\t\t};\n\t\n\t\t/** \r\n\t  * Add event server to the specified channel (only one server allowed per channel)\r\n\t  * \r\n\t  * @param {string} channel\r\n\t  * @param {function} queryEventHandler\r\n\t  * @example\r\n\t  *\r\n\t  * RouterClient.addServer(\"ServerChannelName\", function (error, queryMessage) {\r\n\t  *\tif (error) {\r\n\t  *\t\tconsole.log('addServer failed: ' + JSON.stringify(error));\r\n\t  *\t} else {\r\n\t  *\t\t// process income query message\r\n\t  *\t\t// then send query response\r\n\t  *\t\tqueryMessage.sendQueryResponse(null, queryMessage.data);\r\n\t  *\t}\r\n\t  * });\r\n\t  *\r\n\t  */\n\t\tthis.addServer = function (channel, queryEventHandler) {\n\t\t\tconsole.debug(\"addServer for channel \" + channel);\n\t\t\tvalidate.args(channel, \"string\", queryEventHandler, \"function\");\n\t\t\tvar status = addServerCallBack(mapServers, channel, queryEventHandler);\n\t\t\tif (status) {\n\t\t\t\tsendToRouterService(new AddServerMessage(channel));\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"Server already locally defined for channel \" + channel);\n\t\t\t\tqueryEventHandler({\n\t\t\t\t\t\"RouteClient QueryError\": \"Server already locally defined for channel\"\n\t\t\t\t}, null); // immediately invoke callback passing error\n\t\t\t}\n\t\t};\n\t\n\t\t/**\r\n\t  * Send query to server listening on specified channel.\r\n\t  * \r\n\t  * @param {any} serverChannel\r\n\t  * @param {object=} queryEvent event message sent to server\r\n\t  * @param {function} responseEventHandler\r\n\t  */\n\t\tthis.query = function (serverChannel, queryEvent, responseEventHandler) {\n\t\t\tconsole.debug(\"query to server channel \" + serverChannel + \" passing event: \" + JSON.stringify(queryEvent));\n\t\t\tvalidate.args(serverChannel, \"string\", queryEvent, \"any=\", responseEventHandler, \"function\");\n\t\t\tvar newQueryID = clientID();\n\t\t\taddQueryResponseCallBack(mapQueryResponses, newQueryID, responseEventHandler);\n\t\t\tsendToRouterService(new QueryMessage(newQueryID, serverChannel, queryEvent));\n\t\t};\n\t\n\t\t/**\r\n\t  * Remove event server from specified channel.\r\n\t  * \r\n\t  * @param {string} serverChannel\r\n\t  */\n\t\tthis.removeServer = function (serverChannel) {\n\t\t\tconsole.debug(\"removeServer from server channel \" + serverChannel);\n\t\t\tvalidate.args(serverChannel, \"string\");\n\t\t\tvar status = removeServerCallBack(mapServers, serverChannel);\n\t\t\tif (status) {\n\t\t\t\tsendToRouterService(new RemoveServerMessage(serverChannel));\n\t\t\t}\n\t\t};\n\t\n\t\t/**\r\n\t  * Add a PubSub server to specified topic. Generally only one PubSub server allowed per topic;\r\n\t  * however a topic may be a regular-expression, in which case the PubSub server will server all matching topics.\r\n\t  * When a regEx topic is used, the same default functionality is provides for each matching topic -- the difference\r\n\t  * is only on SubPub service is need to cover a set of related topics, plus the same callback hander can be used (if provided).\r\n\t  *\r\n\t  * Note an exact topic match will take precedence over a regEx match, but otherwise results are unpredictable for overlapping topics.\r\n\t  * \r\n\t  * @param {string} topic topic for this server, or a topic RegEx (e.g. '/abc.+/') to handle a set of topcis\r\n\t  * @param {object} initialState for the topic (defaults to empty struct)\r\n\t  * @param {object=} params optional parameters\r\n\t  * @param {function=} params.subscribeCallback allows server know of the subscription and accept or reject it (default is to accept)\r\n\t  * @param {function=} params.publishCallback allows server to use the publish data to form a new state (default is the publish data becomes the new state)\r\n\t  * @param {function=} params.unsubscribeCallback allows server to know of the unsubscribe, but it must be accepted\r\n\t  *\r\n\t  * @example\r\n\t  *\r\n\t  * function subscribeCallback(error, subscribe) {\r\n\t  * \t\tif (subscribe) {\r\n\t  * \t\t\t// must make this callback to accept or reject the subscribe (default is to accept). First parm is err and second is the initial state\r\n\t  * \t\t\tsubscribe.sendNotifyToSubscriber(null, { \"NOTIFICATION-STATE\": \"One\" });\r\n\t  * \t\t}\r\n\t  * }\r\n\t  * function publishCallback(error, publish) {\r\n\t  * \t\tif (publish) {\r\n\t  * \t\t\t// must make this callback to send notify to all subscribers (if error parameter set then notify will not be sent)\r\n\t  * \t\t\tpublish.sendNotifyToAllSubscribers(null, publish.data); \r\n\t  * \t\t}\r\n\t  * }\r\n\t  * function unsubscribeCallback(error, unsubscribe) {\r\n\t  * \t\tif (unsubscribe) {\r\n\t  * \t\t\t// must make this callback to acknowledge the unsubscribe \r\n\t  * \t\t\tunsubscribe.removeSubscriber();\r\n\t  * \t\t}\r\n\t  * }\r\n\t  * RouterClient.addPubSubServer(\"topicABC\", { \"State\": \"start\" }, { subscribeCallback:subscribeCallback, publishCallback:publishCallback, unsubscribeCallback:unsubscribeCallback } );\r\n\t  *\r\n\t  *   or\r\n\t  *\r\n\t  * RouterClient.addPubSubServer(\"topicABC\", { \"State\": \"start\" });\r\n\t  *\r\n\t  *   or\r\n\t  *\r\n\t  * RouterClient.addPubSubServer(\\/topicA*\\/, { \"State\": \"start\" });\r\n\t  *\r\n\t  */\n\t\tthis.addPubSubServer = function (topic, initialState, params) {\n\t\t\tconsole.debug(\"addPubSubServer for topic \" + topic);\n\t\t\tvalidate.args(topic, \"any\", initialState, \"object=\", params, \"object=\");\n\t\t\tparams = params || {};\n\t\t\tvalidate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") && validate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\n\t\n\t\t\tvar status = addPubSubServerCallBack(topic, params.subscribeCallback, params.publishCallback, params.unsubscribeCallback);\n\t\t\tif (status) {\n\t\t\t\tinitialState = initialState || {};\n\t\t\t\tmapPubSubServerState[topic.toString()] = initialState;\n\t\t\t\tsendToRouterService(new AddPubSubServerMessage(topic.toString()));\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"PubSub Server already locally defined for topic \" + topic);\n\t\t\t\tnotifyEventHandler({\n\t\t\t\t\t\"error\": \"PubSub Server already locally defined for topic\"\n\t\t\t\t}, null); // immediately invoke callback passing error\n\t\t\t}\n\t\t};\n\t\n\t\t/**\r\n\t  * Remove pubsub server from specified topic.\r\n\t  * \r\n\t  * @param {string} topic\r\n\t  */\n\t\tthis.removePubSubServer = function (topic) {\n\t\t\tconsole.debug(\"removePubSubServer for topic \" + topic);\n\t\t\tvalidate.args(topic, \"string\");\n\t\t\tvar status = removeServerCallBack(mapPubSubServers, topic);\n\t\t\tif (status) {\n\t\t\t\tdelete mapPubSubServerState[topic.toString()]; // remove corresponding state\n\t\t\t\tdelete mapPubSubServerRegEx[topic.toString()]; // may be a RegEx\n\t\t\t\tsendToRouterService(new RemovePubSubServerMessage(topic));\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"removePubSubServer failed -- could not find server for topic \" + topic);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\r\n\t  * Subscribe to a PubSub Server.\r\n\t  * \r\n\t  * @param {string} topic\r\n\t  * @param {function} notifyCallback\r\n\t  * @returns subscribe object used for unsubscribing\r\n\t  */\n\t\tthis.subscribe = function (topic, notifyCallback) {\n\t\t\tconsole.debug(\"subscribe for topic \" + topic);\n\t\t\tvalidate.args(topic, \"string\", notifyCallback, 'function');\n\t\t\tvar subscribeID = clientID();\n\t\t\taddSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic);\n\t\t\tsendToRouterService(new SubscribeMessage(subscribeID, topic));\n\t\t\treturn { \"subscribeID\": subscribeID, \"topic\": topic };\n\t\t};\n\t\n\t\t/**\r\n\t  * Publish to a PubSub Server, which will trigger a corresponding Notify to be sent to all subscribers. \r\n\t  * \r\n\t  * @param {string} topic\r\n\t  * @param {object} event\r\n\t  */\n\t\tthis.publish = function (topic, event) {\n\t\t\tvalidate.args(topic, \"string\", event, 'any');\n\t\t\tconsole.debug(\"publish to topic \" + topic + \" event: \" + JSON.stringify(event));\n\t\t\tsendToRouterService(new PublishMessage(topic, event));\n\t\t};\n\t\n\t\t/**\r\n\t  * Unsubscribe from PubSub server.\r\n\t  * \r\n\t  * @param {object} subscribeIDStruct\r\n\t  */\n\t\tthis.unsubscribe = function (subscribeIDStruct) {\n\t\t\tconsole.debug(\"unsubscribe to topic \" + subscribeIDStruct.topic + \" for subscriberID \" + subscribeIDStruct.subscribeID);\n\t\t\tvalidate.args(subscribeIDStruct, \"object\") && validate.args2(\"subscribeIDStruct.subscribeID\", subscribeIDStruct.subscribeID, \"string\");\n\t\t\tvar deletedSubscriber = removeSubscriberCallBack(mapSubscribersID, subscribeIDStruct.subscribeID);\n\t\t\tif (deletedSubscriber) {\n\t\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeIDStruct.subscribeID, subscribeIDStruct.topic));\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"unsubscribe failed -- could not find subscribeID for topic \" + subscribeIDStruct.topic);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\r\n\t  * @todo\r\n\t  * Removes all listeners, servers, and subscribers for this router client -- typically called when client component is shutting down (but RouterService is staying up).\r\n\t  */\n\t\tthis.disconnectAll = function () {\n\t\t\tconsole.debug(\"disconnectAll\");\n\t\n\t\t\tfor (var channel in mapListeners) {\n\t\t\t\tconsole.debug(\"removing listener on \" + channel);\n\t\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\n\t\t\t\tdelete mapListeners[channel];\n\t\t\t}\n\t\n\t\t\tfor (var serverChannel in mapServers) {\n\t\t\t\tconsole.debug(\"removing server on \" + serverChannel);\n\t\t\t\tsendToRouterService(new RemoveServerMessage(serverChannel));\n\t\t\t\tdelete mapServers[serverChannel];\n\t\t\t}\n\t\n\t\t\tfor (var topic in mapPubSubServers) {\n\t\t\t\tconsole.debug(\"removing pubsub server on \" + topic);\n\t\t\t\tsendToRouterService(new RemovePubSubServerMessage(topic));\n\t\t\t\tdelete mapPubSubServers[topic.toString()]; // could be a RegEx\n\t\t\t\tdelete mapPubSubServerState[topic.toString()]; // remove corresponding state\n\t\t\t\tdelete mapPubSubServerRegEx[topic.toString()]; // may be a RegEx\n\t\t\t}\n\t\n\t\t\tfor (var subscribeID in mapSubscribersID) {\n\t\t\t\tvar stopic = mapSubscribersTopic[subscribeID];\n\t\t\t\tconsole.debug(\"removing subscriber on \" + stopic);\n\t\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeID, stopic));\n\t\t\t\tdelete mapSubscribersID[subscribeID];\n\t\t\t\tdelete mapSubscribersTopic[subscribeID];\n\t\t\t}\n\t\t};\n\t\n\t\tconstructor(thisClientName, transportName); // on creation invoke to initialize\n\t};\n\t\n\tmodule.exports = RouterClientConstructor;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// -------------------------------------------------------------------------------------------\n\t// Copyright 2012-2017 by ChartIQ, Inc\n\t// -------------------------------------------------------------------------------------------\n\t\n\t\"use strict\";\n\t\n\tvar Utils = __webpack_require__(2);\n\tvar console = new Utils.Console(\"RouterTransport\"); // Finsemble console\n\t\n\tvar openfinAppConfig; // config used to determine if cross-domain\n\tif (window.location.hostname === \"localhost\") {\n\t\t// if localhost then using desktop-local config\n\t\tconsole.debug(\"desktop-local config\");\n\t\topenfinAppConfig = __webpack_require__(6);\n\t} else {\n\t\t// else using desktop-app config\n\t\tconsole.debug(\"desktop-app config\");\n\t\topenfinAppConfig = __webpack_require__(7);\n\t}\n\t\n\t/**\r\n\t * @introduction\r\n\t * <h2>Router Transport</h2>\r\n\t * **Service-Level Module**.  Manages and contains the point-to-point transports (i.e. Layer 2) supported by Finsemble.\r\n\t * Each transport communicates betweew a Finsemble services or component (on one end) and the Finsemble router (on the other end).\r\n\t *\r\n\t * The OpenFinBus transport is used for cross-domain components (where SharedWorker fails).\r\n\t *\r\n\t * Requirements for adding a new transport:\r\n\t * 1) create new transport object with same interface provided by SharedWorkerTransport and OpenFinTransport in this file.\r\n\t * 2) call RouterTransport.addTransport() to make the transport available (see the bottom of this file)\r\n\t *\r\n\t * Integration into routerService.js is automatic.\r\n\t *\r\n\t * @namespace RouterTransport\r\n\t */\n\tvar RouterTransport = {\n\t\n\t\tactiveTransports: {},\n\t\n\t\t/**\r\n\t  * Adds a new type of router transport to pass message between RouterClient and RouterService. \r\n\t  * \r\n\t  * @param {string} transportName identifies the new transport\r\n\t  * @param {object} transportConstructor returns an instance of the new transport\r\n\t  */\n\t\taddTransport: function addTransport(transportName, transportConstructor) {\n\t\t\tthis.activeTransports[transportName] = transportConstructor;\n\t\t\tconsole.info(\"RouterTransport added: \" + transportName);\n\t\t},\n\t\n\t\t/**\r\n\t  * Gets array of active transports\r\n\t  * \r\n\t  * @returns array transport names/identifier\r\n\t  */\n\t\tgetActiveTransports: function getActiveTransports() {\n\t\t\tvar transportNames = [];\n\t\t\tfor (var transportIdentifier in this.activeTransports) {\n\t\t\t\ttransportNames.push(transportIdentifier);\n\t\t\t}\n\t\t\treturn transportNames;\n\t\t},\n\t\n\t\t/**\r\n\t  * Get best client transport based on the run-time context. Will only return cross-domain transport if current context is inter-domain.  \r\n\t  * \r\n\t  * @param {any} incomingMessageHandler\r\n\t  * @param {any} source\r\n\t  * @param {any} destination\r\n\t  * @returns the transport object\r\n\t  */\n\t\tgetRecommendedTransport: function getRecommendedTransport(incomingMessageHandler, source, destination) {\n\t\t\tvar newTransport; // return variable\n\t\n\t\t\t// Will tell you if the window is in an iframe or not (for future)\n\t\t\tfunction isInIframe() {\n\t\t\t\ttry {\n\t\t\t\t\treturn window.self !== window.top;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// returns true if this window's location is in another domain \n\t\t\tfunction crossDomain() {\n\t\t\t\tvar parser = document.createElement('a');\n\t\t\t\tparser.href = openfinAppConfig.startup_app.url;\n\t\n\t\t\t\tvar isSameHost = window.location.hostname === parser.hostname;\n\t\t\t\tconsole.debug(\"Transport crossDomain host comparison:\" + window.location.hostname + \"==\" + parser.hostname);\n\t\n\t\t\t\tvar isSameProtocol = window.location.protocol === parser.protocol;\n\t\t\t\tconsole.debug(\"Transport crossDomain protocol comparison:\" + window.location.protocol + \"==\" + parser.protocol);\n\t\n\t\t\t\tvar wport = window.location.port === undefined ? window.location.port : 80;\n\t\t\t\tvar pport = parser.port === undefined ? parser.port : 80;\n\t\t\t\tvar isSamePort = wport === pport;\n\t\t\t\tconsole.debug(\"Transport crossDomain port comparison:\" + wport + \"==\" + pport);\n\t\n\t\t\t\tvar isCrossDomain = !(isSameHost && isSamePort && isSameProtocol);\n\t\t\t\tconsole.debug(\"Transport crossDomain=\" + isCrossDomain + \" (\" + isSameHost + \":\" + isSameProtocol + \":\" + isSamePort + \")\");\n\t\t\t\treturn isCrossDomain;\n\t\t\t}\n\t\n\t\t\t// returns the best transport to communicating with router service\t\t\n\t\t\tfunction recommendedTransportName() {\n\t\t\t\tvar recommendedName = \"SharedWorker\"; // default -- fast but doesn't work cross-domain\n\t\t\t\tif (crossDomain()) {\n\t\t\t\t\trecommendedName = \"OpenFinBus\"; // required for cross-domain event messaging between windows\n\t\t\t\t}\n\t\t\t\treturn recommendedName;\n\t\t\t}\n\t\n\t\t\tvar transportName = recommendedTransportName();\n\t\t\tvar transportConstructor = this.activeTransports[transportName];\n\t\t\tif (transportConstructor) {\n\t\t\t\tnewTransport = new transportConstructor(transportName, incomingMessageHandler, source, destination);\n\t\t\t}\n\t\t\treturn newTransport;\n\t\t},\n\t\n\t\t/**\r\n\t  * Get a specific transport by name. The transport must be in list of the active transports (i.e. previously added).\r\n\t  * \r\n\t  * @param {any} transportName\r\n\t  * @param {any} incomingMessageHandler\r\n\t  * @param {any} source\r\n\t  * @param {any} destination\r\n\t  * @returns the transport object\r\n\t  */\n\t\tgetTransport: function getTransport(transportName, incomingMessageHandler, source, destination) {\n\t\t\tvar transportConstructor = this.activeTransports[transportName];\n\t\t\tif (transportConstructor) {\n\t\t\t\tvar newTransport = new transportConstructor(transportName, incomingMessageHandler, source, destination);\n\t\t\t}\n\t\t\treturn newTransport;\n\t\t}\n\t};\n\t\n\t//////////////////////////////////////////////////////////////\n\t// Below all transports are defined then added to active list\n\t//////////////////////////////////////////////////////////////\n\t\n\tvar RouterTransportImplementation = {}; // a convenience namespace for router-transport implementations\n\t\n\t/*\r\n\t * Implements the SharedWorker Transport.\r\n\t * \r\n\t * Required Functions (used by transport clients):\r\n\t * \t\tsend(eventMessage) -- transports the event \r\n\t * \t\tidentifier() -- returns transport name/identifier\r\n\t * \r\n\t *  @param {object=} name the name the transport will be reference by\r\n\t *  @param {any} parentMessageHandlerParm callback for incoming event\r\n\t */\n\tRouterTransportImplementation.SharedWorkerTransport = function (name, parentMessageHandlerParm, source) {\n\t\tvar parentMessageHandler;\n\t\tvar routerThread;\n\t\tvar transportName;\n\t\tvar console = new Utils.Console(\"SharedWorkerTransport.\" + source); // Finsemble console\n\t\n\t\t// receives incoming shared-worker messages then passes on to parent with correct \"wrapper\"\n\t\tfunction sharedWorkerMessageHandler(swMessage) {\n\t\t\tvar port = swMessage.data[0];\n\t\t\tvar eventMessage = swMessage.data[1];\n\t\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"port\": port };\n\t\t\tconsole.debug(\"IncomingTransport: \" + JSON.stringify(incomingTransportInfo) + \" Message: \" + JSON.stringify(eventMessage), 5);\n\t\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\n\t\t}\n\t\n\t\t//required function for parent (i.e. routeClient or routeService)\n\t\tthis.send = function (transport, eventMessage) {\n\t\t\t// handle optional transport parm\n\t\t\tif (arguments.length === 1) {\n\t\t\t\ttransport = null;\n\t\t\t\teventMessage = arguments[0];\n\t\t\t} else {\n\t\t\t\ttransport = arguments[0];\n\t\t\t\teventMessage = arguments[1];\n\t\t\t}\n\t\t\tconsole.debug(\"OutgoingTransport: \" + \" Transport: \" + JSON.stringify(transport) + \" Message: \" + JSON.stringify(eventMessage), 5);\n\t\t\trouterThread.port.postMessage([transport, eventMessage]);\n\t\t};\n\t\n\t\t//required function for parent (i.e. routeClient or routeService)\n\t\tthis.identifier = function () {\n\t\t\treturn transportName;\n\t\t};\n\t\n\t\tconsole.debug(\"SharedWorker Initializing: \" + source);\n\t\ttransportName = name;\n\t\tparentMessageHandler = parentMessageHandlerParm;\n\t\trouterThread = new SharedWorker(\"/common/routerSharedWorker.js\", \"Finsemble\");\n\t\trouterThread.port.onmessage = sharedWorkerMessageHandler;\n\t\trouterThread.onerror = function (e) {\n\t\t\tconsole.error(\"RouteClient SharedWorker Error\" + JSON.stringify(e));\n\t\t};\n\t\trouterThread.port.start();\n\t\n\t\tif (source === \"RouterService\") {\n\t\t\t// send first message though shared worker to identify router service\n\t\t\trouterThread.port.postMessage({ data: \"connect\", source: \"RouterService\" });\n\t\t}\n\t};\n\t\n\t/*\r\n\t * Implements the OpenFin Bus Transport.\r\n\t * \r\n\t * Required Functions (used by transport clients):\r\n\t * \t\tsend(event) -- transports the event \r\n\t * \t\tidentifier() -- returns transport name/identifier\r\n\t * \r\n\t *  @param {any} name -- the name the transport will be reference by\r\n\t *  @param {any} parentMessageHandlerParm -- callback for incoming event\r\n\t */\n\tRouterTransportImplementation.OpenFinTransport = function (name, parentMessageHandlerParm, source, destination) {\n\t\tvar parentMessageHandler;\n\t\tvar transportName;\n\t\tvar console = new Utils.Console(\"OpenFinTransport.\" + source); // Finsemble console\n\t\n\t\t// receives incoming OpenFin bus messages then passes on to parent with correct \"wrapper\"\n\t\tfunction openFinMessageHandler(eventMessage, senderUuid, name) {\n\t\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"senderUuid\": senderUuid, \"name\": eventMessage.header.origin };\n\t\t\tconsole.debug(\"IncomingTransport: \" + JSON.stringify(incomingTransportInfo) + \" Message: \" + JSON.stringify(eventMessage), 5);\n\t\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\n\t\t}\n\t\n\t\tfunction subscribeFailure(reason) {\n\t\t\tconsole.error(\"OpenFinBus Subscribe Failure: \" + reason);\n\t\t}\n\t\n\t\t//required function for the parent (i.e. routeClient or routeService)\n\t\tthis.send = function (transport, eventMessage) {\n\t\t\tvar destTopic;\n\t\n\t\t\t// handle optional transport parm\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tdestTopic = destination;\n\t\t\t\teventMessage = arguments[0];\n\t\t\t} else {\n\t\t\t\tdestTopic = transport.name;\n\t\t\t\teventMessage = arguments[1];\n\t\t\t}\n\t\n\t\t\tconsole.debug(\"OutgoingTransport: \" + destTopic + \" Message: \" + JSON.stringify(eventMessage), 5);\n\t\t\tfin.desktop.InterApplicationBus.send(\"ChartIQ\", destTopic, eventMessage);\n\t\t};\n\t\n\t\t//required function for the parent (i.e. routeClient or routeService)\n\t\tthis.identifier = function () {\n\t\t\treturn transportName;\n\t\t};\n\t\n\t\ttransportName = name;\n\t\tparentMessageHandler = parentMessageHandlerParm;\n\t\tconsole.debug(\"OpenFinBus Initializing: \" + source);\n\t\tfin.desktop.InterApplicationBus.subscribe(\"ChartIQ\", source, openFinMessageHandler, null, subscribeFailure);\n\t};\n\t\n\t// add the transports to the available/active list\n\tRouterTransport.addTransport(\"SharedWorker\", RouterTransportImplementation.SharedWorkerTransport);\n\tRouterTransport.addTransport(\"OpenFinBus\", RouterTransportImplementation.OpenFinTransport);\n\t\n\tmodule.exports = RouterTransport;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"FSBL\": {\n\t\t\t\"main_component\": {\n\t\t\t\t\"url\": \"http://localhost/components/toolbar/toolbar.html\",\n\t\t\t\t\"name\": \"Launcher\"\n\t\t\t}\n\t\t},\n\t\t\"devtools_port\": 9090,\n\t\t\"startup_app\": {\n\t\t\t\"name\": \"ChartIQ Local\",\n\t\t\t\"url\": \"http://localhost/components/serviceManager/serviceManager.html\",\n\t\t\t\"uuid\": \"ChartIQ\",\n\t\t\t\"applicationIcon\": \"http://localhost/components/assets/img/CIQ_Taskbar_Icon.png\",\n\t\t\t\"defaultTop\": 0,\n\t\t\t\"defaultLeft\": 0,\n\t\t\t\"showTaskbarIcon\": true,\n\t\t\t\"autoShow\": true,\n\t\t\t\"frame\": false,\n\t\t\t\"resizable\": false,\n\t\t\t\"maximizable\": false,\n\t\t\t\"delay_connection\": true,\n\t\t\t\"contextMenu\": true,\n\t\t\t\"cornerRounding\": {\n\t\t\t\t\"width\": 4,\n\t\t\t\t\"height\": 4\n\t\t\t},\n\t\t\t\"alwaysOnTop\": false,\n\t\t\t\"frameConnect\": \"main-window\",\n\t\t\t\"customData\": {\n\t\t\t\t\"finsemble\": {\n\t\t\t\t\t\"services\": {\n\t\t\t\t\t\t\"beforeLaunch\": [],\n\t\t\t\t\t\t\"workers\": []\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"runtime\": {\n\t\t\t\"arguments\": \"--noerrdialogs  --v=1\",\n\t\t\t\"version\": \"stable\"\n\t\t},\n\t\t\"shortcut\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"description\": \"ChartIQ Local\",\n\t\t\t\"icon\": \"http://localhost/components/assets/img/CIQ_Taskbar_Icon.ico\",\n\t\t\t\"name\": \"ChartIQ - LOCAL\",\n\t\t\t\"target\": [\n\t\t\t\t\"desktop\",\n\t\t\t\t\"start-menu\"\n\t\t\t],\n\t\t\t\"force\": false,\n\t\t\t\"startMenuRootFolder\": \"ChartIQ Local\"\n\t\t},\n\t\t\"dialogSettings\": {\n\t\t\t\"logo\": \"http://localhost/components/assets/img/ciq-banner-100x25.png\",\n\t\t\t\"bgColor\": 4280798349,\n\t\t\t\"textColor\": 4293521652,\n\t\t\t\"progressBarBgColor\": 4294967295,\n\t\t\t\"progressBarFillColor\": 4282684881,\n\t\t\t\"progressBarBorderColor\": 4293521652\n\t\t},\n\t\t\"supportInformation\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"product\": \"ChartIQ Desktop\",\n\t\t\t\"email\": \"support@chartiq.com\"\n\t\t},\n\t\t\"fileName\": \"ChartIQ-local-installer\"\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"FSBL\": {\n\t\t\t\"main_component\": {\n\t\t\t\t\"url\": \"http://finsemble.chartiq.com/components/toolbar/toolbar.html\",\n\t\t\t\t\"name\": \"Launcher\"\n\t\t\t}\n\t\t},\n\t\t\"devtools_port\": 9090,\n\t\t\"startup_app\": {\n\t\t\t\"name\": \"ChartIQ\",\n\t\t\t\"url\": \"http://finsemble.chartiq.com/components/serviceManager/serviceManager.html\",\n\t\t\t\"uuid\": \"ChartIQ\",\n\t\t\t\"applicationIcon\": \"http://finsemble.chartiq.com/components/assets/img/CIQ_Taskbar_Icon.png\",\n\t\t\t\"defaultTop\": 0,\n\t\t\t\"defaultLeft\": 0,\n\t\t\t\"showTaskbarIcon\": true,\n\t\t\t\"autoShow\": false,\n\t\t\t\"frame\": false,\n\t\t\t\"resizable\": false,\n\t\t\t\"maximizable\": false,\n\t\t\t\"delay_connection\": true,\n\t\t\t\"cornerRounding\": {\n\t\t\t\t\"width\": 4,\n\t\t\t\t\"height\": 4\n\t\t\t},\n\t\t\t\"alwaysOnTop\": true,\n\t\t\t\"frameConnect\": \"main-window\"\n\t\t},\n\t\t\"runtime\": {\n\t\t\t\"arguments\": \"--v=1\",\n\t\t\t\"version\": \"stable\"\n\t\t},\n\t\t\"shortcut\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"description\": \"ChartIQ\",\n\t\t\t\"icon\": \"http://finsemble.chartiq.com/components/assets/img/CIQ_Taskbar_Icon.ico\",\n\t\t\t\"name\": \"ChartIQ\",\n\t\t\t\"target\": [\n\t\t\t\t\"desktop\",\n\t\t\t\t\"start-menu\"\n\t\t\t],\n\t\t\t\"force\": false,\n\t\t\t\"startMenuRootFolder\": \"ChartIQ\"\n\t\t},\n\t\t\"dialogSettings\": {\n\t\t\t\"logo\": \"http://finsemble.chartiq.com/components/assets/img/ciq-banner-100x25.png\",\n\t\t\t\"bgColor\": 4280798349,\n\t\t\t\"textColor\": 4293521652,\n\t\t\t\"progressBarBgColor\": 4294967295,\n\t\t\t\"progressBarFillColor\": 4282684881,\n\t\t\t\"progressBarBorderColor\": 4293521652\n\t\t},\n\t\t\"supportInformation\": {\n\t\t\t\"company\": \"ChartIQ\",\n\t\t\t\"product\": \"ChartIQ Desktop\",\n\t\t\t\"email\": \"support@chartiq.com\"\n\t\t},\n\t\t\"fileName\": \"ChartIQ-installer\"\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\r\n\t * @introduction\r\n\t * <h2>Finsemble Vaidate Functions</h2>\r\n\t * \r\n\t * @class Validate\r\n\t */\n\t\n\t/**\r\n\t * Constructor for Finsemble argment validator.\r\n\t *\r\n\t * Validatation logic is ONLY RAN when the console diagnotics level is set to debug (i.e. 4 or above)\r\n\t * A failed validation will generate a warning message, but nothing more; however application logic can check the validation results.\r\n\t *\r\n\t * @param {string} console Finsemble console object used to display messages and check diagnotic level\r\n\t * @memberof Utils\r\n\t * @constructor\r\n\t */\n\tvar Validate = function Validate(console) {\n\t\n\t\tfunction warningMsg(paramDescript, thisArg, thisArgType) {\n\t\n\t\t\tfunction getErrorObject() {\n\t\t\t\ttry {\n\t\t\t\t\tthrow Error('');\n\t\t\t\t} catch (err) {\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar err = getErrorObject();\n\t\n\t\t\tvar caller_line1 = err.stack.split(\"\\n\")[5];\n\t\t\tvar index1 = caller_line1.indexOf(\"at \");\n\t\t\tvar msgPart1 = caller_line1.slice(index1 + 2, caller_line1.length);\n\t\n\t\t\tvar caller_line2 = err.stack.split(\"\\n\")[6];\n\t\t\tvar index2 = caller_line2.indexOf(\"at \");\n\t\t\tvar msgPart2 = caller_line2.slice(index2 + 2, caller_line2.length);\n\t\n\t\t\tconsole.warn(\"parameter validation failed: parameter \" + paramDescript + \" is of type '\" + (typeof thisArg === \"undefined\" ? \"undefined\" : _typeof(thisArg)) + \"' but should be of type '\" + thisArgType + \"' in\" + msgPart1 + \" called by\" + msgPart2);\n\t\t}\n\t\n\t\t/**\r\n\t  * Confirm parameters are valid. A variable number of parameter pairs are supported. \r\n\t  * @param {any} param1 is arg to validate\r\n\t  * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \r\n\t  * @param {any=} param2 is next arg to validate\r\n\t  * @param {string=} paramType2 os required type for next arg \r\n\t  * @return {boolean} returns turn if parameter list is valid; otherwise, false.\r\n\t  *\r\n\t  * @example\r\n\t  *\r\n\t  * var validate = new Validate(console); \r\n\t  * validate.args(name, \"string\", age, \"number\")\r\n\t  *\r\n\t  * validate.args(topic, \"string\", initialState, \"object=\"); // with optional paramter (represented by \"=\")\r\n\t  *\r\n\t  * validate.args(topic, \"string\", initialState, \"any\"); // with \"any\" type\r\n\t  *\r\n\t  * validate.args(subscribeIDStruct, \"object\") && validate.args(subscribeIDStruct.subscribeID, \"string\"); // only do second varidate if first test successful\r\n\t  *\r\n\t  * validate.args(subscribeIDStruct, \"object\", subscribeIDStruct.subscribeID, \"string\"); // only check second parm if first validated successful\r\n\t  *\r\n\t  * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\"); // depending on logic, can break into seperate validations\r\n\t  * params = params || {}; \r\n\t  * validate.args(params.subscribeCallback, \"function=\", params.publishCallback, \"function=\", params.unsubscribeCallback, \"function=\");\r\n\t  */\n\t\tthis.args = function (param1, paramType1, param2, paramType2 /*.....optional more paramter pairs....*/) {\n\t\t\tvar returnCode = true;\n\t\t\t/*if (console.getLevel() >= 4) {\r\n\t  \tvar parmCount = arguments.length;\r\n\t  \tif ((parmCount + 1) % 2 !== 0) { // parameters must come in pairs (i.e. even number)\r\n\t  \t\tfor (var i = 0; i < parmCount; i = i + 2) {\r\n\t  \t\t\tvar optionalArg = false;\r\n\t  \t\t\tvar thisArg = arguments[i];\r\n\t  \t\t\tvar thisArgType = arguments[i + 1];\r\n\t  \t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\r\n\t  \t\t\t\tthisArgType = thisArgType.slice(0, -1);\r\n\t  \t\t\t\toptionalArg = true;\r\n\t  \t\t\t}\r\n\t  \t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\r\n\t  \t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\r\n\t  \t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\r\n\t  \t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\r\n\t  \t\t\t\t\t\twarningMsg(parameterPosition, thisArg, thisArgType);\r\n\t  \t\t\t\t\t\treturnCode = false;\r\n\t  \t\t\t\t\t\tbreak;\r\n\t  \t\t\t\t\t}\r\n\t  \t\t\t\t}\r\n\t  \t\t\t}\r\n\t  \t\t}\r\n\t  \t} else {\r\n\t  \t\tconsole.warn(\"verifyParmas requires even number of parameters: \" + JSON.stringify(arguments));\r\n\t  \t}\r\n\t  }*/\n\t\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \n\t\t};\n\t\n\t\t/**\r\n\t  * Confirm parameters are valid. args2() has the same functionality as args() except a third \"parameter description\" is passed in for each argument varified\r\n\t  * Typically this for passing in a properties name for better diagnostic messages when varifying object properties.\r\n\t  * A variable number of parameter \"triples\"\" are supported.\r\n\t  *\r\n\t  * @param {string} paramName1 is descriptive name of param1 (for diagnostic message)\r\n\t  * @param {any} param1 is arg to validate\r\n\t  * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\").\r\n\t  * @param {string} paramName2 is descriptive name of param1 (for diagnostic message)\r\n\t  * @param {any} param2 is arg to validate\r\n\t  * @param {string} paramType2 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \r\n\t  * @return {boolean} returns turn if parameter list is valid; otherwise, false.\r\n\t  *\r\n\t  * @example\r\n\t  *\r\n\t  * var validate = new Utils.Validate(console); \r\n\t  * validate.args2(\"record.name\", record.name, \"string\", \"record.age\", age, \"number\")\r\n\t  *\r\n\t  * // common case using args() and args2() together\r\n\t  * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\") &&\r\n\t  *   validate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\r\n\t  *   validate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\r\n\t  */\n\t\tthis.args2 = function (paramName1, param1, paramType1, paramName2, param2, paramType2 /*.....optional, more paramter sets of three....*/) {\n\t\n\t\t\tvar returnCode = true;\n\t\t\t/*if (console.getLevel() >= 4) {\r\n\t  \tvar parmCount = arguments.length;\r\n\t  \tif ((parmCount + 1) % 3 !== 0) { // parameters must come in sets of three \r\n\t  \t\tfor (var i = 0; i < parmCount; i = i + 3) {\r\n\t  \t\t\tvar optionalArg = false;\r\n\t  \t\t\tvar thisArgName = arguments[i];\r\n\t  \t\t\tvar thisArg = arguments[i + 1];\r\n\t  \t\t\tvar thisArgType = arguments[i + 2];\r\n\t  \t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\r\n\t  \t\t\t\tthisArgType = thisArgType.slice(0, -1);\r\n\t  \t\t\t\toptionalArg = true;\r\n\t  \t\t\t}\r\n\t  \t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\r\n\t  \t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\r\n\t  \t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\r\n\t  \t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\r\n\t  \t\t\t\t\t\twarningMsg(thisArgName, thisArg, thisArgType);\r\n\t  \t\t\t\t\t\treturnCode = false;\r\n\t  \t\t\t\t\t\tbreak;\r\n\t  \t\t\t\t\t}\r\n\t  \t\t\t\t}\r\n\t  \t\t\t}\r\n\t  \t\t}\r\n\t  \t} else {\r\n\t  \t\tconsole.warn(\"verifyParmas requires even number of parameters: \" + JSON.stringify(arguments));\r\n\t  \t}\r\n\t  }*/\n\t\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \n\t\t};\n\t};\n\t\n\tmodule.exports = Validate;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar Utils = __webpack_require__(2);\n\tvar console = new Utils.Console(\"StorageClient\"); // Finsemble console\n\tvar Validate = __webpack_require__(8); // Finsemble args validator\n\tvar validate = new Validate(console);\n\t\n\t/**\r\n\t * \r\n\t * Public API for The Storage Service\r\n\t * StorageClient.[storageType].action(name,[data],cb);\r\n\t */\n\tvar RouterClient = __webpack_require__(3);\n\tvar BaseClient = __webpack_require__(10);\n\t/**\r\n\t *  @todo add clear method\r\n\t *  @example\r\n\t *\r\n\t * // Save a key value pair to local storage\r\n\t * FSBL.StorageClient.save(\"localStorage\",\"testKey\",\"testValue\")\r\n\t * // Save a key value pair to the default storage\r\n\t * FSBL.StorageClient.save(,\"testKey\",\"testValue\")\r\n\t * // Get an value from local storage\r\n\t * FSBL.StorageClient.get(\"localStorage\",\"testKey\",)\r\n\t * // Get an value from the default storage\r\n\t * FSBL.StorageClient.get(testKey\")\r\n\t * //Delete a value from local storage\r\n\t * FSBL.StorageClient.delete(\"localStorage\",\"testKey\")\r\n\t * //Delete a value from the default storage\r\n\t * FSBL.StorageClient.delete(\"testKey\")\r\n\t * \r\n\t * \r\n\t * @constructor\r\n\t */\n\tvar StorageClient = function StorageClient(params) {\n\t\tvalidate.args(params, \"object=\") && params && validate.args2(\"params.onReady\", params.onReady, \"function=\");\n\t\tvar self = this;\n\t\tBaseClient.call(this, params);\n\t\tthis.RouterClient = RouterClient;\n\t\tvar defaultStorage = null;\n\t\t//should probably come from some config;\n\t\tvar storageTypes = [\"localStorage\"];\n\t\tthis.startup = function () {};\n\t\tfunction loadStorageTypes() {\n\t\t\tfunction loadType(type) {\n\t\t\t\tif (!self[type]) {\n\t\t\t\t\tself[type] = {};\n\t\t\t\t}\n\t\t\t\tself[type][\"save\"] = function (name, data, cb) {\n\t\t\t\t\tself.save(type, name, data, cb);\n\t\t\t\t};\n\t\t\t\tself[type][\"get\"] = function (name, cb) {\n\t\t\t\t\tself.get(type, name, cb);\n\t\t\t\t};\n\t\t\t\tself[type][\"delete\"] = function (name, cb) {\n\t\t\t\t\tself.delete(type, name, cb);\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var i = 0; i < storageTypes.length; i++) {\n\t\t\t\tloadType(storageTypes[i]);\n\t\t\t}\n\t\t\tdefaultStorage = \"localStorage\";\n\t\t}\n\t\n\t\t/**\r\n\t  * Save a key value pair into storage.\r\n\t  * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t  * @param {string} name - The key to be stored under\r\n\t  * @param {any} data -  the value to be stored\r\n\t  * @param {function=} [cb] -  callback to be called on success\r\n\t  * \r\n\t  * @example\r\n\t  * StorageClient.save(\"localStorage\",\"testKey\",\"testValue\")\r\n\t  */\n\t\tthis.save = function (storageType, name, data, cb) {\n\t\t\t//use the first storage if no type is given\n\t\t\tif (arguments.length < 4 && typeof data === \"function\") {\n\t\t\t\tcb = arguments[2];\n\t\t\t\tdata = arguments[1];\n\t\t\t\tname = arguments[0];\n\t\t\t\tstorageType = defaultStorage;\n\t\t\t}\n\t\t\tvalidate.args(storageType, \"any\", name, \"string\", data, \"any\", cb, \"function=\");\n\t\t\tself.RouterClient.query('Storage.save', { storageType: storageType, name: name, payload: data }, function (err, response) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\t/**\r\n\t  * Get a value from storage.\r\n\t  * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t  * @param {string} name - The key to pull from storage\r\n\t  * @param {function} [cb] -  callback to be called on success\r\n\t  * \r\n\t  * @todo use default\r\n\t  * @example\r\n\t  * StorageClient.get(\"localStorage\",\"testKey\")\r\n\t  */\n\t\tthis.get = function (storageType, name, cb) {\n\t\t\tif (arguments.length < 3 && typeof name === \"function\") {\n\t\t\t\tcb = arguments[1];\n\t\t\t\tname = arguments[0];\n\t\t\t\tstorageType = defaultStorage;\n\t\t\t}\n\t\t\tvalidate.args(storageType, \"string\", name, \"string\", cb, \"function=\");\n\t\t\tself.RouterClient.query('Storage.get', { storageType: storageType, name: name }, function (err, response) {\n\t\t\t\tconsole.log('clienterr', err);\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\tthis.getMultiple = function (storageType, query, cb) {\n\t\t\tif (arguments.length < 3 && typeof query === \"function\") {\n\t\t\t\tcb = arguments[1];\n\t\t\t\tquery = arguments[0];\n\t\t\t\tstorageType = defaultStorage;\n\t\t\t}\n\t\t\tself.RouterClient.query('Storage.getMultiple', { storageType: storageType, query: query }, function (err, response) {\n\t\t\t\tconsole.log('clienterr', err, response);\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\t/**\r\n\t  * Delete a value from storage.\r\n\t  * @param {(string|object)=} [storageType] -  The storage type to use. If ommitted, the default storage is used\r\n\t  * @param {string} name - The key to delete from storage\r\n\t  * @param {function} [cb] -  callback to be called on success\r\n\t  * @todo use default\r\n\t  * @example\r\n\t  * StorageClient.get(\"localStorage\",\"testKey\")\r\n\t  */\n\t\tthis.delete = function (storageType, name, cb) {\n\t\t\tif (arguments.length < 3 && typeof name === \"function\") {\n\t\t\t\tcb = arguments[1];\n\t\t\t\tname = arguments[0];\n\t\t\t\tstorageType = defaultStorage.keys[0];\n\t\t\t}\n\t\t\tvalidate.args(storageType, \"any\", name, \"string\", cb, \"function=\");\n\t\t\tself.RouterClient.query('Storage.delete', { storageType: storageType, name: name }, function (err, response) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\t//Load the storage types\n\t\tloadStorageTypes();\n\t};\n\t\n\tvar storageClient = new StorageClient({\n\t\tonReady: function onReady(cb) {\n\t\t\tstorageClient.startup();\n\t\t\tconsole.log(\"storage online\");\n\t\t\tcb();\n\t\t},\n\t\tname: \"storageClient\"\n\t});\n\tstorageClient.requiredServices = [];\n\tstorageClient.initialize();\n\tmodule.exports = storageClient;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar Utils = __webpack_require__(2);\n\tvar console = new Utils.Console(\"BaseClient\"); // Finsemble console\n\tvar Validate = __webpack_require__(8); // Finsemble args validator\n\tvar validate = new Validate(console);\n\t\n\tvar Client = function Client(params) {\n\t\tvalidate.args(params, \"object=\");\n\t\tvar self = this;\n\t\tvar status = \"offline\";\n\t\tvar onReady;\n\t\tthis.name;\n\t\tif (params) {\n\t\t\tonReady = params.onReady;\n\t\t\tthis.name = params.name;\n\t\t}\n\t\tthis.finWindow = fin.desktop.Window.getCurrent();\n\t\tthis.clientName = this.finWindow.name; //The current window\n\t\n\t\tthis.routerClient = __webpack_require__(3);\n\t\tthis.requiredServices = [];\n\t\tthis.onlineServices = [];\n\t\n\t\tthis.addServices = function (services) {\n\t\t\tvalidate.args(services, \"any\");\n\t\t\tif (!services) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!Array.isArray(services)) {\n\t\t\t\tservices = [services];\n\t\t\t}\n\t\t\tfor (var i = 0; i < services.length; i++) {\n\t\t\t\tif (this.onlineServices.indexOf(services[i]) === -1) {\n\t\t\t\t\tthis.onlineServices.push(services[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.checkRequiredServices();\n\t\t};\n\t\tthis.checkRequiredServices = function () {\n\t\t\tfor (var i = 0; i < this.requiredServices.length; i++) {\n\t\n\t\t\t\tif (this.onlineServices.indexOf(this.requiredServices[i]) > -1) {\n\t\t\t\t\tthis.requiredServices.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.checkOnline();\n\t\t};\n\t\tthis.checkOnline = function () {\n\t\t\tvar self = this;\n\t\t\tif (status === \"online\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.requiredServices.length === 0) {\n\t\n\t\t\t\tif (onReady) {\n\t\t\t\t\treturn onReady(function () {\n\t\t\t\t\t\tstatus = \"online\";\n\t\t\t\t\t\tself.routerClient.transmit(self.clientName + \"FSBLClient\", self.name);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.initialize = function () {\n\t\t\tsetup();\n\t\t\tthis.checkRequiredServices();\n\t\t};\n\t\tfunction setup() {\n\t\t\tself.routerClient.query(\"ServiceManager.getServices\", {}, function (err, event) {\n\t\t\t\tself.addServices(event.data);\n\t\t\t});\n\t\t\tself.routerClient.addListener(\"ServiceManager.serviceOnline\", function (err, event) {\n\t\t\t\tself.addServices(event.data);\n\t\t\t});\n\t\t};\n\t};\n\t\n\tmodule.exports = Client;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar RouterClient = __webpack_require__(3);\n\tvar BaseClient = __webpack_require__(10);\n\tvar util = __webpack_require__(2);\n\tvar console = new util.Console(\"BaseClient\"); // Finsemble console\n\tvar Validate = __webpack_require__(8); // Finsemble args validator\n\tvar validate = new Validate(console);\n\t\n\t/**\r\n\t * Finsemble windowDescriptor. This is a superset of the Openfin Window object.\r\n\t * @typedef {Object} windowDescriptor\r\n\t * @property {string} url url to load.\r\n\t * @property {number} defaultTop Top pixel of the window. The top left of the screen is 0.\r\n\t * @property {number} defaultLeft Left edge of the window.\r\n\t * @property {number} defaultWidth Window width.\r\n\t * @property {number} defaultHeight Window height\r\n\t * @property {boolean} [showTaskbarIcon=true] Whether to show the icon in the taskbar.\r\n\t * @property {number} [minWidth=0] Minimum width that the window can be resized to.\r\n\t * @property {number} [minHeight=0] Minimum height that the window can be resized to.\r\n\t * @property {boolean} [autoShow=true] Whether the window should render in the background. If this option is set to false, you must tell the window to show itself at some point. You can use {@link WindowClient#show}.\r\n\t * @property {boolean} [frame=false] Whether the window should be rendered with a sytem frame. \r\n\t * @property {boolean} [resizable=true] Whether the window can be resized.\r\n\t * @property {boolean} [maximizable=true] Whether the window can be maximized.\r\n\t * @property {boolean} [alwaysOnTop=false] Whether the window should always sit on top of other finsemble windows.\r\n\t * @property {boolean} [fixedPosition=false] Whether the window should remain where it was spawned.\r\n\t * @property {Object} [resizeRegion] \r\n\t * @property {number} [resizeRegion.size=10]\r\n\t * @property {number} [resizeRegion.bottomCorner= 10]\r\n\t */\n\t\n\t/**\r\n\t * \"Private\" properties of the windowDescriptor\r\n\t * @private @property @todo { boolean } [hoverFocus = false]\r\n\t * @private @property {boolean} [saveWindowState=false] Openfin window state saving. Don't want to\r\n\t * have them saving the window state since we are.Turning this to true is untested.Do not change.\r\n\t */\n\t\n\t/**\r\n\t * \r\n\t * The launcher client handles spawning windows for the application.\r\n\t * @constructor\r\n\t */\n\tfunction LauncherClient(params) {\n\t\tvalidate.args(params, \"object=\") && params && validate.args2(\"params.onReady\", params.onReady, \"function=\");\n\t\n\t\t/** @alias LauncherClient# */\n\t\tvar self = this;\n\t\tBaseClient.call(this, params);\n\t\n\t\t/**\r\n\t  * Get a list of available components. This is useful if you need to list all of your components (e.g., in a toolbar).\r\n\t  * @param {Function} cb Callback to be invoked after function is completed.\r\n\t  * @example <caption>Something like this could be done to retrieve the list of components inside of something like a Toolbar or a launcher.</caption>\r\n\t  * var self=this; \r\n\t  * FSBL.LauncherClient.getComponentList(function(err, data){\r\n\t  *\tself.setState({\r\n\t \tcomponentList: data\r\n\t  });\r\n\t  * });\r\n\t  */\n\t\tthis.getComponentList = function (cb) {\n\t\t\tvalidate.args(cb, \"function\");\n\t\n\t\t\tRouterClient.query('Launcher.componentList', {}, function (err, response) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response.data);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\t/**\r\n\t  * Get the defaults for an individual component.\r\n\t  * @param {String} componentType The type of the component you are looking for\r\n\t  * @param {Function} cb Callback to be invoked after function is completed.\r\n\t  * @example\r\n\t  * FSBL.launcherClient.getComponentInfo('Advanced Chart', function(err, data){\r\n\t  *\t//do something with the default values for Advanced chart.\r\n\t  * });\r\n\t  */\n\t\tthis.getComponentInfo = function (componentType, cb) {\n\t\t\tvalidate.args(cb, \"function\");\n\t\t\tconsole.log(\"getComponentInfo \" + componentType);\n\t\t\tRouterClient.query('Launcher.componentList', {}, function (err, response) {\n\t\t\t\twindow.console.log(\"got the info\", err, response, cb);\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response.data[componentType]);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\t/**\r\n\t  * Asks the Launcher service to spawn a window. The examples below show the basic functionality that the launcher offers. Please see the [Window Spawning]{@tutorial spawningWindows} tutorial for advanced functionality.\r\n\t  * @param {String} component - Type of the component to launch\r\n\t  * @param {Object} params Properties to merge with the default windowDescriptor.\r\n\t  * @param {Function=} cb Callback to be invoked after function is completed.'\r\n\t  *\r\n\t  * @example\r\n\t  * //Spawns an advanced chart with the default positioning.\r\n\t  * FSBL.LauncherClient.spawn(\"Advanced Chart\");\r\n\t  * //Spawns an advanced chart in the center of the monitor from where the spawn call originated. If A component on monitor 3 invokes Spawn and passes in a <code>defaultLeft</code> of 'center', it will spawn on monitor 3.\r\n\t  * FSBL.LauncherClient.spawn(\"Advanced Chart\", {\r\n\t  * \tdefaultLeft: 'center',\r\n\t  * \tdefaultTop: 'center'\r\n\t  * });\r\n\t  */\n\t\tthis.spawn = function (component, params, cb) {\n\t\t\tparams.component = component;\n\t\t\tif (!params.customData) {\n\t\t\t\tparams.customData = {};\n\t\t\t}\n\t\t\tif (!params.customData.monitorDimensions) {\n\t\n\t\t\t\treturn util.retrieveMonitorDimensions(function (err, dims) {\n\t\t\t\t\twindow.console.log(\"dims\", dims);\n\t\t\t\t\tparams.customData.monitorDimensions = dims.monitorDimensions;\n\t\t\t\t\twindow.console.log(\"params\", params);\n\t\t\t\t\tcallSpawn(params, cb);\n\t\t\t\t});\n\t\t\t}\n\t\t\tcallSpawn(params, cb);\n\t\t};\n\t\tfunction callSpawn(params, cb) {\n\t\t\tRouterClient.query('Launcher.spawn', params, function (err, response) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tcb(err, response);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t/**\r\n\t * Spawns a new openfin window.\r\n\t * @param {string} windowName\tThe name of the window you are looking for\r\n\t * @param {function} cb Callback\r\n\t */\n\t\tthis.getWindow = function (windowName, cb) {\n\t\t\tRouterClient.query('Launcher.getWindow', windowName, function (err, response) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\t/**\r\n\t * Spawns a new openfin window.\r\n\t * @param {string} windowName\tThe name of the window you are looking for\r\n\t * @param {function} cb Callback\r\n\t */\n\t\tthis.isWindowOpen = function (windowName, cb) {\n\t\t\tRouterClient.query('Launcher.isWindowOpen', windowName, function (err, response) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\tthis.getActiveDescriptors = function (cb) {\n\t\t\tRouterClient.query('Launcher.getActiveDescriptors', {}, function (err, response) {\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(err, response);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\t/**\r\n\t * Spawns a new openfin window.\r\n\t * @param {object} params\tThe name of the window you are looking for\r\n\t * @param {object} params.monitorDimensions\r\n\t * @param {number} params.width\r\n\t * @param {number} params.hight\r\n\t * @param {number} [params.widnow]\r\n\t * @param {function} cb Callback\r\n\t */\n\t\tthis.moveWindowCenter = function (params) {\n\t\t\tif (!params.monitorDimensions) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar centerTop = (params.monitorDimensions.height - params.height) / 2;\n\t\t\tvar centerLeft = (params.monitorDimensions.width - params.width) / 2;\n\t\t\twindow.console.log(params, centerTop, centerLeft + params.monitorDimensions.left);\n\t\t\tif (!params.window) {\n\t\t\t\treturn fin.desktop.Window.getCurrent().moveTo(centerLeft + params.monitorDimensions.left, centerTop);\n\t\t\t}\n\t\t\tconsole.log(\"move this window\");\n\t\t\treturn params.window.moveTo(centerLeft + params.monitorDimensions.left, centerTop, function () {\n\t\t\t\tparams.window.bringToFront();\n\t\t\t});\n\t\t};\n\t\treturn this;\n\t};\n\t\n\tvar launcherClient = new LauncherClient({\n\t\tonReady: function onReady(cb) {\n\t\t\tcb();\n\t\t},\n\t\tname: \"launchClient\"\n\t});\n\tlauncherClient.requiredServices = [];\n\tlauncherClient.initialize();\n\t\n\tmodule.exports = launcherClient;\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=FrontEnd.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// e:/nodeProjects/finsemble/libs/FrontEnd.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}